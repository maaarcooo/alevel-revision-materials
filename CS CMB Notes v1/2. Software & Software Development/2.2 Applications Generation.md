# 2.2 Applications Generation - Revision Notes

## Nature of Applications

### Applications Software
- **Purpose**: Designed for end-users to perform specific tasks
- **Dependency**: Requires systems software to run
- **Examples**: Word processors (Microsoft Word), spreadsheets (Excel), web browsers (Chrome), database management (MySQL), graphics software (Photoshop)

### Systems Software
- **Purpose**: Low-level software responsible for running the computer system smoothly
- **Functions**: Interacts with hardware, provides platform for applications software
- **Characteristics**: User doesn't directly interact with it, ensures high performance
- **Examples**: Operating systems, utility programs, device drivers, library programs

---

## Utilities

**Definition**: System software with specific functions for maintaining operating system performance.

### Key Utility Types

**Compression**
- Reduces file size for transmission/storage
- Used for large files across the Internet
- OS provides compression/decompression utilities

**Disk Defragmentation**
- Rearranges fragmented files on hard disk
- Improves read/write times and performance
- Note: Modern SSDs generally don't require defragmentation

**Antivirus**
- Detects potential threats to the computer
- Alerts users and removes threats
- Protects against viruses and malware

**Automatic Updating**
- Keeps OS up to date
- Tackles bugs and security flaws
- Reduces vulnerability to malware and hacking

**Backup**
- Creates routine copies of selected files
- User specifies frequency and files
- Enables recovery after power failure, attacks, or accidents

---

## Open Source vs Closed Source

### Open Source Software

**Definition**: Source code is freely available, can be viewed, modified and redistributed

**Advantages**:
- Can be modified and improved by anyone
- Technical support from online community
- Can be modified and sold on
- Often free to use

**Disadvantages**:
- Online support may be insufficient or incorrect
- No official user manuals
- Lower security (may not be developed in controlled environment)

### Closed Source Software

**Definition**: Source code is proprietary, users cannot access it, requires appropriate license

**Advantages**:
- Thorough, regular, well-tested updates
- Expert support and user manuals from company
- High security (professionally developed)

**Disadvantages**:
- License restricts number of users
- Users cannot modify/improve software
- Can be costly

### Selection Considerations
- **Costs**: Implementation, maintenance, training, licensing
- **Functionality**: Available features, ease of use
- **Suitability**: Match software to specific task requirements

---

## Translators

**Purpose**: Convert source code from high-level language to low-level machine code

### Compilers

**Process**: Translate entire source code into machine code all at once

**Advantages**:
- Faster execution time once compiled
- No translator needed during execution
- Can be optimised for performance

**Disadvantages**:
- Longer initial compilation time
- Must recompile entire program for any changes
- Platform-specific (not portable between different systems)

**Use Case**: Production environments where performance is critical

### Interpreters

**Process**: Translate and execute code line-by-line

**Advantages**:
- Faster to start execution
- Easier debugging (stops at error line)
- More portable (runs on any platform with appropriate interpreter)
- Good for incremental testing

**Disadvantages**:
- Slower overall execution (translates each run)
- Requires interpreter present during execution

**Use Case**: Development, testing, and debugging

### Assemblers

**Purpose**: Translate assembly language (low-level) into machine code

**Characteristics**:
- Almost one-to-one translation (one line assembly ≈ one line machine code)
- Platform-specific (depends on processor instruction set)
- Considered "next level up" from machine code

**Common Languages and Their Translators**:
- C, C++, Java, Swift → Compiler
- Python, JavaScript, Ruby, PHP → Interpreter
- Assembly Language → Assembler

---

## Stages of Compilation

### 1. Lexical Analysis

**Purpose**: Study the vocabulary/words of the language

**Process**:
1. Remove whitespace and comments
2. Identify lexical tokens (keywords, identifiers, operators, separators)
3. Create token table with each token and its type

**Token Types**:
- **Keywords**: var, const, function, if, while, return
- **Identifiers**: Variable names, function names
- **Operators**: +, ++, -, *, =
- **Separators**: , ; { } ( )

**Output**: Token table and symbol table

### 2. Syntax Analysis (Parsing)

**Purpose**: Check tokens adhere to grammar rules of the programming language

**Process**:
1. Analyse tokens against language syntax rules
2. Flag syntax errors (e.g., undeclared variable type, incomplete brackets)
3. Perform semantic analysis (detect logic mistakes)
4. Create Abstract Syntax Tree (AST)

**Common Errors Detected**:
- Syntax errors: Undeclared variable type, mismatched parentheses, missing semicolons
- Semantic errors: Multiple declarations, undeclared identifiers

**Output**: Abstract Syntax Tree (AST) - graph-based representation of code

### 3. Code Generation

**Purpose**: Convert AST into executable machine code

**Process**: Traverse the AST to generate object code that can be executed by the computer

### 4. Optimisation

**Purpose**: Improve code efficiency without changing functionality

**Actions**:
- Remove redundant/insignificant code
- Group repeated sections into more efficient code
- Reduce memory requirements
- Improve execution speed

**Trade-off**: Adds to compilation time, but improves runtime performance

**Warning**: Excessive optimisation may alter program behaviour

---

## Libraries, Linkers & Loaders

### Libraries

**Definition**: Collection of pre-written, pre-compiled code (functions, procedures, classes) that can be incorporated into programs

**Types**:
- **Standard Libraries**: Come with programming language, provide basic functionalities
- **Third-Party Libraries**: Created by others, shared through package managers

**Advantages**:
- Saves time and effort (no need to write from scratch)
- Reliable (tested and optimised)
- Reusable across multiple projects
- Community support and documentation

**Disadvantages**:
- Dependency issues (if library discontinued/not maintained)
- Compatibility problems with different versions
- Can add unnecessary complexity/size for small tasks

### Linkers

**Purpose**: Combine different code files and libraries into single executable

**Types**:

**Static Linking**:
- Libraries added directly into main file at compile time
- Increases file size
- External updates don't affect program
- Can use specific library version

**Dynamic Linking**:
- Only addresses/references to libraries included
- Libraries loaded at runtime by loader
- Smaller file sizes
- External updates automatically feed through
- Requires library present during execution

### Loaders

**Purpose**: Operating system programs that load executable files into memory for execution

**Process**: When file executed, loader retrieves library/subroutine from specified memory location

---

## Key Distinctions

### Applications vs Systems Software
- **Applications**: User-facing, task-specific, depends on systems software
- **Systems**: Behind-the-scenes, hardware interaction, OS maintenance

### Compiler vs Interpreter
- **Compiler**: All-at-once, faster execution, platform-specific, harder to debug
- **Interpreter**: Line-by-line, slower execution, portable, easier to debug

### Static vs Dynamic Linking
- **Static**: Compiled in, larger files, independent, specific version
- **Dynamic**: Referenced, smaller files, requires library at runtime, gets updates

### Syntax vs Semantic Errors
- **Syntax**: Breaking grammar rules (missing semicolon, mismatched brackets)
- **Semantic**: Logic mistakes (undeclared identifiers, multiple declarations)

---

## Exam Tips

1. **Application Software Questions**: Always link features to user needs from scenario
2. **Utility Software**: Know specific purpose and how it improves OS performance
3. **Open/Closed Source**: Consider both creator and user perspectives
4. **Translator Selection**: Match translator type to language and use case
5. **Compilation Stages**: Remember the order and what each stage produces
6. **Libraries**: Focus on efficiency vs complexity trade-offs
7. **Use Examples**: Reference specific software (MySQL, Python, Chrome) when explaining concepts
