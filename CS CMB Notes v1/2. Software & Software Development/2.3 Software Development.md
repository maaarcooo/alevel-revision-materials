# 2.3 Software Development - Revision Notes

## Common Stages in Software Development Life Cycles (SDLCs)

Most software development approaches share these core stages:

### 1. Analysis
- **Stakeholders** define requirements for the finished product
- Clearly defines the problem and system requirements
- Considers:
  - Strengths/weaknesses of current solutions
  - Types of data (inputs, outputs, stored data, volumes)
- Includes **feasibility study** using **TELOS**:
  - **T**echnical: Is the project possible with available technology?
  - **E**conomic: Can it be financed short-term and long-term?
  - **L**egal: Can the project comply with legal requirements?
  - **O**perational: Can it be successfully implemented and maintained?
  - **S**cheduling: Can it be completed within the time available?

### 2. Design
Designs different aspects of the new system:
- **Inputs**: volume, methods, frequency
- **Outputs**: volume, methods, frequency
- **Security features**: access levels, security requirements
- **Hardware setup**: compatibility considerations
- **User interface**: menus, accessibility, navigation
- **Test plan** may be designed at this stage

### 3. Development
- Design is split into **individual, self-contained modules**
- Modules allocated to teams for programming
- Different sections developed in parallel (in agile approaches)

### 4. Testing
Program tested against the test plan. Types of testing include:

**Alpha Testing**
- Carried out **in-house** by development teams
- Bugs identified and fixed

**Beta Testing**
- Carried out by **end-users** after alpha testing
- User feedback informs next development stage

**White Box Testing**
- Test plan based on **internal structure** of program
- All possible routes through the program are tested
- Performed by development teams

**Black Box Testing**
- Testers **unaware of internal structure**
- Test plan traces inputs and outputs
- Can be performed by developers or end-users

### 5. Implementation
- Software installed onto users' systems after testing complete

### 6. Evaluation
- Effectiveness evaluated against system requirements
- Criteria considered:
  - **Robustness**: handles errors gracefully
  - **Reliability**: performs consistently
  - **Portability**: works on different systems
  - **Maintainability**: easy to update and fix

### 7. Maintenance
- End-users flag errors or improvements
- Regular software updates to:
  - Fix bugs
  - Address security issues
  - Implement improvements

---

## Software Development Methodologies

### 1. Waterfall Lifecycle

**Description**: Traditional sequential model with clearly defined stages completed in order from start to finish.

**Stages**:
1. Analysis (including feasibility study)
2. Design
3. Implementation
4. Evaluation
5. Maintenance

**Key Characteristics**:
- Linear progression through stages
- Each stage must be completed before the next begins
- Changes require revisiting all stages back to the point of change

**Benefits**:
- Simple and easy to understand
- Clear stages and milestones
- Well-documented
- Easy to measure progress
- Suitable for well-defined projects

**Drawbacks**:
- **Inflexible** - difficult to implement changes once started
- **Expensive to fix late problems** - issues discovered late are costly
- **Long development cycle** - sequential nature can cause delays
- **Limited user involvement** - users only involved at analysis and evaluation stages
- No risk analysis

**Suitability**:
- Projects with **stable, well-understood requirements**
- Low-risk projects
- Projects requiring high quality and compliance
- General-purpose software
- Static projects needing little user input

---

### 2. Agile Methodologies

**Description**: Collection of methodologies emphasising flexibility, adaptability, and rapid response to changing requirements.

**Key Characteristics**:
- Problem broken into sections developed in parallel
- Design and analysis phases often occur together
- Different sections at different development stages simultaneously
- **Working prototype delivered early**
- Prototypes built upon iteratively
- New prototypes delivered regularly
- Less focus on documentation, more on user satisfaction

**Benefits**:
- Highly flexible and adaptable
- Quick response to changing requirements
- Regular user input and feedback
- Produces high-quality code
- Rapid delivery

**Drawbacks**:
- Poor documentation
- Requires consistent interaction between user and programmer
- **Scope creep** - flexible nature may lead to uncontrolled requirement changes
- Not suitable for large projects
- Collaboration dependency

**Suitability**:
- Small to medium projects
- Projects with **unclear or changing requirements**
- Fast-paced development environments
- Projects requiring regular user feedback

---

### 3. Extreme Programming (XP)

**Description**: Agile model featuring paired programming and constant user involvement.

**Development Team**:
- Pair of programmers working together
- Representative end-user present
- One programmer writes code, other critiques in real-time

**Steps**:
1. **Identify user stories and requirements**
   - Work with stakeholders to gather requirements
   - Requirements written as user stories (e.g., "As a user, I want to...")
   
2. **Plan the sprint** (1-4 weeks)
   - Break requirements into tasks
   - Choose features for current sprint
   - Define sprint goal
   
3. **Design the solution**
   - Simple and adaptable design
   - No heavy upfront documentation
   
4. **Develop the features**
   - Write code for sprint tasks
   - Pair programming or small teams
   
5. **Test continuously**
   - Unit testing, integration testing, acceptance testing
   - Testing ongoing, not saved for end
   
6. **Review progress (Sprint Review)**
   - Demo working software to stakeholders
   - Collect feedback and identify improvements
   
7. **Reflect on process (Sprint Retrospective)**
   - Team reflects on successes and areas for improvement
   - Focus on team performance and process optimisation
   
8. **Release** (after sprint or set of sprints)
   - Deploy working software
   
9. **Repeat**
   - Next sprint with updated priorities and feedback

**Key Practices**:
- **Pair programming** produces high-quality code
- Maximum **40 hours per week** to maintain quality
- Each iteration generates a **'working version'**
- Built on **user stories** from end-users

**Benefits**:
- Produces high-quality code
- Constant user involvement ensures high usability
- Flexible and adaptable
- Frequent communication between team and stakeholders
- Continuous testing ensures quality

**Drawbacks**:
- **High cost** - two programmers on one project
- Teamwork essential - requires experienced team members
- Intensive collaboration can lead to burnout
- May lack documentation
- Scope creep possible
- End-user may not always be available

**Suitability**:
- Small to medium projects
- Projects with changing requirements
- High customer involvement available
- Projects requiring excellent usability

---

### 4. Spiral Model

**Description**: Combines iterative (agile) and sequential (waterfall) processes with emphasis on risk management.

**Four Key Stages** (repeated in cycles):
1. **Planning**
   - Define objectives, alternatives, and constraints
   
2. **Risk Analysis**
   - Identify and assess potential risks
   - Plan mitigation strategies
   - Project terminated if too risky
   
3. **Engineering**
   - Develop next version of product
   - Includes design, coding, testing, integration
   
4. **Evaluation and Feedback**
   - Review progress with stakeholders
   - Plan next iteration

**Key Characteristics**:
- Process repeats in spiral loops
- Each loop represents a development phase
- Continues until final product ready
- Produces prototypes throughout

**Benefits**:
- **Thorough risk analysis and mitigation**
- Flexible to changes and adaptations
- Strong customer involvement
- Tailored customer feedback
- Incremental releases provide early partial solutions

**Drawbacks**:
- **Complex and harder to manage**
- **Time-consuming** - emphasis on planning and risk management
- **Expensive** - requires hiring risk assessors
- Often requires more resources
- Lack of focus on code efficiency
- High costs due to constant prototyping
- Not suitable for small projects

**Suitability**:
- **Large, complex, risk-intensive projects**
- Projects where requirements may change
- High-budget projects
- Projects requiring extensive risk management

---

### 5. Rapid Application Development (RAD)

**Description**: Iterative methodology emphasising fast development using partially functioning prototypes.

**Steps**:
1. **Requirement Planning**
   - Gather general system requirements
   - Define constraints and assumptions
   - Requirements initially gathered using **focus groups**
   
2. **User Design and Prototyping**
   - Collaborate with users to develop prototypes
   - Ensure alignment with user needs
   - Develop 'incomplete' version for user trial
   
3. **Construction/Iterative Development**
   - Build system incrementally
   - Continuous user feedback and adaptation
   - User feedback generates improved prototype
   
4. **Cutover/Deployment**
   - Transition product to live environment
   - Includes user training, support, documentation
   
5. **Maintenance and Updates**
   - Continue to adapt and improve
   - Based on user feedback and needs

**Key Characteristics**:
- Uses **partially functioning prototypes**
- Continually built upon until matching requirements
- Becomes final product when requirements met
- Focus on core features

**Benefits**:
- **Speed** - rapid development and delivery
- User involvement ensures alignment with needs
- Flexible to changing requirements
- Highly usable finished product
- Adaptable throughout process
- Focus on core features reduces development time
- Incremental development with constant feedback

**Drawbacks**:
- Dependent on strong team collaboration
- Potential lack of quality - speed may compromise testing/documentation
- Not suitable for small projects
- Can lead to scope creep
- Collaboration dependence
- Less scalable
- Quality issues possible
- Code may be inefficient due to changing requirements

**Suitability**:
- Projects where **rapid delivery is required**
- Requirements can be developed and refined on the go
- User requirements incomplete or unclear at start
- Small to medium, low-budget projects
- Short time-frames
- Active user participation available

---

## Comparison of Methodologies

| **Methodology** | **Tasks/Processes** | **Benefits** | **Drawbacks** | **Suitability** |
|-----------------|---------------------|--------------|---------------|-----------------|
| **Waterfall** | Linear stages: Requirements, Design, Coding, Testing, Deployment, Maintenance | Simple, clear stages, well-defined projects | Inflexible, expensive late changes, long development cycle | Well-defined projects with stable requirements |
| **Agile** | Iterative: Planning, Designing, Coding, Testing, Reviewing | Flexible, constant customer involvement, rapid delivery | Scope creep, collaboration dependency, not for large projects | Fast-paced projects with changing requirements |
| **Extreme Programming (XP)** | Iterative sprints with pair programming and user stories | Produces high-quality code, constant user involvement | High cost, teamwork essential, end-user may not be available | Small to medium projects requiring excellent usability |
| **Spiral** | Cyclic: Planning, Risk Analysis, Engineering, Evaluation | Risk management focus, tailored customer feedback | Complex, expensive, expert risk assessment required | Complex projects needing extensive risk management |
| **RAD** | Phases: Requirements Planning, User Design, Construction, Cutover | Faster development, user feedback, adaptable | Collaboration dependence, less scalable, quality issues | Projects requiring quick delivery with active user participation |

---

## Writing and Following Algorithms

**Definition**: An algorithm is a set of instructions used to solve a problem.

### Key Qualities of Good Algorithms:

1. **Clearly defined inputs** - what is valid and invalid must be specified
2. **Always produces valid output** for any defined input
3. **Handles invalid inputs** appropriately
4. **Always reaches a stopping condition** (terminates)
5. **Well-documented** for future reference
6. **Well-commented** so modifications can easily be made
7. **Efficient** - uses appropriate data structures and logic

### Algorithm Requirements:
- Must be unambiguous
- Must be executable
- Must be finite (terminates)
- Must be effective for the problem domain

---

## Exam Tips

### When Comparing Methodologies:
1. Identify specifics from the scenario (team size, budget, timeline, requirement clarity)
2. Consider the project's risk level
3. Evaluate the need for flexibility
4. Assess user involvement requirements
5. Consider documentation needs
6. Justify your recommendation based on context

### Common Exam Questions:
- Justify which methodology to use for a given scenario
- Compare and contrast two methodologies
- Explain advantages/disadvantages of a specific approach
- Describe stages of a particular methodology
- Explain types of testing and when to use them

### Key Points to Remember:
- **Waterfall** = sequential, inflexible, well-documented
- **Agile/XP** = iterative, flexible, user-focused, less documentation
- **Spiral** = risk-focused, expensive, large-scale
- **RAD** = fast, prototype-based, user-feedback driven
- Testing should always be thorough regardless of methodology
- User involvement varies significantly between methodologies
