# 2.4 Types of Programming Language - Revision Notes

## Programming Paradigms

**Definition:** Different approaches to using a programming language to solve a problem.

### Main Categories

```
Programming Paradigms
    ├── Imperative (specifies actions to be performed)
    │   ├── Procedural
    │   └── Object-Oriented
    └── Declarative (states desired result)
        ├── Functional
        └── Logic
```

### Procedural Programming

**Characteristics:**
- Uses sequence of instructions executed step-by-step
- May be contained within procedures/functions
- Employs modular design for reusability

**Core Programming Constructs:**
- **Sequence** - code executed line-by-line, top to bottom
- **Selection** - IF statements for conditional execution
- **Iteration** - FOR, WHILE, REPEAT UNTIL loops
- **Recursion** - functions calling themselves until base case met

**Examples:** Pascal, Python, C, Logo

**Advantages:**
- Efficient for straightforward tasks
- Clear flow of control
- Easy to implement algorithms

**Disadvantages:**
- Can become unwieldy for large programs
- Lack of modularity leads to code redundancy
- Not ideal for complex states/behaviours

### Object-Oriented Programming (OOP)

**Characteristics:**
- Built around entities called **objects** formed from **classes**
- Focuses on reusable, maintainable code
- Applicable to problems with similar characteristics

**Examples:** Python, Java, C#, Delphi

**Advantages:**
- High level of reusability (inheritance, polymorphism)
- Encapsulation makes code more reliable
- Modular structure easy to maintain and update
- High level of abstraction

**Disadvantages:**
- Requires different style of thinking
- Not suited to all problem types
- Unsuitable for smaller problems
- Can result in longer programs where few components are reused

### Declarative Programming

**Functional:**
- Uses reusable set of functions
- Programs consist of function calls
- Closely linked to mathematics
- **Examples:** Haskell, C#, Java

**Logic:**
- Defines set of facts and rules
- Uses queries to find answers
- Common in AI and expert systems
- **Example:** Prolog

---

## Procedural Languages

### Key Features

**Data Types:**
- Traditional types: integers, strings, boolean
- Data structures: arrays, dictionaries

**Structured Programming:**
Uses four main control structures to determine program flow:
1. Sequence
2. Selection  
3. Iteration
4. Recursion

---

## Assembly Language

### Overview

- **Level:** Low-level language (one level above machine code)
- **Translation:** Converted by assembler to machine code
- **Key Feature:** Uses mnemonics instead of binary
- **Limitation:** Processor-specific (not portable)
- **Use Case:** Direct hardware interaction, embedded systems

### Little Man Computer (LMC) Mnemonics

| Mnemonic | Instruction | Function |
|----------|-------------|----------|
| **ADD** | Add | Add value at memory address to Accumulator |
| **SUB** | Subtract | Subtract value at memory address from Accumulator |
| **STA** | Store | Store Accumulator value at memory address |
| **LDA** | Load | Load value from memory address into Accumulator |
| **INP** | Input | User input stored in Accumulator |
| **OUT** | Output | Print Accumulator value |
| **HLT** | Halt | Stop program execution |
| **DAT** | Data | Create flag/label for data storage |
| **BRZ** | Branch if zero | Conditional branch if Accumulator = 0 |
| **BRP** | Branch if positive | Conditional branch if Accumulator ≥ 0 |
| **BRA** | Branch always | Unconditional branch |

### LMC Example - Adding Two Numbers

```
INP          // Input first number
STA 90       // Store at memory location 90
INP          // Input second number
ADD 90       // Add value at location 90
OUT          // Output result
HLT          // End program
DAT          // Memory location 90
```

---

## Modes of Addressing Memory

### Machine Code Structure

```
┌─────────────────────────┬──────────────┐
│       OPCODE            │   OPERAND    │
├────────────┬────────────┤              │
│ Instruction│ Addressing │              │
│            │   Mode     │              │
└────────────┴────────────┴──────────────┘
```

**Opcode:** Specifies the instruction to perform  
**Operand:** Value related to data for the instruction  
**Addressing Mode:** Specifies how to interpret the operand

### Four Addressing Modes

#### 1. Immediate Addressing
- **Operand contains:** The actual value in binary
- **Example:** Load the value 5

#### 2. Direct Addressing
- **Operand contains:** Address where value is stored
- **Used in:** Little Man Computer (LMC)
- **Example:** Load value from address 50

#### 3. Indirect Addressing
- **Operand contains:** Address of register containing another address
- **Process:** Operand → Register → Address → Value
- **Example:** Operand = 100, Register at 100 contains 200, value at 200 is loaded

#### 4. Indexed Addressing
- **Uses:** Index register storing an offset value
- **Calculation:** Address = Operand + Index Register
- **Purpose:** Access data stored contiguously (e.g., arrays)
- **Example:** Operand = 1000, Index = 5, Access address 1005

**Why use addressing modes?**
- Allows greater number of memory locations to be accessed
- Size of operand would otherwise constrain addressable memory

---

## Object-Oriented Programming (OOP)

### Core Concepts

#### Classes
- **Definition:** Template/blueprint for creating objects
- **Contains:** Attributes (state) and methods (behaviour)
- **Purpose:** Define structure and capabilities of objects

#### Objects
- **Definition:** Specific instance of a class
- **Created by:** Instantiation using constructor method
- **Example:**
  ```python
  myBook = new Book('Great Expectations', 'Charles Dickens', False, False)
  ```

#### Attributes
- **Definition:** Properties/data members of a class
- **Also called:** Instance variables (for objects), Class variables (for classes)
- **Access:** Declared as **private** to protect data
- **Example:** title, author, reserved, onLoan (for Book class)

#### Methods
- **Definition:** Functions associated with objects/classes
- **Types:**
  - **Function** - performs task and returns value
  - **Procedure** - performs task, returns nothing
- **Special Methods:**
  - **Constructor** - creates new object (usually called 'new')
  - **Getter** - retrieves attribute value
  - **Setter** - sets attribute value
- **Access:** Declared as **public** to allow external access

#### Example Class Structure

```python
class Book:
    private reserved      # Attributes (private)
    private onLoan
    private author
    private title
    
    public procedure new(title, author, reserved, onLoan)  # Constructor
        title = givenTitle
        author = givenAuthor
        reserved = givenReserved
        onLoan = givenOnLoan
    end procedure
    
    public function set_reserved()  # Setter method
        reserved = True
    end function
    
    public function get_title()     # Getter method
        return title
    end function
end class
```

### OOP Principles

#### 1. Encapsulation

**Definition:** Bundling data (attributes) and methods within a class, controlling access through access modifiers.

**Key Points:**
- Attributes declared as **private** (cannot be directly accessed externally)
- Methods declared as **public** (can be accessed externally)
- Data only modified through public methods (getters/setters)
- Hides implementation details from users

**Benefits:**
- Data security - prevents accidental modification
- Code organization - related data/methods kept together
- Maintainability - internal changes don't affect external code
- Abstraction - programmers don't need to know implementation details

#### 2. Inheritance

**Definition:** A class (subclass/derived class) inheriting attributes and methods from another class (superclass/parent class).

**Relationship:** Establishes an "IS-A" relationship  
**Example:** Car IS-A Vehicle

**Syntax:**
```python
class Biography inherits Book
```

**Benefits:**
- **Code reuse** - inherit existing functionality
- **Promotes organization** - logical class hierarchies
- **Reduces redundancy** - shared code in parent class

**Structure:**
```
        ┌─────────────┐
        │ Superclass  │  (e.g., Vehicle)
        │  Methods    │
        │  Attributes │
        └──────┬──────┘
               │ inherits
        ┌──────┴──────┐
        │             │
   ┌────▼────┐   ┌───▼────┐
   │Subclass │   │Subclass│  (e.g., Car, Truck)
   │Methods  │   │Methods │
   │Attributes   │Attributes
   └─────────┘   └────────┘
```

**Example:**
- **Superclass: Vehicle** - attributes: manufacturer, make, cost, methods: startEngine(), displayInfo()
- **Subclass: Car** - inherits all Vehicle properties, adds: engineCapacity, gearChange()
- **Subclass: Truck** - inherits all Vehicle properties, adds: isRefrigerated, totalCargoArea

#### 3. Polymorphism

**Definition:** Objects can take different forms/behaviours; same method produces different outputs depending on object class.

**Two Types:**

**a) Overriding**
- Redefining a method within subclass
- Changes functionality to produce different output
- **Example:**
  ```python
  class Vehicle:
      def displayInfo():
          print("I am a Vehicle")
  
  class Car inherits Vehicle:
      override def displayInfo():   # Different implementation
          print("I am a Car")
  ```

**b) Overloading**
- Same method name with different parameters
- Different behaviour based on arguments passed
- **Example:**
  ```python
  def calculate(a, b):        # Two parameters
      return a + b
  
  def calculate(a, b, c):     # Three parameters
      return a + b + c
  ```

**Benefits:**
- Flexibility in code
- Same interface, different implementations
- Makes code more maintainable

---

## Quick Reference Summary

### When to Use Each Paradigm

**Procedural:**
- Straightforward tasks with clear step-by-step process
- Simple algorithms
- Problems requiring clear control flow

**Object-Oriented:**
- Multiple components with similar characteristics
- Projects requiring high reusability
- Systems needing easy maintenance/updates
- Complex applications with multiple entities

**Assembly:**
- Direct hardware interaction required
- Embedded systems
- Performance-critical code
- Low-level system programming

### Key Terminology

| Term | Definition |
|------|------------|
| **Paradigm** | Approach to using a language to solve problems |
| **Instantiation** | Creating an object from a class |
| **Mnemonic** | Abbreviation for machine code instruction |
| **Opcode** | Part of instruction specifying operation |
| **Operand** | Part of instruction specifying data/address |
| **Accumulator** | Special register in LMC holding current value |
| **Constructor** | Method creating new object |
| **Inheritance** | Subclass inheriting from superclass |
| **Encapsulation** | Hiding implementation, protecting data |
| **Polymorphism** | Objects behaving differently based on class |

---

## Exam Tips

1. **Programming Paradigms:** Be able to identify paradigm from code characteristics and explain why it's suitable for specific problems

2. **LMC Programs:** Practice tracing through programs step-by-step, tracking Accumulator values and memory locations

3. **Addressing Modes:** Understand the difference between where the operand points vs where the data actually is

4. **OOP Concepts:** Be able to:
   - Identify classes, objects, attributes, methods from code
   - Explain inheritance relationships
   - Recognize encapsulation through public/private keywords
   - Provide examples of polymorphism

5. **Code Writing:** For LMC programs, always include:
   - Labels for branches
   - DAT statements for data storage
   - HLT to end program

6. **Class Diagrams:** Be able to draw/interpret relationships between superclasses and subclasses with inheritance arrows
