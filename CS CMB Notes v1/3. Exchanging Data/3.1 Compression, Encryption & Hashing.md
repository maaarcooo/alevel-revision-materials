# 3.1 Compression, Encryption & Hashing
## Revision Notes

---

## **1. Compression**

### **What is Compression?**
Compression reduces the storage space required by a file, enabling:
- More efficient storage (store more files with the same storage capacity)
- Faster data transfer over networks and the Internet
- Reduced bandwidth consumption

### **Lossy vs Lossless Compression**

| **Aspect** | **Lossy Compression** | **Lossless Compression** |
|------------|----------------------|--------------------------|
| **Data Loss** | Some data is permanently discarded | No data is lost; original file can be fully recovered |
| **File Size** | Greatly reduced file sizes | Larger file sizes than lossy |
| **Quality** | Irreversible loss of quality (e.g., pixelation, reduced audio clarity) | Maintains original quality |
| **Use Cases** | Media streaming, social media images, music files | Text files, executable files, archival storage, professional graphics |
| **Examples** | JPEG images, MP3 audio, MP4 video | PNG images, ZIP files, FLAC audio |
| **Reversibility** | Cannot recover original data | Can fully restore original data |

**Key Point:** Lossy removes information permanently (e.g., removing inaudible frequencies in audio), while lossless uses algorithms to encode data more efficiently without losing information.

---

### **Run Length Encoding (RLE)**

**Definition:** A lossless compression method that replaces consecutive repeated values with a single occurrence followed by a count.

**Example:**
- Original: `AAAAAABBBBBCCC`
- Compressed: `A6B5C3`

**How it works:**
1. Identify sequences of repeated characters
2. Replace with: character + count

**Effectiveness:**
- **Works well:** Data with lots of consecutive repetition (e.g., bitmap images with large areas of the same colour)
- **Works poorly:** Data with little repetition (compression may not reduce file size significantly)

**Practical Application:** Commonly used for compressing bitmap images where lines of pixels often have the same colour.

---

### **Dictionary Coding/Encoding**

**Definition:** A lossless compression method that replaces frequently occurring sequences with shorter codes using a dictionary lookup table.

**How it works:**
1. Create a dictionary mapping frequently occurring data to unique short codes
2. Replace occurrences in the data with the corresponding codes
3. Store compressed data alongside the dictionary
4. Use the dictionary to restore original data

**Example:**

Original text:
```
We shall fight in France,
we shall fight on the seas and oceans,
we shall fight with growing confidence
```

Dictionary:
```
1: We shall
2: fight
3: the
4: on
5: in
6: and
```

Compressed:
```
1 2 5 France,
1 2 4 3 seas 6 oceans,
1 2 with growing confidence
```

**Critical Point:** The dictionary **must** be transferred with the compressed data. Without it, the data cannot be decoded.

**Effectiveness:** Most effective when data contains frequently repeated phrases or patterns.

---

## **2. Encryption**

### **What is Encryption?**
Encryption converts readable data (plaintext) into an unreadable format (ciphertext) to secure it during transmission or storage. Only authorized parties with the correct key can decrypt and read the data.

**Purpose:**
- Protect data from unauthorized access
- Secure data transmission over networks
- Prevent data breaches and cyber-attacks

---

### **Symmetric Encryption**

**Definition:** Uses a **single private key** for both encryption and decryption.

**Process:**
1. Sender and receiver share the same private key (via key exchange)
2. Sender encrypts data using the private key
3. Data is transmitted
4. Receiver decrypts data using the same private key

**Advantages:**
- **Fast** - efficient for encrypting large amounts of data
- Simple to implement once key is shared

**Disadvantages:**
- **Key distribution problem** - the private key must be securely shared between parties
- **Security risk** - if the key is intercepted during exchange, all communications can be decrypted

**Use Cases:**
- Encrypting large files
- Database encryption
- Encrypting data on local storage
- Situations where the same person/system encrypts and decrypts (e.g., backing up data)

---

### **Asymmetric Encryption**

**Definition:** Uses **two mathematically related keys**: a **public key** (for encryption) and a **private key** (for decryption).

**Key Pair:**
- **Public key:** Can be published openly; anyone can use it to encrypt messages
- **Private key:** Must be kept secret; only the owner can use it to decrypt messages

**Process:**
1. Receiver generates a key pair (public and private keys)
2. Receiver publishes their public key
3. Sender obtains receiver's public key
4. Sender encrypts message using receiver's public key
5. Only the receiver's private key can decrypt the message

**Advantages:**
- **Solves key distribution problem** - public key can be shared openly
- **More secure** - private key never needs to be transmitted
- Enables **digital signatures** - sender can encrypt with their private key to prove identity

**Disadvantages:**
- **Slower** than symmetric encryption
- More computationally intensive

**Digital Signatures:**
If you encrypt a message with your **private key**, anyone can decrypt it with your **public key**. This proves **you** sent it, as only you have access to your private key.

**Use Cases:**
- Secure email communications
- Online banking
- HTTPS websites
- Exchanging passwords and sensitive credentials
- Government and confidential communications

---

### **Choosing Between Symmetric and Asymmetric**

| **Scenario** | **Recommended Type** | **Reason** |
|--------------|---------------------|------------|
| Large file encryption | Symmetric | Speed and efficiency |
| Secure communication between two parties | Asymmetric | Secure key exchange |
| Database encryption (same system) | Symmetric | Fast, no key exchange needed |
| Sharing passwords online | Asymmetric | High security, no shared key risk |

**Common Practice:** Many systems use **hybrid encryption** - asymmetric encryption to securely exchange a symmetric key, then symmetric encryption for the actual data transfer (combining security with speed).

---

## **3. Hashing**

### **What is Hashing?**
Hashing converts input data (of any size) into a **fixed-size string of characters** called a **hash** or **digest** using a **hash function**.

**Key Properties:**
- **Deterministic:** Same input always produces the same hash
- **Fixed output size:** Regardless of input size, output is always the same length
- **One-way function:** Cannot reverse a hash to get the original input
- **Sensitive to changes:** Even tiny changes in input produce completely different hashes
- **Fast computation:** Quick to calculate

**Example:**
```
Input: "hello123" → Hash (SHA-256): 8d9389d5a0375bd6b028bc0368003333
Input: "hello124" → Hash (SHA-256): 9ac12bac3a0843a1917b1c4a0f77a76d
```

---

### **Common Hashing Algorithms**

| **Algorithm** | **Status** | **Notes** |
|---------------|-----------|-----------|
| **MD5** | Weak | Vulnerable to collision attacks; not recommended for security |
| **SHA-1** | Weak | Previously used in SSL certificates; now considered insecure |
| **SHA-256** | Secure | Part of SHA-2 family; widely used and secure for most purposes |
| **SHA-3** | Most Secure | Latest SHA family member; highest security level |

---

### **Uses of Hashing**

#### **1. Password Storage**

**Process:**
1. User creates account and enters password
2. System hashes the password
3. Only the hash is stored in the database (not the plaintext password)
4. When user logs in, system hashes the entered password
5. System compares the new hash with the stored hash
6. If hashes match, access is granted

**Benefits:**
- Even if the database is compromised, attackers only get hashes (cannot reverse them to get passwords)
- Protects user privacy
- Minimizes risk of data breaches
- Reduces legal liability

**Security Note:** Since hashing is one-way, a successful hacker would only gain access to hash digests, which cannot be reversed to obtain the original passwords.

---

#### **2. Data Integrity Verification**

**Purpose:** Verify that data has not been corrupted or tampered with during transmission.

**Process:**
1. Sender hashes the data before sending
2. Sender transmits both the data and the hash
3. Receiver hashes the received data using the same hash function
4. Receiver compares their hash with the received hash
5. If hashes match, data is intact; if not, data was corrupted or modified

**Benefits:**
- Detects data corruption
- Identifies malicious interference
- Computationally efficient (comparing fixed-size hashes is faster than comparing entire files)

---

#### **3. Hash Tables (Efficient Data Retrieval)**

**Definition:** A data structure that uses a hash function to map keys to specific locations (buckets) in an array, enabling **constant time** (O(1)) data access.

**Structure:**
- **Hash function:** Converts key into an index
- **Bucket array:** Stores key-value pairs at the hashed index

**Process:**
1. Data is hashed to produce an index
2. Data is stored at that index in the hash table
3. To retrieve data, hash the key and look up the corresponding index

**Example:**
```
Hash Table for User Database:

Index | Hash     | Email          | Sign-Up Date
------|----------|----------------|-------------
0     | ab1c2d   | Aarav@...      | 08/08/22
1     | ef8g9h   | Mei@...        | 11/11/22
2     | i1j2k3   | Sven@...       | 02/02/22
3     | l4m5n6   | Fatima@...     | 06/06/22
4     | o7p8q9   | Tariq@...      | 05/05/22
```

**Advantages:**
- **Fast lookups:** Constant time access
- **Efficient:** Comparing fixed-size hashes is faster than comparing variable-length strings

**Use Cases:**
- Databases
- Caches
- Dictionaries in programming languages
- Quick data retrieval systems

---

#### **4. Collisions in Hash Tables**

**Definition:** A collision occurs when two different inputs produce the same hash value.

**Example:** Keys "John Smith" and "Sandra Dee" both hash to index `02`.

**Collision Resolution Methods:**
1. **Chaining:** Store multiple items at the same index using a linked list
2. **Open Addressing:** Use a secondary hash function to find a new index
3. **Linear Probing:** Check the next available index sequentially

**Good Hash Function Characteristics:**
- **Low collision probability:** Distributes keys uniformly
- **Fast to compute:** Minimal processing time
- **Output smaller than input:** Otherwise, searching the hash takes longer than searching the key

---

## **Comparison: Encryption vs Hashing**

| **Aspect** | **Encryption** | **Hashing** |
|------------|---------------|-------------|
| **Purpose** | Secure data transmission/storage (reversible) | Data verification, quick retrieval (irreversible) |
| **Reversibility** | Can be decrypted to original data | Cannot be reversed |
| **Keys** | Uses keys (symmetric or asymmetric) | No keys involved |
| **Speed** | Slower (especially asymmetric) | Generally faster |
| **Output Length** | Variable (can be same or longer than input) | Fixed length |
| **Use Cases** | Secure communications, file protection | Password storage, data integrity checks, hash tables |
| **Change Sensitivity** | Small input change → significantly different output | Small input change → significantly different output |
| **Operations** | Encrypt, Decrypt | Hash, Verify |

---

## **Key Exam Points**

### **Compression:**
- Know when to use lossy vs lossless
- Understand RLE works best with repetitive consecutive data
- Remember dictionary encoding requires the dictionary to be sent with the data

### **Encryption:**
- **Symmetric:** One key, fast, but key distribution is problematic
- **Asymmetric:** Two keys, slower, solves key distribution, used for small sensitive data
- Know appropriate use cases for each

### **Hashing:**
- **One-way function** - cannot be reversed
- Used for password storage (stores hashes, not passwords)
- Used for data integrity (compare hashes to verify data)
- Hash tables enable O(1) data access
- Good hash functions have low collision probability and are fast to compute

### **Common Mistakes to Avoid:**
- Don't confuse encryption (reversible) with hashing (irreversible)
- Don't forget that dictionary encoding needs the dictionary sent with the data
- Don't claim RLE is effective for all data types (it needs repetition)
- Don't say asymmetric encryption uses "two keys" without clarifying they're a public-private pair

---

## **Specification Coverage**

**1.3.1 a)** ✓ Lossy vs Lossless compression  
**1.3.1 b)** ✓ Run length encoding and dictionary coding for lossless compression  
**1.3.1 c)** ✓ Symmetric and asymmetric encryption  
**1.3.1 d)** ✓ Different uses of hashing

---
