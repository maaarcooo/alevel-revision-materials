# OCR A Level Computer Science: 1.4.1 Data Types
## Comprehensive Revision Notes

---

## Primitive Data Types

Data is always stored in binary by computers, but representation varies between data types. Using the correct data type ensures appropriate operations can be performed.

### Integer
- **Definition**: A whole number (no fractional part)
- **Includes**: Zero, positive and negative numbers
- **Use**: Counting things
- **Examples**: 6, 47238, -12, 0, 15

### Real / Floating Point
- **Definition**: Positive or negative numbers that can have a fractional part
- **Note**: All integers are real numbers
- **Use**: Measuring things
- **Examples**: 0, -71.5, 5.01, -80.8, 15

### Character
- **Definition**: A single symbol used by a computer
- **Includes**: Letters (A-Z), numbers (0-9), symbols (%, £, Σ)
- **Examples**: R, {, 7, Σ, ほ

### String
- **Definition**: A collection of characters
- **Can store**: Single or multiple characters in succession
- **Use**: Storing text, phone numbers (e.g., 07789 - preserves leading zero)
- **Examples**: "Hello, world!", "07789"

### Boolean
- **Definition**: Data type with only two possible values
- **Named after**: Mathematician George Boole (hence capital B)
- **Values**: True or False
- **Use**: Recording binary states (power button on/off, code execution status)

---

## Binary Number Representation

### Key Terminology
- **Bit**: Single binary digit (0 or 1)
- **Byte**: 8 bits
- **Nybble**: 4 bits (half a byte)
- **Base 2**: Binary counting system (powers of 2)
- **LSB**: Least Significant Bit (rightmost)
- **MSB**: Most Significant Bit (leftmost)

### Binary to Decimal Conversion

**Method**:
1. Write out place values (powers of 2)
2. Multiply each bit by its place value
3. Add all products together

**Example**: Convert 1101₂ to decimal

| 8 (2³) | 4 (2²) | 2 (2¹) | 1 (2⁰) |
|--------|--------|--------|--------|
| 1      | 1      | 0      | 1      |

Calculation: (8×1) + (4×1) + (2×0) + (1×1) = **13₁₀**

### Decimal to Binary Conversion

**Method**:
1. Find largest power of 2 smaller than the number
2. Write out place values up to this power
3. Starting from MSB, place 1 if place value ≤ current value, otherwise 0
4. If placing 1, subtract place value from current value
5. Continue until all positions filled

**Example**: Convert 47₁₀ to binary

| 32 | 16 | 8 | 4 | 2 | 1 |
|----|----|----|---|---|---|
| 1  | 0  | 1 | 1 | 1 | 1 |

Process:
- 32 ≤ 47 → Place 1, new value = 47-32 = 15
- 16 > 15 → Place 0
- 8 ≤ 15 → Place 1, new value = 15-8 = 7
- 4 ≤ 7 → Place 1, new value = 7-4 = 3
- 2 ≤ 3 → Place 1, new value = 3-2 = 1
- 1 ≤ 1 → Place 1

Result: **101111₂** (or 00101111₂ as a byte)

---

## Binary Addition

### Rules
1. 0 + 0 + 0 = 0
2. 0 + 0 + 1 = 1
3. 0 + 1 + 1 = 10 (carry the 1)
4. 1 + 1 + 1 = 11 (carry the 1)

### Method
1. Align binary numbers vertically
2. Start from LSB (right side)
3. Add each column
4. If result > 1 digit, write carried digit under next column in small writing
5. Read final answer from full-size digits

**Example**: 1011₂ + 1110₂

```
    1 0 1 1
  + 1 1 1 0
  ---------
  1 1 0 0 1
```

Result: **11001₂**

**Exam Tip**: Always check your answer by converting to decimal.

---

## Negative Numbers in Binary

### Sign Magnitude

**Concept**: Equivalent to adding +/- sign in decimal
- **Leading 0**: Positive number
- **Leading 1**: Negative number

**Example**: Representing 173 and -173

| Binary 173 | Sign Magnitude +173 | Sign Magnitude -173 |
|------------|---------------------|---------------------|
| 10101101   | 010101101           | 110101101           |

**Converting from Sign Magnitude to Decimal**:
1. Note the MSB (sign bit)
2. Discard the leading bit
3. Convert remaining bits to decimal
4. Apply the sign

**Example**: 101101001
- MSB = 1 (negative)
- Remove sign bit: 01101001 = 105₁₀
- Result: **-105₁₀**

### Two's Complement

**Advantages**: Simplifies binary arithmetic with negative numbers

**Key Concept**: MSB becomes negative. In an 8-bit byte, the MSB represents -128 instead of +128.

**Converting to Two's Complement**:
1. Start with positive binary number
2. Flip all bits (1→0, 0→1)
3. Add 1

**Example**: Convert 7 to -7 in two's complement (8 bits)
- Positive 7: 00000111
- Flip bits: 11111000
- Add 1: **11111001**

**Verification**:

| -128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
|------|----|----|----|----|---|---|---|
| 1    | 1  | 1  | 1  | 1  | 0 | 0 | 1 |

Calculation: (-128×1) + (64×1) + (32×1) + (16×1) + (8×1) + (4×0) + (2×0) + (1×1) = **-7₁₀**

---

## Binary Subtraction Using Two's Complement

**Method**: Convert subtraction to addition of negative number

**Example**: 8 - 12 = 8 + (-12)

Using 5-bit two's complement:
- 8₁₀ = 01000₂
- -12₁₀ = 10100₂

```
  -16  8  4  2  1
   0   1  0  0  0
 + 1   0  1  0  0
 ----------------
   1   1  1  0  0
```

Verification: -16 + 8 + 4 = **-4₁₀** ✓

---

## Hexadecimal

### Introduction
- **Base**: 16 (compared to decimal base 10, binary base 2)
- **Digits**: 0-9 and A-F (A=10, B=11, C=12, D=13, E=14, F=15)

### Decimal-Hexadecimal Table

| Decimal | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---------|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|-----|
| Hex     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A  | B  | C  | D  | E  | F   |

### Hexadecimal to Decimal

**Place values**: Start with 1 (16⁰) and increase in powers of 16

**Example**: Convert 4E7F₁₆ to decimal

| 4096 (16³) | 256 (16²) | 16 (16¹) | 1 (16⁰) |
|------------|-----------|----------|---------|
| 4          | E (14)    | 7        | F (15)  |

Calculation: (4×4096) + (14×256) + (7×16) + (15×1) = **20095₁₀**

### Hexadecimal to Binary

**Method**: Convert each hex digit to a 4-bit binary nybble, then combine

**Example**: Convert B2₁₆ to binary

1. Split: B | 2
2. Hex to decimal: 11 | 2
3. Decimal to binary nybbles: 1011 | 0010
4. Combine: **10110010₂**

Verification: 128 + 32 + 16 + 2 = 178₁₀

### Hexadecimal to Decimal (Alternative)

Can convert hex→binary→decimal OR use hex place values directly

**Example**: 4C3₁₆

| 256 (16²) | 16 (16¹) | 1 (16⁰) |
|-----------|----------|---------|
| 4         | C (12)   | 3       |

Calculation: (4×256) + (12×16) + (3×1) = **1219₁₀**

---

## Floating Point Numbers

### Concept
Similar to scientific notation (e.g., 6.67 × 10⁻¹¹)

**Components**:
- **Mantissa**: The significant digits
- **Exponent**: The power/shift amount

Both stored in **two's complement**.

### Structure Example
11-bit mantissa, 6-bit exponent:

```
M: 01100100111 | E: 000110
```

**Key Rule**: Binary point is always after the MSB of mantissa

### Converting Floating Point to Decimal

**Method**:
1. Identify mantissa and exponent
2. Place binary point after MSB of mantissa
3. Convert exponent to decimal
4. Shift binary point by exponent value (right if positive, left if negative)
5. Convert final binary to decimal

**Example 1**: M: 01100100111 | E: 000110

1. Mantissa: 0.1100100111
2. Exponent: 000110₂ = 5₁₀
3. Shift binary point 5 places right: 0110010.0111
4. Convert to decimal:

| -64 | 32 | 16 | 8 | 4 | 2 | 1 | 0.5 | 0.25 | 0.125 | 0.0625 |
|-----|----|----|----|---|---|---|-----|------|-------|--------|
| 0   | 1  | 1  | 0  | 0 | 1 | 0 | 0   | 1    | 1     | 1      |

Result: 32 + 16 + 2 + 0.25 + 0.125 + 0.0625 = **50.4375₁₀**

**Example 2**: M: 0101101000 | E: 111101 (10-bit mantissa, 6-bit exponent)

1. Mantissa: 0.101101000
2. Exponent: -32 + 16 + 8 + 4 + 1 = -3₁₀
3. Shift binary point 3 places left: 0.000101101
4. Convert: 1/16 + 1/64 + 1/128 + 1/512 = **45/512**

### Normalisation

**Purpose**: Maximise precision by using mantissa fully

**Rules**:
- **Positive numbers**: Must start with 01
- **Negative numbers**: Must start with 10

**Method**:
1. Split into mantissa and exponent
2. Shift mantissa bits to achieve 01 (positive) or 10 (negative) start
3. Adjust exponent to compensate for mantissa shift
4. If mantissa shifted left by n, decrease exponent by n
5. If mantissa shifted right by n, increase exponent by n

**Example**: Normalise 000110100101 (8-bit mantissa, 4-bit exponent)

Original:
- Mantissa: 00011010
- Exponent: 0101₂ = 5₁₀

Normalised:
- Shift mantissa 2 places left: **01101000**
- Reduce exponent by 2: 5 - 2 = 3₁₀ = **0011₂**
- Result: 01101000 0011

---

## Floating Point Arithmetic

### Addition

**Method**:
1. Make exponents equal by shifting mantissa of number with smaller exponent
2. Add the mantissas using binary addition
3. Normalise the result if necessary

**Example**: Add 000100 0011 and 000101 0010 (6-bit mantissa, 4-bit exponent)

Step 1: Match exponents
- First number needs shifting by 1: 001000 0010
- Second number: 000101 0010

Step 2: Add mantissas
```
  0 0 1 0 0 0
+ 0 0 0 1 0 1
-------------
  0 0 1 1 0 1
```

Result: 001101 0010

Step 3: Normalise
- Shift mantissa left by 1: 011010
- Decrease exponent by 1: 0001
- **Final**: 011010 0001

### Subtraction

**Method**:
1. Make exponents equal
2. Convert mantissa of number to subtract to two's complement (flip bits, add 1)
3. Add the mantissas
4. Normalise the result

Same process as integer subtraction but with floating point format.

---

## Bitwise Manipulation

### Logical Shifts

**Definition**: Moving all bits a specified number of places left or right

**Logical Shift Left**: Add trailing zeros
**Logical Shift Right**: Add leading zeros

**Example**: Logical shift left by 3 places on 10010110

Result: **10010110000**

**Effect**:
- **Shift left by n**: Multiply by 2ⁿ
- **Shift right by n**: Divide by 2ⁿ
- **Shift left by 1**: Double the number

Example calculation: Original × 2³ = Original × 8

### Masks

**Definition**: Combining binary numbers using logic gates

#### AND Mask

**Effect**: Acts like multiplication - both inputs must be 1 for output of 1

**Example**:
```
  0 0 1 0 1 0 1 1
AND 1 0 1 1 1 0 1 1
  -----------------
  0 0 1 0 1 0 1 1
```

**Use**: Extracting specific bits (bits where mask is 0 become 0)

#### OR Mask

**Effect**: Output is 1 if either input is 1

**Example**:
```
  0 0 1 0 1 0 1 1
OR  1 0 1 1 1 0 1 1
  -----------------
  1 0 1 1 1 0 1 1
```

**Use**: Setting specific bits to 1

#### XOR Mask

**Effect**: Output is 1 if inputs are different

**Example**:
```
  0 0 1 0 1 0 1 1
XOR 1 0 1 1 1 0 1 1
  -----------------
  1 0 0 1 0 0 0 0
```

**Use**: Toggling specific bits, encryption

---

## Character Sets

### Character Set Definition
A published collection of codes and corresponding characters for representing text.

### ASCII (American Standard Code for Information Interchange)

**Specifications**:
- Uses **7 bits**
- Represents **2⁷ = 128** different characters
- Capital letters A-Z: codes 65-90
- Lower case letters a-z: codes 97-122
- Includes numbers and symbols

**Limitations**:
- Insufficient for languages with different character sets
- Cannot represent many international symbols
- Led to development of Unicode

### Unicode

**Specifications**:
- Uses **varying number of bits**
- Capacity for **over 1 million** different characters
- Many characters yet to be allocated

**Advantages**:
- Represents multiple languages
- Includes extensive symbol sets
- Supports emoji
- Backwards compatible with ASCII

**Purpose**: Solves ASCII's limitation of only 128 characters

---

## Summary Comparison Tables

### Number System Comparison

| System      | Base | Digits Used        | Example |
|-------------|------|-------------------|---------|
| Binary      | 2    | 0, 1              | 1011    |
| Decimal     | 10   | 0-9               | 47      |
| Hexadecimal | 16   | 0-9, A-F          | 2F      |

### Negative Number Representation

| Method           | MSB Meaning    | Advantage                    | Disadvantage          |
|------------------|----------------|------------------------------|----------------------|
| Sign Magnitude   | Sign bit (0=+, 1=-) | Simple to understand    | Two representations of zero |
| Two's Complement | Negative value | Simplifies arithmetic        | Less intuitive       |

### Data Type Summary

| Type    | Fractional Part? | Examples           | Typical Use          |
|---------|------------------|--------------------|---------------------|
| Integer | No               | -12, 0, 47         | Counting            |
| Real    | Yes              | -71.5, 5.01        | Measuring           |
| Character | N/A            | 'A', '7', '%'      | Single symbols      |
| String  | N/A              | "Hello", "07789"   | Text, phone numbers |
| Boolean | N/A              | True, False        | Binary states       |

---

## Exam Tips

1. **Always show working** for conversions - partial marks available
2. **Check answers** by converting back to decimal when time permits
3. **Remember place values**: 1, 2, 4, 8, 16, 32, 64, 128 for 8-bit numbers
4. **Normalisation**: Positive starts 01, negative starts 10
5. **Binary addition**: Watch for carry digits - write them small
6. **Two's complement**: Flip all bits, then add 1
7. **Hexadecimal**: Each hex digit = exactly 4 binary bits
8. **Floating point**: Binary point always after MSB of mantissa
9. **Leading zeros**: Don't affect value but needed for fixed-width representation
10. **Character sets**: ASCII = 7 bits (128 chars), Unicode = variable bits (1M+ chars)

---

## Common Mistakes to Avoid

- Forgetting to normalise floating point results
- Incorrect placement of binary point in floating point
- Adding instead of concatenating in hex to binary conversion
- Not making exponents equal before floating point addition
- Forgetting the MSB is negative in two's complement
- Confusing logical shift effects (left = multiply, right = divide)
- Applying wrong mask (AND vs OR vs XOR)
- Not recognising when mantissa/exponent split occurs

---

**End of Notes**
