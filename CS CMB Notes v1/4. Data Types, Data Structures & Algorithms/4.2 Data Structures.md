# 1.4.2 Data Structures - Revision Notes

## 1. Basic Data Structures

### Arrays

**Definition:** An ordered, finite set of elements of a **single type**.

**Key Characteristics:**
- Arrays are **zero-indexed** (first element at position 0) unless stated otherwise
- Elements stored **contiguously** in memory
- **Fixed size** - cannot change after creation
- Allow **direct access** to elements via index (random access)

**Dimensions:**
- **1D Array:** Linear array, e.g., `[1, 23, 12, 14, 16]`
- **2D Array:** Table/spreadsheet format - access using `[row, column]`
  - Navigate: down rows first, then across columns
- **3D Array:** Multi-page spreadsheet - access using `[array, row, column]`

**Example:**
```
array[3] → returns element at index 3
twoDimensionalArray[1,3] → row 1, column 3
threeDimensionalArray[0,1,2] → array 0, row 1, column 2
```

---

### Records

**Definition:** A row in a file made up of **fields** - commonly used in databases.

**Structure:**
```
fighterDataType = record
    integer  ID
    string   FirstName
    string   Surname
end record
```

**Accessing Fields:**
- Create variable: `fighter : fighterDataType`
- Access field: `fighter.FirstName`
- Syntax: `recordName.fieldName`

---

### Lists

**Definition:** A data structure consisting of **ordered items** where items can **occur more than once**.

**Key Differences from Arrays:**
- Stored **non-contiguously** (not next to each other in memory)
- Can contain **multiple data types**
- **Dynamic size** - can grow/shrink
- No direct access - must traverse sequentially

**List Operations:**

| Operation | Syntax | Description |
|-----------|--------|-------------|
| `isEmpty()` | `List.isEmpty()` | Checks if list is empty |
| `append(value)` | `List.append(15)` | Adds value to end of list |
| `remove(value)` | `List.remove(23)` | Removes first occurrence of value |
| `search(value)` | `List.search(38)` | Searches for value, returns Boolean |
| `length()` | `List.length()` | Returns length of list |
| `index(value)` | `List.index(23)` | Returns position of item |
| `insert(pos, value)` | `List.insert(4,25)` | Inserts value at given position |
| `pop()` | `List.pop()` | Returns and removes last value |
| `pop(position)` | `List.pop(3)` | Returns and removes value at position |

---

### Tuples

**Definition:** An ordered set of values of **any type** that is **immutable**.

**Key Characteristics:**
- **Cannot be changed** once created
- Elements cannot be added or removed
- Use **regular brackets** `()` instead of square brackets
- Accessed like arrays but values cannot be modified

**Example:**
```
tupleExample = ("Value1", 2, "Value3")
print(tupleExample[0]) → "Value1"
tupleExample[0] = "Changed" → Syntax Error
```

---

## 2. Advanced Data Structures

### Linked Lists

**Definition:** A **dynamic data structure** holding an ordered sequence where items are **not stored contiguously**.

**Components:**
- **Node:** Each item in the list
- **Data field:** Contains the actual value
- **Pointer/Link field:** Contains address of next item
- **Start pointer:** Index of first item
- **NextFree pointer:** Index of next available space

**Structure Example:**

| Index | Data | Pointer |
|-------|------|---------|
| 0 | 'Linked' | 2 |
| 1 | 'Example' | 0 |
| 2 | 'List' | - |
| 3 | | |

Start = 1, NextFree = 3

**Traversal:** Start at 'Start' pointer, follow pointers until reaching empty/null pointer.
- Output: 'Example', 'Linked', 'List'

**Adding a Node:**
1. Add new value at NextFree position
2. Update pointer of previous node to point to new node
3. Update pointer of new node to point to next node
4. Update NextFree pointer

**Removing a Node:**
- Update pointer of previous node to skip deleted node
- Node not truly removed (wastes memory) but is ignored

**Advantages:**
- Easy insertion/deletion via pointer updates
- Dynamic size

**Disadvantages:**
- **No random access** - must traverse sequentially
- Extra memory needed for pointers
- Nodes not truly deleted (memory waste)

---

### Graphs

**Definition:** A set of **vertices/nodes** connected by **edges/arcs**.

**Types:**
- **Directed Graph:** Edges traversed in one direction only
- **Undirected Graph:** Edges traversed in both directions
- **Weighted Graph:** Cost attached to each edge

**Representation Methods:**

**1. Adjacency Matrix:**
- 2D array showing connections
- Value represents weight/cost between nodes
- `-` or `0` indicates no connection

**2. Adjacency List:**
- Each node lists its connections
- Format: `A → {B:4, C:18, D:12}`

**Comparison:**

| Adjacency Matrix | Adjacency List |
|------------------|----------------|
| Quicker access times | More space efficient for sparse networks |
| Convenient to work with | Easy to add nodes |
| Better for dense networks | Better for sparse networks |

---

### Stacks

**Definition:** A **Last In First Out (LIFO)** data structure.

**Key Characteristics:**
- Items added/removed from **top only**
- Uses a **top pointer** indicating where next item will be inserted
- Can be **static** (fixed size) or **dynamic**

**Applications:**
- Undo/redo functionality
- Browser back button
- Reversing actions
- Function call management

**Stack Operations:**

| Operation | Syntax | Description |
|-----------|--------|-------------|
| `isEmpty()` | `Stack.isEmpty()` | Checks if stack is empty (checks top pointer) |
| `push(value)` | `Stack.push("Nadia")` | Adds value to top (checks not full first) |
| `peek()` | `Stack.peek()` | Returns top value without removing |
| `pop()` | `Stack.pop()` | Removes and returns top value |
| `size()` | `Stack.size()` | Returns size of stack |
| `isFull()` | `Stack.isFull()` | Checks if stack is full |

---

### Queues

**Definition:** A **First In First Out (FIFO)** data structure.

**Key Characteristics:**
- Items added at **rear/back**
- Items removed from **front**
- Uses **two pointers:** front pointer and rear pointer

**Applications:**
- Printer queues
- Keyboard buffers
- Process scheduling
- Simulations

**Types of Queues:**

**1. Linear Queue:**
- Array-based implementation
- **Problem:** Space cannot be reused after items are removed
- Inefficient memory usage

**2. Circular Queue:**
- When rear pointer reaches maximum size, loops back to front
- **Better memory efficiency**
- More complex to implement
- Formula: `newRearPointer = (rearPointer + 1) MOD maxSize`

**Queue Operations:**

| Operation | Syntax | Description |
|-----------|--------|-------------|
| `enQueue(value)` | `Queue.enQueue("Nadia")` | Adds item to rear (increments rear pointer) |
| `deQueue()` | `Queue.deQueue()` | Removes item from front (increments front pointer) |
| `isEmpty()` | `Queue.isEmpty()` | Checks if queue is empty (compares pointers) |
| `isFull()` | `Queue.isFull()` | Checks if queue is full |

---

### Trees

**Definition:** A connected form of graph with a hierarchical structure.

**Key Terminology:**

| Term | Definition |
|------|------------|
| **Node** | An item in the tree |
| **Edge** | Connects two nodes (also: branch/arc) |
| **Root** | Top node with no incoming edges |
| **Child** | Node with incoming edges |
| **Parent** | Node with outgoing edges |
| **Subtree** | Section consisting of parent and all its children |
| **Leaf** | Node with no children |

**Binary Tree:**
- Each node has **maximum of two children**
- Used for binary searches
- Represented using **left pointer** and **right pointer**
- Usually implemented with 2D arrays

**Example Structure:**

| Index | Left Pointer | Data | Right Pointer |
|-------|--------------|------|---------------|
| 0 | 1 | G | 3 |
| 1 | 2 | C | 4 |
| 2 | - | A | - |

---

### Binary Tree Traversal Methods

**1. Pre-order Traversal:** Root → Left → Right
- Order of passing nodes on the **left**
- **Use:** Programming languages with prefix notation (operation before values)
- Example: 15, 9, 5, 7, 11, 10, 12, 20, 25, 34

**2. In-order Traversal:** Left → Root → Right
- Order of passing **under** nodes
- **Use:** Traversing nodes in sequential order
- Example: 5, 7, 9, 10, 11, 12, 15, 20, 25, 34

**3. Post-order Traversal:** Left → Right → Root
- Order of passing nodes on the **right**
- **Use:** Postfix notation
- Example: 7, 5, 10, 12, 11, 9, 34, 25, 20, 15

**Memory Tip - Outline Method:**
- Pre-order: trace left side
- In-order: trace bottom
- Post-order: trace right side

---

### Hash Tables

**Definition:** An array coupled with a **hash function** that maps keys to indices.

**Components:**
- **Hash Function:** Takes input (key) and produces output (hash/index)
- **Hash Table:** Array storing the data
- **Key:** Input data
- **Hash:** Output index

**How It Works:**
1. Key is input to hash function
2. Hash function returns index
3. Data stored at that index in array

**Collisions:**
- **Collision:** Two keys produce same hash value
- **Collision Resolution:** Place item in next available location
- Good algorithms have **low collision probability**

**Advantages:**
- **Fast access** to data (O(1) average case)
- Efficient for indexing
- Unique one-to-one relationship between keys and addresses

**Applications:**
- Database indexing
- Password storage (with encryption)
- Caching systems
- Lookup tables

---

## 3. Key Comparisons for Exams

### Arrays vs Lists

| Arrays | Lists |
|--------|-------|
| Single data type | Multiple data types |
| Contiguous storage | Non-contiguous storage |
| Fixed size | Dynamic size |
| Random access O(1) | Sequential access O(n) |
| Less memory overhead | More memory overhead |

### Stacks vs Queues

| Stacks (LIFO) | Queues (FIFO) |
|---------------|---------------|
| Add/remove from top | Add at rear, remove from front |
| One pointer (top) | Two pointers (front & rear) |
| Undo operations | Process scheduling |
| Function calls | Printer queues |

### Linear Queue vs Circular Queue

| Linear Queue | Circular Queue |
|--------------|----------------|
| Simple implementation | Complex implementation |
| Wastes memory | Efficient memory use |
| Space cannot be reused | Space can be reused |
| Front spaces remain empty | Wraps around to reuse space |

### Adjacency Matrix vs Adjacency List

| Adjacency Matrix | Adjacency List |
|------------------|----------------|
| Better for dense graphs | Better for sparse graphs |
| O(1) edge lookup | O(n) edge lookup |
| O(V²) space | O(V+E) space |
| Easy to add edges | Easy to add vertices |

---

## Exam Tips

1. **Array Indexing:** Always assume zero-indexed unless stated otherwise
2. **2D Arrays:** Remember - rows first, then columns (opposite to coordinates)
3. **Tuples vs Lists:** Tuples are immutable; attempting to modify raises error
4. **Linked Lists:** Understand pointer manipulation for add/remove operations
5. **Tree Traversal:** Learn the outline method for quick determination
6. **Hash Tables:** Know collision resolution methods
7. **Queue Types:** Understand why circular queues are more efficient
8. **Stack/Queue:** Remember LIFO vs FIFO - crucial distinction

---

## Common Errors to Avoid

- Confusing row/column order in 2D arrays
- Forgetting that linked list nodes aren't truly deleted
- Mixing up tree traversal orders
- Not checking if stack/queue is full/empty before operations
- Assuming arrays can contain multiple data types
- Forgetting tuples are immutable
- Confusing adjacency matrix and adjacency list use cases
