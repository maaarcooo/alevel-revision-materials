# 6.1 Thinking Abstractly - Revision Notes

## The Nature of Abstraction

### Core Definition
**Abstraction** is the process of **removing unnecessary details** from a problem to focus on the **important features** needed for a solution. It is one of the most critical principles in Computer Science and computational thinking.

### Types of Abstraction

#### 1. Representational Abstraction
- Analysing what is **relevant** to a given scenario
- Simplifying a problem based on this information
- Removing excessive details to arrive at a representation consisting only of **key features**

#### 2. Abstraction by Generalisation
- **Grouping together similarities** within a problem
- Identifying **what kind of problem** it is
- Categorising problems as being of a **particular type**
- Allows a **common solution** to be applied to similar problems

#### 3. Data Abstraction
- A subcategory where **details about how data is stored are hidden**
- Programmers can use **abstract data structures** (e.g., stacks, queues) without knowing their implementation
- Examples: Using push/pop operations on a stack without understanding the underlying code

#### 4. Procedural Abstraction
- Models **what a subroutine does** without considering **how** it's done
- Used in decomposition
- Once coded, procedures can be **reused as black-boxes**
- Programmers can perform functions **without knowledge of implementation code**

### Levels of Abstraction

Very large, complex problems use **multiple levels of abstraction**, each performing a different role:

- **Highest levels**: Closest to the user; provide an **interface** for user-hardware interaction
- **Lowest levels**: Responsible for executing tasks through **machine code**

### Practical Examples of Abstraction

1. **London Underground Map**
   - Travellers don't need geographical layout details
   - Only need to know: getting on at stop A transports you to stop B
   - Removes complexity while maintaining essential information

2. **Simulators**
   - Car/flight simulators
   - Building/house representations in programs or games
   - Bus/train route maps

3. **Pong Game**
   - Highly abstracted tennis/badminton
   - Constant ball momentum
   - No extraneous factors (friction, gravity)

4. **Projectile Physics**
   - Implementing trajectory of a ball or dart
   - Snooker ball physics
   - Decision: Include gravity, air resistance, friction?
   - **Closer to reality = less abstract**

---

## The Need for Abstraction

### Core Benefits

**Primary Function**: Allows **non-experts to use systems** by hiding information that is **too complex or irrelevant** to the system's purpose.

### Software Development Advantages

1. **More efficient design** - programmers focus on essential elements
2. **Reduced development time** - no wasted effort on unnecessary details
3. **Smaller program size** - removing wasteful details prevents unnecessary bloat
4. **Improved focus** - concentrate on elements that contribute to solving the problem

### Abstraction in Programming Languages

Programming languages exist on a **spectrum from low-level to high-level**:

#### Low-Level Languages
- **Machine Code** (1st Generation)
  - Uses binary (0s and 1s)
  - Directly interacts with computer systems
  - Requires understanding specific binary codes
  - Time-consuming, tedious, error-prone

- **Assembly Language** (2nd Generation)
  - Uses **mnemonics** to represent binary groups (e.g., ADD for 1011)
  - Easier to memorise than machine code
  - Requires knowledge of processor-specific instruction sets
  - **Disadvantage**: Each processor family has its own version; programs must be rewritten for different processors

#### High-Level Languages
- **Third Generation**: BASIC, FORTRAN, Python, Java, C
- **Advantages**:
  - Syntax **parallels natural language**
  - Considerably easier to learn and use
  - Made coding **accessible to non-specialists**
  - Abstracts long, complicated instruction sequences into shorter commands
  - Example: Multiplication in assembly takes many lines; in Python just one: `A = B * C`
  - Developers can ignore:
    - How data is stored in memory
    - Specifics of processor instruction execution
  - Allows focus on **solving the problem** rather than technical details

**Analogy**: A car driver doesn't need to know how the engine works to drive; similarly, programmers don't need to understand all underlying complexity to create programs.

### Abstraction in Networking

**TCP/IP Model** - An abstraction for network communication:

- **Four layers**: Application, Transport, Internet, Link
- Each layer handles a **different part of the communication process**
- Separating stages makes them **simpler to understand**
- Each layer doesn't need to know how other layers work
- **Outgoing**: Visualised as going down layers
- **Incoming**: Visualised as going up layers
- Uses a **set of protocols** for layer independence
- **Compatibility** between layers ensured through **agreed standards**

---

## The Difference Between Abstraction and Reality

### Core Distinction

**Abstraction is a simplified representation of reality.**

### Reality's Complexity
- The real world is very **complex** with **many variables**
- Example: Aerial city view shows all roads, junctions, streets with:
  - Weaving, turning roads
  - Different governing laws (speed limits, turning restrictions)
  - Buildings, greenspace, etc.

### Abstraction Process

When creating useful representations, **unnecessary details are removed**:

**City Navigation Example:**
1. **Reality**: Full city with buildings, greenspace, roads, junctions
2. **First abstraction**: Remove buildings and greenspace (irrelevant for vehicle travel)
3. **Further abstraction**: Represent junctions as **graph nodes**, roads as **edges/arcs**
4. **Final abstraction**: Graph suitable for computational processing
   - Directed edges can represent restrictions (e.g., no left turns)
   - Edge weights can represent distances
   - Can apply algorithms (Dijkstra's shortest path, A* search)

**Applications**: Google Maps, Uber - use abstracted maps to calculate shortest routes, factoring in traffic, roadworks, weather conditions.

### Computational Representations

#### Real-World Entities Represented Using:
- **Computational structures**: Tables, databases
- **Variables**: Store real-world values
- **Objects** (in object-oriented programming): Abstraction for real-world entities

#### Object-Oriented Programming Abstractions
- **Functionality, interface, and properties** of entities are considered
- **Attributes**: Abstraction for object characteristics
- **Methods**: Abstraction for actions a real-world object can perform

---

## Devising an Abstract Model

### Key Questions to Consider

When devising an abstract model for a scenario, consider:

#### 1. Problem Definition
- **What** is the problem that needs solving?
- Can the problem be **solved computationally**?
- What are the **key features** of the problem?
- Can the problem be **broken into milestones**?

#### 2. Model Usage
- **How** will the model be used?
- What **format** does the model need?
- Consider factors: **convenience, affordability, ease of access**

#### 3. Target Audience
- **Who** will use the model?
- How many people will use it?
- What **level of expertise** do they have in the subject/discipline?

#### 4. Relevance Assessment
- Which parts are relevant based on **target audience** and **purpose**?
- **Remove** sections not relevant to the problem
- **Remove** details that will confuse the audience
- **Test**: If an element were removed, would it impact the solution?

### Alternative Framework
- What elements will **impact** the solution for each milestone?
- If an element were removed, would it **affect** the solution in any way?

---

## Data Abstraction in Detail

### Primitive Data Types
- Programmers **don't need to know** how integers, strings, or booleans are stored and represented
- These implementations are **hidden** to make programming easier

### Abstract Data Types
Higher-level languages allow creation of abstracted data types to represent **logical structures**:

**Queue Example** (modelling a fast-food restaurant queue):
- **First-in, first-out** structure
- New people added to the **back**
- People removed from the **front** once served
- Usually has a **maximum capacity**

### Implementation Hierarchy
Queues are actually:
- Modified **arrays**
- Which are collections of **variables**
- Which are collections of **bytes**
- Which are collections of **bits**
- Which are collections of **flip-flops**

**Key Point**: Programmers don't worry about underlying implementation or memory storage - only that they can **add to** and **remove from** the structure.

### Benefits
- Creates **powerful analogous structures** that closely resemble real life
- Makes problems **easier to solve** and **understand**
- Facilitates effective **modelling**

---

## Key Principle

**Abstraction separates WHAT a program does from HOW it does it.**

By hiding implementation details and focusing on essential features, abstraction enables:
- More efficient problem-solving
- Better understanding of complex systems
- Easier development and maintenance
- Accessibility for non-experts
- Reusable, modular solutions

---

## Exam Tips

1. When asked about abstraction, always emphasise **removal of unnecessary details** and **focus on key features**
2. Be prepared to identify **what to remove** and **what to keep** in given scenarios
3. Understand the **different types** of abstraction and when each applies
4. Remember practical examples (London Underground map, programming languages, TCP/IP model)
5. Be able to **devise abstract models** by asking the four key questions
6. Recognise that **closer to reality = less abstract**
7. Understand abstraction's role in making systems **accessible to non-specialists**
