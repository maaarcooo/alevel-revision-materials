# 6.2 Thinking Ahead - Revision Notes
## OCR A Level Computer Science

---

## Introduction

**Thinking ahead** involves considering the different components of a problem and how they will be handled optimally before implementation. This allows developers to:
- Anticipate problems or difficulties that may arise during software use
- Design strategies to make programs easy and intuitive to use
- Create efficient and robust solutions

At their core, all computational problems consist of **inputs** which are **processed** to produce an **output**.

---

## 1. Inputs and Outputs

### Definition

**Inputs** are any data required to solve a problem, entered into the system by the user. Considerations include:
- The data itself
- The order in which data is input
- The method of input

**Outputs** are the results passed back once inputs have been processed and the problem solved. Designers must decide:
- Suitable data type
- Data structure
- Method of presentation

**Important**: Output data is not necessarily visual on a screen or monitor. It can include information in visual or audio format requiring output devices such as printers or speakers.

### Identifying Inputs and Outputs

When designing an algorithm, inputs and outputs must be **explicitly defined**, including:
- Type
- Size
- Format

Failure to define these explicitly makes algorithm creation more difficult and can cause errors when unexpected events occur.

**Design Process**:
1. Consider what outputs are required based on user requirements
2. Identify the inputs required
3. Determine how inputs need to be processed to achieve outputs

### Example: ATM Program

| **Inputs** | **Outputs** |
|------------|-------------|
| Transaction type (deposit, balance check, withdrawal) | Display amount entered on screen (if deposit) |
| Card details (via card reader) | Display account balance (if balance check) |
| PIN (via keypad) | Dispense cash (if withdrawal) |
| | Print receipt to confirm transaction |
| | Speaker provides verbal feedback |

**Input devices**: Touch screen, magnetic stripe card reader, keypad  
**Output devices**: Monitor, cash dispenser, printer, speakers

### Formal Specification Example

**Name**: LinearSearch  
**Input**: A list of integers my_list = (i₁, i₂, i₃, ..., iₙ)  
**Output**: The index of the element as an integer

---

## 2. Preconditions

### Definition

**Preconditions** are requirements which must be met before a program can be executed. If preconditions are not met, the program will:
- Fail to execute, or
- Return an invalid answer

Specifying preconditions means a subroutine can safely expect the arguments passed to it to meet certain criteria.

### Where Preconditions Appear

Preconditions can be:
1. **Tested within the code** - the subroutine checks conditions before executing
2. **Included in documentation** - the user is responsible for ensuring requirements are met

### Example 1: Stack Pop Function

```
function pop():
    if top = 0 then
        print "No items in the stack."
    else:
        element = stack[top]
        top = top-1
    endif
endfunction
```

**Precondition tested in code**: Stack must not be empty (top > 0)  
This prevents attempting to pop from an empty stack, which would cause a program crash.

### Example 2: Factorial Function

**Precondition in documentation**: Argument must be non-negative  
Rather than checking within the function, this is specified in accompanying documentation, reducing program length and complexity.

### Example 3: Binary Search

**Name**: BinarySearch  
**Inputs**: A list of integers my_list (i₁, i₂, i₃, i₄, ..., iₙ)  
**Outputs**: The index of the element as an integer  
**Preconditions**: 
- length of my_list > 0
- type(my_list) = int
- my_list must be sorted (ordered)

### Common Preconditions

- **List must not be empty** - prevents index out of bounds errors
- **Data must be same data type** - prevents invalid comparisons or results
- **Target data must match list data type** - ensures valid comparisons
- **Size limitations** - e.g., for O(n²) algorithms like bubble sort, limit input size to prevent excessive execution time

### Benefits of Specifying Preconditions

1. If provided in documentation, developers know what checks are required before calling the subroutine
2. If no preconditions specified, the program carries out validation checks internally, saving developer time
3. Defining preconditions makes subroutines **more reusable** and suitable for inclusion in libraries
4. Reduces program length and complexity
5. Saves time needed to debug and maintain code

---

## 3. Caching (A Level Only)

### Definition

**Caching** is the process of storing instructions or values in cache memory after they have been used, as they may be used again.

**Cache** is tiny storage on a processor used to temporarily store frequently used data and instructions while a program is running.

### Benefits of Caching

1. **Saves time** - avoids retrieving instructions from secondary storage repeatedly
2. **Faster access** - frequently accessed data loads without delay
3. **Reduces bandwidth usage** - data doesn't need to be downloaded multiple times
4. **Improves performance** - particularly for web pages, images, and text

### Common Applications

**Web Caching**:
- HTML pages and images most recently accessed are cached
- Next time these pages are accessed, content loads without delay
- Images and text don't need to be redownloaded
- Frees up network bandwidth for other tasks

**Processor Caching**:
- Usually performed automatically by the operating system
- Some languages (e.g., C) allow manipulation of underlying hardware cache

### Prefetching

**Prefetching** is an advanced variation of caching where **algorithms predict which instructions are likely to be fetched soon**.

**Process**:
1. Algorithms predict likely-to-be-used instructions
2. Instructions and data are loaded and stored in cache before they are actually fetched
3. Less time spent waiting for instructions to be loaded from hard disk into RAM

### Drawbacks and Limitations

1. **Algorithm accuracy** - predictions may be incorrect; no guarantee of accuracy
2. **Cache management** - effectiveness depends on how well caching algorithms manage the cache
3. **Cache size limitations** - larger caches take longer to search, limiting how much data can be stored
4. **Implementation difficulty** - can be difficult to implement effectively
5. **Performance variability** - benefits depend significantly on implementation quality

**Overall**: Thinking ahead through caching can be challenging to implement but can significantly improve performance when done effectively.

---

## 4. Reusable Program Components

### Definition

**Reusable components** are commonly used functions and subroutines that are packaged into **libraries** for reuse across multiple projects.

### Types of Reusable Components

- **Implementations of abstract data structures** (queues, stacks, linked lists)
- **Classes**
- **Subroutines and functions**
- **Standard algorithms** (quick sort, merge sort, search algorithms)

### Development Process

1. **Decomposition** - problem is broken down into smaller, simpler tasks
2. **Think ahead** - developers consider how each task can be solved
3. **Identify reuse opportunities** - determine where existing components can be reused
4. **Source components** - use internally-developed or externally-sourced components

### Benefits of Reusable Components

1. **Increased reliability** - components have already been tested and debugged
2. **Time savings** - no need to write code from scratch
3. **Cost reduction** - saves development time, money, and resources
4. **Versatility** - subroutines can be reused with different arguments to produce various outputs
5. **Future reusability** - well-tested components can be reused in future projects
6. **Reduced debugging time** - less new code means fewer potential bugs

### Drawbacks of Reusable Components

1. **Compatibility issues** - third-party components may not integrate with existing software
2. **Modification requirements** - components may need adaptation to work with existing systems
3. **Cost considerations** - modifying third-party components can sometimes be more costly and time-consuming than developing in-house

### Best Practices

- Create well-documented, thoroughly-tested components
- Package related functions into libraries
- Ensure components are modular and independent
- Specify clear preconditions and postconditions
- Use consistent naming conventions and interfaces

---

## Exam Tips

1. When asked about **inputs and outputs**, be specific about data types, methods of capture, and presentation formats
2. For **preconditions**, provide measurable conditions (e.g., "must be greater than 0" not just "valid data")
3. Remember **caching is A Level only** content
4. Understand the **difference between inputs/outputs** and **preconditions** - they are related but distinct concepts
5. Be prepared to suggest preconditions for given scenarios
6. Know both **benefits and drawbacks** of caching and reusable components

---

## Key Terms Summary

- **Thinking Ahead**: Considering components and problems before implementation
- **Inputs**: Data required to solve a problem
- **Outputs**: Results returned after processing inputs
- **Preconditions**: Requirements that must be met before execution
- **Caching**: Storing frequently used data in cache memory
- **Prefetching**: Predicting and preloading likely-to-be-used instructions
- **Reusable Components**: Functions/subroutines packaged for reuse across projects
- **Decomposition**: Breaking down problems into smaller, simpler tasks
- **Arguments**: Values passed into subroutines as parameters
