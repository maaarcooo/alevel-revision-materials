# 6.3 Thinking Procedurally

## Specification Coverage
- 2.1.3 a) Identify the components of a problem
- 2.1.3 b) Identify the components of a solution to a problem
- 2.1.3 c) Determine the order of the steps needed to solve a problem
- 2.1.3 d) Identify sub-procedures necessary to solve a problem

---

## What is Thinking Procedurally?

**Thinking procedurally** is an approach in computer science that makes program development simpler by breaking problems down into smaller, more manageable parts that are easier to understand, design, and implement.

This approach involves considering a problem in terms of the **underlying subproblems** that need to be solved to achieve the desired result.

---

## Identifying the Components of a Problem

### Problem Decomposition

**Problem decomposition** is the process of taking a large, complex problem and continually breaking it down into smaller subproblems that can be solved more easily.

**Benefits of decomposition:**
- Makes problems more **feasible to manage**
- Enables problems to be **divided between a group of people** according to skill sets
- Allows each component to be **tested separately** before integration
- Facilitates **code reuse** through modular design
- Simplifies **error identification and maintenance**

### Abstraction

**Abstraction** is the act of removing unimportant details from a real problem and focusing on the details that will form part of the solution.

**Examples of abstraction:**
- **Saving files**: Users don't need to know the underlying complex procedures for saving data on a hard disk drive or how the operating system represents data using paging and segmentation in RAM
- **Sending an email**: Users don't need to know which protocols are being used, how data is formatted, or what protocol handshaking occurs
- **Downloading content**: Users don't need to explicitly know how security checks are made using digital certificates, signatures, and protocols
- **Modelling a garden**: In a program, you don't need to model every single blade of grass; a green mesh or image typically suffices

### Top-Down Design

**Top-down design** (also known as **stepwise refinement**) is the preferred method for approaching very large problems. It breaks problems down into levels:
- **Higher levels** provide an overview of a problem
- **Lower levels** specify in detail the components of this problem

**Process:**
1. Break the problem down into major tasks
2. Break down these major tasks into smaller sub-tasks
3. Continue until each subproblem can be represented as a **single task**
4. Ideally, each task becomes a **self-contained module or subroutine**

**Example: Adventure Game Decomposition**

```
Adventure Game
├── Characters
│   ├── Characters' interactions
│   └── Characters' appearance
├── Adventures
│   ├── Levels
│   └── Backgrounds and settings
└── Enemies
    ├── Enemies' interactions
    └── Enemies' appearance
```

**Example: Book Reservation System**

```
Level 1: Book Reservation System Problem
├── Level 2: Borrower Input
│   ├── Level 3: Borrower name
│   ├── Level 3: Book details
│   └── Level 3: Collection location
├── Level 2: Process Request
│   └── Level 3: Check book availability
└── Level 2: Confirm Request
    ├── Level 3: Print estimated arrival date
    └── Level 3: Display account details
```

---

## Identifying the Components of a Solution

Once the components of the problem are identified, the matching **components used to solve the problem** can be identified.

### Procedural Abstraction

**Procedural abstraction** involves using a procedure (unit of computation) to execute sequences of instructions to achieve a specific goal.

### Technical Considerations for Solution Components

When identifying solution components, programmers must evaluate:

**Data aspects:**
- **Input parameter and output data types**: Integer, real/float, string, boolean, etc.
- **Data structures required**: Array, list, dictionary, linked list, hash table
- **Output format**: Array, list, dictionary, output string, etc.

**Implementation aspects:**
- **Libraries required**: Statistics module, math module, etc.
- **Data transformations and constructs**: Multiplication, division, for loop, while loop, select case
- **Algorithm efficiency**: Does it need to be O(n) or less?

**Reusability:**
- Identify tasks that could be solved using **existing modules, subroutines, or libraries**
- Reduces complexity of the development stage

### Example: Book Reservation System Components

**Borrower name module (getName()):**
- Check if user is signed-in to library account
- If signed-in: query database for borrower name using borrower ID
- If not signed-in: redirect to register/sign-in page
- Implementation: SQL query to database (e.g., `SELECT borrower_name FROM borrowers_table WHERE borrower_id='392'`)

**Book details module:**
- Text entry field for book name
- Display books stocked by libraries
- Implementation: Function returning ISBN of selected book (easier to handle than string)

**Collection location module:**
- Implementation: Function returning location specified by user
- Use drop-down field (not text entry) to prevent erroneous data entry

**Check book availability module:**
- Database query to check if books under selected ISBN are available or on loan
- Implementation: Function returning 'True' if available, 'False' if not

---

## Order of Steps Needed to Solve a Problem

When constructing the final solution, the **order in which operations are performed** is crucial.

### Key Considerations

**Sequential dependencies:**
- Some programs require certain **inputs before processing** can be carried out
- Inputs must be **validated** before passing to next subroutines
- Some subroutines require data from other subroutines and cannot execute simultaneously

**Parallel execution:**
- Programmers must identify where **subroutines can execute simultaneously**
- Depends on data and inputs the subroutine requires
- Consider **how subroutines interact with each other**

**User experience:**
- Programs should ensure operations are not carried out in an order that doesn't make sense or will raise errors
- Examples:
  - Adventure game: Users cannot access levels ahead of those they've unlocked
  - Food delivery app: Users cannot select food until location is confirmed
  - Food delivery app: Users cannot pay before confirming order

### Example: Grade Calculation Order

**Problem**: Teacher calculating student grades across classes

**Step 1 - Calculate the grade for each assessment:**
- For each question, mark the question and store the value
- Sum the value of each marked question

**Step 2 - For each student, calculate the average grade:**
- Add up the grade for each assessment
- Divide by the number of assessments
- Store the result

**Step 3 - Repeat steps 1-2 for each class**

---

## Identifying Sub-Procedures Necessary to Solve a Problem

### Hierarchy Charts

**Hierarchy charts** are diagrams used to show problem decomposition and are preferred for larger problems.

**Characteristics:**
- Each problem is **divided into multiple subproblems**
- Subproblems are divided into **further subproblems** until they cannot be divided further
- Shows how **modules and subroutines relate** to each other
- Depicted as a **tree structure**
- Can be created on paper, digitally, or programmatically by software

**Example: Mobile Phone Communication**

```
                    MOBILE PHONE
                         |
        +----------------+----------------+
        |                |                |
   VOICE CALLS    TEXT MESSAGES    CONTACT DATA STORE
        |                |                |
    VIBRATE            [...]            [...]
        |
   +----+----+----+----+
   |    |    |    |    |
RECEIVE  RECEIVE  CONVERT TO  SEND VOICE
VOICE    DATA     ANALOGUE
                      |
              +-------+-------+-------+
              |       |       |       |
          CAPTURE   CONVERT  TRANSMIT
          VOICE   TO DIGITAL TO NETWORK
```

### Goal of Decomposition

Continue splitting problems into subproblems until:
- Each subproblem can be solved using a **single subroutine or module**
- Each sub-task is **unable to be broken down further**
- Each sub-task is **easily solved**
- Each sub-task is **clear**

---

## Summary

**Thinking procedurally** is essential for effective software development, enabling programmers to:
1. **Decompose** complex problems into manageable subproblems
2. Use **abstraction** to focus on relevant details
3. Apply **top-down design** to create hierarchical problem structures
4. Identify **solution components** with appropriate data structures and algorithms
5. Determine the **correct order of execution** for operations
6. Create **sub-procedures** that can be developed, tested, and maintained independently

This approach facilitates team collaboration, code reusability, easier testing, and more maintainable software systems.

---

## Exam Tips

- Be able to **decompose problems** using hierarchy charts or structured descriptions
- Remember that **abstraction** means removing unnecessary details, not oversimplifying
- Understand the difference between **problem decomposition** and **solution identification**
- In exam questions, clearly identify **each sub-procedure's purpose and implementation**
- Basic input procedures (e.g., "move left/right") may not receive credit; focus on **what the procedure outputs or processes**
- Remember that "**procedure**" in this context means any unit of computation performing a single task (not strictly a subroutine without a return value)
- Always consider **validation and error handling** when ordering steps