# 6.4 Thinking Logically - Revision Notes

## Overview

Thinking logically involves understanding how decisions are made within programs and how these decisions affect program execution. This is fundamental to computational thinking and effective problem-solving in computer science.

---

## 1. Decision Making in Problem Solving

### What is a Decision?

A **decision** is a result reached after some consideration. In programming and software development, decisions must be made at multiple stages:

- **Development stage decisions:**
  - Which programming paradigm to use
  - Which programming language to use
  - What input/output devices are needed
  - How to interact with devices
  - How information will be collected

### Simplifying Decision Making

To make effective decisions, you should:

1. **Limit possible solutions** - Consider only feasible options
2. **Evaluate suitability** - Does the solution provide enough functionality?
3. **Consider constraints** - Time, resources, existing knowledge
4. **Gather information** - Research options before deciding

### Key Factors in Decision Making

When making decisions, evaluate these conditions in order of priority:

- **Effectiveness** - Will this achieve the desired outcome?
- **Convenience** - Is this practical and easy to implement?
- **Feasibility** - Is this option reasonable given constraints?

The priority of these factors varies depending on the purpose and end-users of the software.

### Importance of Identifying Decision Points

Identifying where decisions need to be made allows you to:
- Gather sufficient information about options
- Make informed decisions
- Plan for different scenarios
- Anticipate program flow

---

## 2. Structured Programming Techniques

Most programming languages use **structured programming techniques** to control program flow:

### Three Core Constructs

1. **Sequence** - One statement executed after another
2. **Selection** - Decision making using if/then/else or switch/case statements
3. **Iteration** - Loops using for/while/do while/do until

### Purpose of Structured Programming

- Aids **readability** of code
- Improves **understanding** of program logic
- Enhances **maintainability** of code

### Block-Structured Languages

Languages like **Python** are block-structured, using only these three constructs to control program flow. Each code block should have:
- A **single entry point**
- A **single exit point**
- Minimal use of break statements (to prevent unintended flow control issues)

---

## 3. Planning Algorithms

### Tools for Algorithm Design

Before coding, plan algorithms using:

**Flowcharts:**
- **Advantages:** Visually show program flow; decisions are clear and easy to follow
- **Disadvantages:** Time-consuming to create
- **Decision representation:** Diamond-shaped icon with two outcomes (Yes/No or True/False)

**Pseudocode:**
- **Advantages:** More accurately mimics programming language constructs without syntax constraints; any expression is acceptable if meaning is clear
- **Disadvantages:** Can be imprecise

**Structured English:**
- **Advantages:** Alternative to pseudocode for expressing algorithms
- **Disadvantages:** Usually more verbose and imprecise than pseudocode

### Language Considerations

- Languages have specific **syntax, constructs, and idiosyncrasies**
- This makes creating language-independent solutions challenging
- Planning tools help overcome language-specific limitations

---

## 4. Identifying Decision Points in Programs

### Common Decision Locations

Most errors occur when evaluating Boolean conditions. Decisions typically appear in:

1. **If statements** - Single or multiple conditions
2. **Switch/case statements** - Multiple distinct cases
3. **Loops** - Particularly while loops with Boolean stopping conditions

### Selection (Branching)

Selection directs program flow based on Boolean conditions or sets of conditions.

**If/Then/Else Example:**

```
if today == "Monday" then
    print("Eugh! Monday again!")
elseif today == "Tuesday" then
    print("Tuesday, one day closer the weekend!")
elseif today == "Wednesday" then
    print("Half way there!")
elseif today == "Thursday" then
    print("One more day to go!")
elseif today == "Friday" then
    print("I can't believe its Friday!")
elseif today == "Saturday" then
    print("Woo! Its Saturday!")
elseif today == "Sunday" then
    print("Aww, its Monday tomorrow!")
else
    print("That's not a day!")
endif
```

**Switch/Case Example:**

```
switch entry:
    case "Monday":
        print("Eugh! Monday again!")
    case "Tuesday":
        print("Tuesday, one day closer the weekend!")
    case "Wednesday":
        print("Half way there!")
    case "Thursday":
        print("One more day to go!")
    case "Friday":
        print("I can't believe its Friday!")
    case "Saturday":
        print("Woo! Its Saturday!")
    case "Sunday":
        print("Aww, its Monday tomorrow!")
    default:
        print("That's not a day!")
endswitch
```

### Iteration

Iteration involves repeating instructions based on a stopping Boolean condition.

---

## 5. Boolean Conditions

### Boolean Operators

Boolean conditions use these operators:

**Comparison Operators:**
- `==` (equal to)
- `>` (greater than)
- `>=` (greater than or equal to)
- `<` (less than)
- `<=` (less than or equal to)
- `!=` (not equal to)

**Logical Operators:**
- `AND` - Both conditions must be true
- `OR` - Either or both conditions must be true
- `NOT` - The condition is not true
- `XOR` - Only one or the other condition must be true (but not both)

### Practical Examples

**Cinema Entry Example:**

A teenager wants to see a 15-rated movie costing £8. They need to meet both conditions:

```
if age >= 15 and money >= 8 then
    entry = True
endif
```

**List Validation Example:**

Removing numeric strings from a list:

```
i = 0
valid_element = True

while len(my_list) > 0:
    valid_element = True
    element = str(my_list[i])
    
    for index in list_item:
        if list_item[index] in [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] then
            valid_element = False
            break
        endif
    next index
    
    if valid_element == False then
        my_list.pop(i)
    endif
endwhile
```

**Decision points in this algorithm:**
1. **While loop** - List must have at least one element
2. **For loop** - Iterates through all elements until end of list
3. **First if statement** - Checks if character is numeric digit
4. **Second if statement** - Removes item if it contains a digit

**Warning:** Be careful using `break` instructions. While powerful for controlling flow, they can be misused and cause unintended problems.

---

## 6. How Decisions Affect Program Flow

### Different Routes Through Programs

Decisions determine which path the program takes. Different decisions produce:
- **Completely different results**
- **Different routes through the program**

**Example:** Runner Game Design

When designing a runner game, you could choose:
- Endless runner format
- Level-based format

Each decision produces a fundamentally different program structure and user experience.

### Nested Structures

Iteration and selection statements can be **nested**, creating complex flow control:

```
Count ← 0

REPEAT 
    INPUT Score[Count] 
    IF Score[Count] >= 70 THEN 
        Grade[Count] ← "A" 
    ELSE 
        IF Score[Count] >= 60 THEN 
            Grade[Count] ← "B" 
        ELSE 
            IF Score[Count] >= 50 THEN 
                Grade[Count] ← "C" 
            ELSE 
                IF Score[Count] >= 40 THEN 
                    Grade[Count] ← "D" 
                ELSE 
                    IF Score[Count] >= 30 THEN 
                        Grade[Count] ← "E" 
                    ELSE 
                        Grade[Count] ← "F" 
                    ENDIF 
                ENDIF 
            ENDIF 
        ENDIF 
    ENDIF 
    Count ← Count + 1 
UNTIL Count = 30
```

Each nested if statement affects program flow, creating multiple possible paths through the code. This structure is functionally identical to a switch/case statement but demonstrates how nesting affects flow control.

### User Decisions

Thinking logically also involves:
- Identifying where **users** make decisions within the program
- Planning outcomes for each user decision
- Understanding that programs follow different routes depending on user input

---

## 7. Key Principles

### Error Prevention

**Most errors in programs occur when evaluating Boolean conditions**, whether in:
- Sequences (as part of statements)
- Iteration (loop conditions)
- Selection (if/switch conditions)

**Important:** Be especially careful with long, complex conditions involving multiple clauses.

### Benefits of Logical Thinking

Logical thinking allows you to:
- **Plan and prepare** for different scenarios
- **Foresee decisions** throughout the program
- **Understand program flow** before implementation
- **Solve problems effectively** through good decision making

### Best Practice

> "Decision making is one of the most important aspects of problem solving; good decision making is the key to solving problems effectively."

---

## Exam Tips

1. **Flowchart decisions** are represented by diamond shapes with two outcomes (True/False or Yes/No)

2. **Boolean conditions** require careful construction - errors here cause most program bugs

3. **Structured programming** improves code quality through sequence, selection, and iteration

4. **Planning before coding** using flowcharts, pseudocode, or structured English prevents errors

5. **Nested structures** create multiple decision paths - trace through each path carefully

6. **Break statements** should be minimised to maintain clear program flow

7. **Each code block** should have single entry and exit points in block-structured languages
