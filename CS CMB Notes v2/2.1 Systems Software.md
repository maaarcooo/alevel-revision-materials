# 2.1 Systems Software

## Operating Systems

### Definition
An **operating system (OS)** is a collection of programs that work together to provide an **interface between the user and computer hardware**. It enables users to communicate with the computer and perform low-level tasks involving the management of computer memory and resources.

**Examples:** Windows, macOS, Linux, iOS, Android, Ubuntu

### Functions of an Operating System

| Function | Description |
|----------|-------------|
| **Memory Management** | Paging, segmentation, virtual memory |
| **Resource Management** | Scheduling CPU time between processes |
| **File Management** | Moving, editing, deleting files and folders |
| **Input/Output Management** | Device drivers for hardware communication |
| **Interrupt Management** | Handling hardware and software interrupts |
| **Utility Software** | Disk defragmenter, backup, formatting, encryption, compression |
| **Security** | Firewall, password protection, file encryption |
| **User Interface** | GUI (Graphical User Interface) or CLI (Command Line Interface) |
| **Platform for Software** | Providing environment for applications to run |

---

## Memory Management

Memory management is a fundamental role of the OS, dealing with the **allocation and deallocation** of the computer's primary memory. Main memory must be shared fairly between multiple programs and applications.

### Paging

**Paging** is when memory is split into **equal-sized sections** known as **pages**.

- Programs are made up of a certain number of equally-sized pages
- Pages can be **swapped between main memory and the hard disk** as needed
- Memory is dynamically allocated as users switch between applications

**Drawback:** Can lead to **internal fragmentation** - unused space within pages is wasted because other unrelated data cannot be stored in that page.

### Segmentation

**Segmentation** is the splitting of memory into **logical-sized divisions** known as **segments**, which **vary in size**.

- Segments are representative of the **structure and logical flow of the program**
- Segments are allocated to blocks of code such as conditional statements, loops, or different data types (video, audio, etc.)
- **Space-efficient** as segments are sized according to actual needs

**Drawback:** Can lead to **external fragmentation** - as segments fill up memory, physical gaps reduce the maximum size of new segments that can be allocated.

### Virtual Memory

**Virtual memory** uses a **section of the hard drive to act as RAM** when space in main memory is insufficient.

- Sections of programs **not currently in use** are temporarily moved to virtual memory through paging
- Creates an **illusion of larger memory** and enables multitasking
- Frees up RAM for other programs

**Drawback:** Accessing data in virtual memory is **considerably slower** compared to RAM (even SSDs are slower than RAM).

### Disk Thrashing

**Disk thrashing** occurs when pages are **swapped too frequently** between the hard disk and main memory. The computer "freezes" because more time is spent transferring pages than actually running programs. This issue worsens as virtual memory fills up.

---

## Interrupts

### Definition
**Interrupts** are **signals generated by software or hardware** to indicate to the processor that a process needs attention.

### Types of Interrupts

| Type | Definition | Examples |
|------|------------|----------|
| **Hardware Interrupts** | Generated by external devices | Keyboard input, mouse movements, disk I/O requests, printer completion |
| **Software Interrupts** | Triggered by software or the OS | Application requests, division by zero errors |
| **Trap Interrupts** | Intentionally triggered by a program | Software debugging, error handling |

### Interrupt Priority
- Different interrupts have different **priorities**
- Interrupts are stored in order of priority within a **priority queue** in a special register called the **interrupt register**
- Higher-priority interrupts can **pre-empt** lower-priority ones (**nesting**)

### Interrupt Service Routine (ISR)

The **ISR** is a special function that handles a particular interrupt type. The process:

1. **Interrupt Request (IRQ):** An interrupt signal is sent to the processor
2. **Interrupt Acknowledge:** The processor checks the interrupt register at the end of each **Fetch-Decode-Execute cycle**
3. If the interrupt is **higher priority** than the current process:
   - Current contents of **CPU registers are saved to a stack**
   - A **flag is set** to signal ISR has begun
4. **ISR Lookup:** The processor fetches the corresponding ISR
5. **ISR Execution:** The processor executes the routine
6. **Interrupt Exit:** 
   - Flag is reset
   - Interrupt queue is checked for more priority interrupts
   - If none, **stack contents are restored** to registers
   - FDE cycle resumes

---

## Scheduling

### Definition
**Scheduling** ensures all sections of programs being run (known as **jobs**) receive a fair amount of processing time. Different algorithms prioritise and process tasks differently.

### Types of Scheduling

| Type | Description | Examples |
|------|-------------|----------|
| **Pre-emptive** | Jobs are actively made to start and stop by the OS; allocates CPU for time-limited slots | Round Robin, MLFQ, Shortest Remaining Time |
| **Non-pre-emptive** | Once a job starts, it runs until completion or switches to waiting state | First Come First Served, Shortest Job First |

### Scheduling Algorithms

#### Round Robin (RR)
- **Pre-emptive**
- Each job is given a **time slice (time quantum)** to execute
- After using its time slice, the job moves to the **back of the queue**
- Continues until job completion

**Advantages:** All processes get fair share; good for time-sharing systems

**Disadvantages:** Longer jobs take much longer due to inefficient splitting; doesn't consider priority; choosing the right time quantum is difficult

#### First Come First Served (FCFS)
- **Non-pre-emptive**
- Jobs processed in **chronological order** of arrival
- Current job blocks all others until complete

**Advantages:** Simple and easy to implement; fair in order of arrival

**Disadvantages:** Poor performance if long process arrives before shorter ones; doesn't consider priority; high-priority tasks must wait

#### Multi-Level Feedback Queues (MLFQ)
- **Pre-emptive**
- Uses **multiple queues**, each ordered by different priority
- Shorter and more critical tasks processed first
- All processes join the highest priority queue initially
- Jobs that exceed time quantum **trickle down** to lower priority queues

**Advantages:** Smaller tasks prioritised; creates effective prioritisation system

**Disadvantages:** Complex to implement; setting correct parameters is difficult

#### Shortest Job First (SJF)
- **Non-pre-emptive**
- Queue ordered by **time required for completion**
- Shortest jobs serviced first

**Advantages:** Minimises waiting time; efficient for short processes

**Disadvantages:** Requires knowing/calculating burst time in advance; risk of **processor starvation** for longer jobs if short jobs keep arriving

#### Shortest Remaining Time (SRT)
- **Pre-emptive** version of SJF
- Queue ordered by **time left for completion**
- Before each cycle, processes are inspected and reordered

**Advantages:** Ideal for jobs with shorter burst times; aligns with CPU performance

**Disadvantages:** Requires knowing burst time in advance; high context switching overhead; risk of processor starvation for longer jobs

### Processor Starvation
When a process **does not receive enough processor time** to execute and complete. This can occur with SJF and SRT if short jobs continuously arrive.

---

## Types of Operating System

| Type | Description | Example Uses |
|------|-------------|--------------|
| **Distributed** | Run across **multiple devices**, allowing load to be spread across multiple processors | Hadoop for big data processing |
| **Embedded** | Built for a **small range of specific tasks**; catered to a specific device; limited functionality; hard to update; **low power consumption** | Microwaves, washing machines, in-car systems, IoT devices |
| **Multi-tasking** | Enables users to carry out tasks **seemingly simultaneously** using **time slicing** to switch between programs | Windows, macOS, Linux |
| **Multi-user** | Multiple users access one computer (typically a supercomputer); requires scheduling algorithms to share processor time fairly | Server systems |
| **Real-Time** | Designed to perform tasks within a **guaranteed time frame**; used in **time-critical** systems | Nuclear power station control, self-driving cars, aerospace |

---

## BIOS (Basic Input Output System)

### Definition
The **BIOS** is the **first program that runs** when a computer is switched on. It is stored as **firmware** on a small memory chip on the motherboard.

### Functions

1. **POST (Power-On Self-Test):** Diagnostic testing to ensure all hardware is correctly connected and functional
2. Checks **CPU clock, memory, and processor** are operational
3. Tests for **external memory devices** connected to the computer
4. Runs the **Bootstrap/Bootloader** - the program that loads the operating system from the hard disk into RAM

The **Program Counter register** points to the location of the BIOS upon each start-up. Only after BIOS checks are completed can the OS be loaded.

---

## Device Drivers

### Definition
**Device drivers** are computer programs provided by the OS that allow the **operating system to interact with hardware**.

### Key Points
- When hardware is used (e.g., keyboard), the device driver **communicates the request to the OS**, which produces the relevant output
- Device drivers are **specific to the computer's architecture** (different drivers for smartphones, consoles, PCs)
- Device drivers are **specific to the operating system** installed
- Hardware manufacturers typically write their own device driver software
- Device drivers are an example of **abstraction** - users interact with hardware without knowing how it works

---

## Virtual Machines

### Definition
A **virtual machine (VM)** is a **software implementation of a computer system**. It provides an environment with a translator for intermediate code to run.

- VMs run within a physical machine using **hypervisor software**
- Each VM behaves as a separate system with its own OS and applications
- A physical machine can run **multiple VMs**

### Intermediate Code
Code that is **halfway between machine code and object code**. It is **independent of processor architecture** so can be used across different machines and operating systems.

**Example:** Java bytecode executed by the Java Virtual Machine (JVM)

### Uses of Virtual Machines

| Use | Description |
|-----|-------------|
| **Development/Testing** | Create isolated environments to test programs on different operating systems without purchasing multiple devices |
| **Protection from Malware** | Malware affects the VM rather than the host device |
| **Running Incompatible Software** | Programs specific to different OS or different versions can run within a VM |
| **Cross-platform Compatibility** | Run macOS apps on Windows or vice versa |
| **Legacy Support** | Run older versions of Windows for outdated applications |

### Advantages and Disadvantages

| Advantages | Disadvantages |
|------------|---------------|
| Cross-platform software execution | Uses host system resources (CPU, RAM, storage) |
| Supports legacy applications | Performance usually slower than native execution |
| Isolated test environments | Can be complex to set up and manage |
| Executes intermediate code | May require additional OS licences |
| Multiple VMs on single hardware | Resource limits can cause crashes/lag if poorly configured |
| Easy reset/rollback using snapshots | Not all hardware features can be virtualised accurately |

---

## Exam Tips

1. **Memory Management:** Know the difference between paging (equal-sized, internal fragmentation) and segmentation (variable-sized, external fragmentation)

2. **Scheduling:** Be able to explain why specific algorithms are suitable/unsuitable for given scenarios (e.g., FCFS unsuitable for anti-virus as it doesn't prioritise critical tasks)

3. **Types of OS:** Real-time OS is used where response within a certain time is **crucial to safety**

4. **Virtual Machines:** Remember that intermediate code provides platform independence but runs slower than native machine code

5. **BIOS:** If corrupted/overwritten, the computer cannot perform POST and cannot load the bootstrap program, preventing the OS from starting

6. **Interrupts:** The ISR process involves saving register contents to a stack, handling the interrupt, then restoring the stack contents
