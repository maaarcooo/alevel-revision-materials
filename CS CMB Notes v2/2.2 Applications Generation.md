# 2.2 Applications Generation

## Specification Coverage
- 1.2.2 a) Nature of applications
- 1.2.2 b) Utilities
- 1.2.2 c) Open source vs closed source
- 1.2.2 d) Translators (Interpreters, Compilers, Assemblers)
- 1.2.2 e) Stages of compilation (Lexical analysis, Syntax analysis, Code generation, Optimisation)
- 1.2.2 f) Linkers, loaders and use of libraries

---

## Nature of Applications

Software is categorised as either **applications software** or **systems software**.

### Applications Software
- Designed to be **used by the end-user** to perform **one specific task**
- Requires systems software in order to run
- **Examples:** word processors, spreadsheets, web browsers, database management systems, graphics manipulation software, presentation software, email clients, video editing software, IDEs

### Systems Software
- **Low-level software** responsible for running the computer system smoothly
- Interacts with hardware and provides a **platform for applications software to run**
- User does not directly interact with it, but it ensures high performance
- **Examples:** operating system, utility programs, library programs, device drivers

---

## Utilities

**Utilities** are a key piece of **system software** integral to ensuring the **consistent, high performance** of the operating system. Each utility program has a **specific function** linked to the **maintenance of the operating system**.

### Examples of Utility Software

| Utility | Purpose | Function |
|---------|---------|----------|
| **Compression** | Reduce file sizes | Enables files to be compressed and decompressed; used for transmitting large files across the Internet |
| **Disk Defragmentation** | Improve hard disk performance | Rearranges fragmented files on the hard drive into contiguous blocks so they can be accessed faster (Note: SSDs do not require defragmentation) |
| **Antivirus** | Protect the system | Detects potential threats, alerts the user, and removes malicious software |
| **Automatic Updating** | Keep system secure | Automatically installs updates when the computer restarts; tackles bugs and security flaws |
| **Backup** | Prevent data loss | Automatically creates routine copies of specified files at intervals set by the user |
| **File Management** | Organise storage | Creating, deleting, moving, searching, and renaming files and folders |
| **System Cleanup** | Free up space | Removes temporary files, system cache, and unused applications |

---

## Open Source vs Closed Source

**Source code** is the human-readable code written by a programmer. When software is described as 'open source' or 'closed source', this refers to whether the source code is accessible to the public.

### Comparison Table

| Aspect | Open Source | Closed Source |
|--------|-------------|---------------|
| **Definition** | Source code can be used by anyone without a licence and is distributed with the source code | Requires an appropriate licence to use; users cannot access the source code as the company owns the copyright |
| **Cost** | Often free | Usually requires purchase or subscription |
| **Modification** | Can be modified and improved by anyone; can be modified and sold on | Users cannot modify or improve the software themselves |
| **Support** | Technical support from online community; may be insufficient or incorrect; no official user manuals | Company provides expert support and user manuals |
| **Security** | Lower security as may not be developed in a controlled environment | High levels of security as developed professionally |
| **Updates** | Community-driven updates | Thorough, regular, and well-tested updates |
| **Examples** | Linux, Apache HTTP Server, GIMP | Microsoft Windows, Adobe Photoshop |

### Factors to Consider When Choosing Software
- **Costs:** implementation, maintenance, training of staff, licence fees
- **Functionality:** features available, ease of use
- **Suitability:** appropriateness for the intended task

---

## Translators

A **translator** is a program that converts **high-level source code** into **low-level object code** (machine code), which can then be executed by a computer.

### Three Types of Translator

#### Compiler
- Translates high-level code into machine code **all at once**
- Carries out checks and reports **all errors** after compilation
- **Initial compilation is slower** than interpretation
- If changes are made, the **whole program must be recompiled**
- Compiled code is **specific to a particular processor type and operating system**
- Code can be **run without a translator** being present
- **Faster execution** once compiled
- More challenging to debug

#### Interpreter
- Translates and executes code **line-by-line**
- **Stops and produces an error** if a line contains an error
- Appears faster initially as code is **instantly executed**
- **Slower overall** as code must be translated each time it is run
- Useful for **testing and debugging** as errors are pinpointed immediately
- **Requires an interpreter** to be present to run on different devices
- **More portable** - can run on different platforms with the right interpreter

#### Assembler
- Translates **assembly code** (low-level language) into machine code
- Assembly code is **platform-specific** as instructions depend on the processor's instruction set
- Each line of assembly code is equivalent to **almost one line of machine code** (near one-to-one translation)

### Key Note
- **High-level code:** Code written and understood by the programmer but not directly by the computer
- **Low-level code:** Code that can be executed by a computer but cannot be directly understood by humans
- **Machine code** is the same as **object code**

---

## Stages of Compilation

When a compiler is used, high-level code goes through **four stages** before it is turned into object code.

### 1. Lexical Analysis
**Purpose:** Break the code into tokens

Process:
- **Whitespace and comments are removed** from the code
- Remaining code is analysed for **keywords**, **identifiers** (variable/constant names), **operators**, and **separators**
- These are replaced with **tokens**
- Information about each token is stored in a **symbol table**

**Token Types:**
| Type | Examples |
|------|----------|
| Keywords | `var`, `const`, `function`, `for`, `while`, `if`, `return` |
| Identifiers | Variable names, function names |
| Operators | `+`, `-`, `*`, `/`, `=`, `>`, `<` |
| Separators/Delimiters | `,`, `;`, `{`, `}`, `(`, `)` |

### 2. Syntax Analysis
**Purpose:** Check tokens against grammar rules

Process:
- Tokens are **analysed against the grammar and rules** of the programming language
- Tokens that break the rules are **flagged as syntax errors** and added to a list of errors
- This process is called **parsing**
- An **Abstract Syntax Tree (AST)** is produced - a tree-based representation of the source code
- Further details about identifiers are added to the symbol table

**Examples of syntax errors:** undeclared variable type, incomplete set of brackets, missing semicolons, mismatched parentheses

**Semantic analysis** is also carried out at this stage, detecting **logic mistakes** within the program.

**Examples of semantic errors:** multiple declaration of the same variable, undeclared identifiers

### 3. Code Generation
**Purpose:** Create executable machine code

- The **AST is traversed** to generate **object code** (machine code) that can be executed by the computer

### 4. Optimisation
**Purpose:** Improve code efficiency

- Searches through the code for areas where it could be made **more efficient**
- Aims to make the code **faster to execute** and **reduce memory usage**
- **Redundant parts of code are detected and removed**
- Repeated sections may be grouped and replaced with more efficient code
- **Warning:** Excessive optimisation may alter program behaviour
- This stage can **add significantly to compilation time**

---

## Linkers, Loaders, and Use of Libraries

Most programs use **external pieces of code**, including subroutines and libraries from outside sources.

### Libraries
**Definition:** Pre-compiled programs (collections of pre-written code, functions, and procedures) that can be incorporated within other programs.

**Benefits:**
- **Ready-to-use and error-free** - saves development and testing time
- **Reusable** across multiple programs
- Provide **specialised functions** (e.g., mathematical, graphical)
- Programmers don't need to "reinvent the wheel"
- **Reliability** - often well-tested and optimised
- **Community support** and documentation for popular libraries

**Drawbacks:**
- **Dependency issues** - problems if library is discontinued or unmaintained
- **Compatibility issues** with different versions
- **Overhead** - using a large library for a small task adds unnecessary complexity

### Linkers
**Definition:** Software responsible for **linking external modules and libraries** included within the code.

#### Static Linking
- Modules and libraries are **added directly into the main file** at compile time
- **Increases file size**
- External updates to libraries **will not affect** the program
- Allows use of a **specific version** of a library
- No need for external files at runtime

#### Dynamic Linking
- **Addresses of modules and libraries** are included in the file where referenced
- Libraries are linked **at runtime**
- **Files remain small**
- **External updates feed through** to the main file automatically
- No need to rewrite the code when libraries update
- Requires the library to be **present during execution**

### Loaders
**Definition:** Programs provided by the operating system that **load executable files into memory** so they can be run.

- When a file is executed, the loader **retrieves the library or subroutine from the given memory location**
- Essential for dynamic linking, as they locate and load required libraries at runtime

---

## Summary Table: Compiler vs Interpreter

| Feature | Compiler | Interpreter |
|---------|----------|-------------|
| Translation method | All at once | Line-by-line |
| Error reporting | After full compilation | Immediately when encountered |
| Execution speed | Faster (once compiled) | Slower (translates each time) |
| Debugging | More difficult | Easier - pinpoints errors |
| Portability | Platform-specific | More portable |
| Translator required at runtime | No | Yes |
| Re-translation needed | Only when code changes | Every time program runs |

---

## Exam Tips

1. **Application software questions** often require recommending suitable software for a scenario - identify user tasks and match them to application features.

2. **Utility software** - be able to explain the purpose and function of each type, not just name them.

3. **Open vs closed source** - questions may ask for benefits/drawbacks from either the user's or creator's perspective.

4. **Compilation stages** - be able to explain what happens at each stage and provide examples of errors detected.

5. **Linkers** - understand the difference between static and dynamic linking, including advantages and disadvantages of each.

6. **Libraries** - be prepared to give specific examples and explain how they save development time.
