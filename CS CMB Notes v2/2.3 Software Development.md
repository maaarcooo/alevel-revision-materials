# 2.3 Software Development

## Software Development Life Cycles (SDLCs)

Software can be developed using various approaches. The methodology chosen depends on the type of software being developed, but most SDLCs share common stages.

### Common SDLC Stages

**Analysis**
- Stakeholders state requirements for the finished product
- Used to **clearly define the problem** and **system requirements**
- Requirements defined by:
  - Analysing strengths and weaknesses of current solutions
  - Considering data types: inputs, outputs, stored data, and volume

**Design**
- Different aspects of the new system are designed:
  - Inputs: volume, methods, frequency
  - Outputs: volume, methods, frequency
  - Security features: level required, access levels
  - Hardware set-up: compatibility
  - User interface: menus, accessibility, navigation
- A **test plan** may be designed at this stage

**Development (Implementation)**
- Design is used to split the project into **individual, self-contained modules**
- Modules are allocated to teams for programming
- Actual code is written based on design documents

**Testing**
- Program tested against the test plan from the Design stage
- Types of testing:

| Testing Type | Description |
|--------------|-------------|
| **Alpha testing** | Carried out **in-house** by software development teams. Bugs are identified and fixed. |
| **Beta testing** | Carried out by **end-users** after alpha testing. Feedback informs the next development stage. |
| **White box testing** | Test plan based on **internal structure** of the program. All possible routes through the program are tested. Carried out by developers. |
| **Black box testing** | Testers are **unaware of internal structure**. Tests trace inputs and outputs. Can be done internally or by end-users. |

**Implementation (Deployment)**
- Software is **installed onto users' systems**
- May involve installation, customisation, and training

**Evaluation**
- Software effectiveness evaluated against **system requirements** from analysis stage
- Criteria considered: **robustness, reliability, portability, maintainability**

**Maintenance**
- Errors and improvements flagged by end-users
- Programmers send **software updates** to fix bugs, security issues, or make improvements

---

## Programming Methodologies

### Waterfall Lifecycle

A **sequential software development process** divided into distinct phases, where each phase must be completed before the next begins.

**Stages:** Requirements → Design → Development → Testing → Deployment → Maintenance

**Feasibility Study (TELOS)**
During analysis, designers evaluate project feasibility using:
- **T**echnical: Is the project possible with available technology?
- **E**conomic: Can the project be financed short-term and long-term?
- **L**egal: Can the project be completed within the law?
- **O**perational: Can the project be successfully implemented and maintained?
- **S**cheduling: Can the project be completed in the time available?

**Key Characteristics:**
- If changes are needed, programmers must **revisit all levels** between current stage and the stage requiring change
- Makes the model **inflexible**
- Users have **little input** (only involved at analysis and evaluation stages)

| Benefits | Drawbacks |
|----------|-----------|
| Simple and linear - easy to understand | Inflexible - changes difficult to implement |
| Clear stages and milestones | Expensive to fix late problems |
| Straightforward to manage | Long development cycle |
| Clearly documented | No risk analysis |
| Suitable for well-defined projects | Limited user involvement |

**Suitable for:** Static, low-risk projects with well-understood requirements unlikely to change (e.g., general-purpose software)

---

### Agile Methodologies

A **collection of methodologies** aimed at improving flexibility and adapting to changes in user requirements faster.

**Key Characteristics:**
- Problem broken down into sections **developed in parallel**
- Design and analysis phases often occur together
- Different sections can be at **different stages of development**
- **Working prototype delivered early** and improved iteratively
- New prototypes delivered **regularly throughout development**
- **Less focus on documentation**, more priority on **user satisfaction**

| Benefits | Drawbacks |
|----------|-----------|
| Produces high quality code | Poor documentation |
| Flexible to changing requirements | Requires consistent interaction between user and programmer |
| Regular user input | Scope creep possible |
| Highly adaptable | Requires experienced team members |
| Quality focus with continuous testing | Intensive collaboration can lead to burnout |

**Suitable for:** Small to medium projects with unclear initial requirements where customer involvement is high

---

### Extreme Programming (XP)

An **agile model** with specific practices for high-quality development.

**Key Characteristics:**
- Development team consists of a **pair of programmers** alongside a **representative end-user**
- Built on **'user stories'**: system requirements specified by end-user
- **Paired programming**: code written by one person, critiqued by the other
- Programmers work **no longer than 40 hours per week** to maintain quality
- Each iteration generates a **'working version'** that could function as final product

**Sprint-Based Process:**
1. Identify user stories and requirements
2. Plan the sprint (1-4 weeks time-boxed period)
3. Design the solution (simple and adaptable)
4. Develop features (often using pair programming)
5. Test continuously (unit, integration, acceptance testing)
6. Review progress (Sprint Review) - demo to stakeholders
7. Reflect on process (Sprint Retrospective)
8. Release and repeat

| Benefits | Drawbacks |
|----------|-----------|
| Produces high quality code | High cost of two people on one project |
| Constant user involvement = high usability | Teamwork is essential |
| Frequent communication | End-user may not be able to be present |
| Customer collaboration | Iterative nature makes documentation difficult |

**Suitable for:** Small to medium projects with unclear initial requirements requiring excellent usability

---

### Spiral Model

Combines aspects of both **iterative (agile)** and **sequential (waterfall)** processes, focused on **effectively managing risk-heavy projects**.

**Four Key Stages (repeated in spirals):**
1. **Planning**: Define objectives, alternatives, and constraints
2. **Risk Analysis**: Identify and assess potential risks; plan mitigation strategies
3. **Engineering**: Development, testing, and implementation
4. **Evaluation**: Review progress with stakeholders; plan next iteration

**Key Characteristics:**
- If project found **too risky at any point**, it is **terminated**
- Requires hiring **risk assessors** (expensive)
- Each spiral loop represents a development phase

| Benefits | Drawbacks |
|----------|-----------|
| Thorough risk-analysis and mitigation | Expensive to hire risk assessors |
| Flexible - allows changes at various stages | Lack of focus on code efficiency |
| Caters to changing user needs | High costs due to constant prototyping |
| Strong customer involvement | Complex and harder to manage |
| Produces prototypes throughout | Time-consuming |
| Incremental releases | Not suitable for small projects |

**Suitable for:** Large, complex, risk-intensive projects with high budget where requirements may change

---

### Rapid Application Development (RAD)

An **iterative methodology** emphasising **fast development** using **partially functioning prototypes** that are continually built upon.

**Stages:**
1. **Requirement Planning**: Gather general requirements using focus groups; define constraints
2. **User Design and Prototyping**: Collaborate with users to develop prototypes
3. **Construction**: Build system incrementally with continuous user feedback
4. **Cutover (Deployment)**: Transition to live environment; user training and documentation
5. **Maintenance**: Continue adapting based on user feedback

**Key Characteristics:**
- User requirements initially gathered using **focus groups**
- **'Incomplete' version** given to users to trial
- **User feedback** generates next improved prototype
- Continues until prototype matches requirements → becomes **final product**
- Commonly used where **requirements are incomplete or unclear**
- As requirements change, code additions may be **inefficient**

| Benefits | Drawbacks |
|----------|-----------|
| Caters to changing user requirements | Poorer quality documentation |
| Highly usable finished product | Fast pace may reduce code quality |
| Focus on core features, reducing development time | Dependent on strong team collaboration |
| Speed - rapid delivery at low cost | Can lead to scope creep |
| Flexible and adaptable | Not suitable for small projects |

**Suitable for:** Small to medium, low-budget projects with short time-frames requiring quick delivery and active user participation

---

## Comparing Software Development Models

| Method | Process Type | Best For | Key Strength | Key Weakness |
|--------|--------------|----------|--------------|--------------|
| **Waterfall** | Sequential/Linear | Stable, well-defined requirements | Clear stages, good documentation | Inflexible, expensive late changes |
| **Agile** | Iterative | Changing requirements, high user involvement | Flexible, rapid delivery | Scope creep, poor documentation |
| **Extreme Programming** | Iterative (Agile) | High usability needs | High quality code, constant feedback | High cost (pair programming) |
| **Spiral** | Cyclic (hybrid) | Large, risky projects | Risk management focus | Expensive, complex |
| **RAD** | Iterative | Quick delivery needed | Speed, user feedback | Quality issues, collaboration dependent |

---

## Writing and Following Algorithms

An **algorithm** is a **set of instructions used to solve a problem**.

### Key Qualities of Good Algorithms

- **Inputs must be clearly defined** - what is valid and invalid?
- Must **always produce a valid output** for any defined input
- Must be able to **deal with invalid inputs**
- Must **always reach a stopping condition**
- Must be **well-documented** for reference
- Must be **well-commented** so modifications can easily be made

---

## Exam Tips

**When comparing methodologies:**
1. Introduce both methodologies with key features
2. Compare and contrast similarities and differences
3. Identify specifics from the scenario given
4. Recommend one methodology with clear justification

**Key terms to remember:**
- **Iterative**: Process repeats in cycles
- **Sequential**: Stages completed in order
- **Prototype**: Working model of the software
- **User stories**: Requirements specified by end-users
- **Sprint**: Time-boxed development period (typically 1-4 weeks)
- **TELOS**: Feasibility study criteria (Technical, Economic, Legal, Operational, Scheduling)
