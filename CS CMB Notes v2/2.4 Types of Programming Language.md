# 2.4 Types of Programming Language

## Specification Coverage
- 1.2.4 a) Programming paradigms (need for and characteristics)
- 1.2.4 b) Procedural languages
- 1.2.4 c) Assembly language (following and writing LMC programs)
- 1.2.4 d) Modes of addressing memory (Immediate, Direct, Indirect, Indexed)
- 1.2.4 e) Object-oriented languages (Classes, Objects, Methods, Attributes, Inheritance, Encapsulation, Polymorphism)

---

## Programming Paradigms

**Programming paradigms** are different approaches to using a programming language to solve a problem. They are established conventions and practices that dictate how computer programs are structured and developed.

### Classification of Paradigms

```
                    Programming Paradigms
                           │
            ┌──────────────┴──────────────┐
            │                             │
       Imperative                    Declarative
            │                             │
     ┌──────┴──────┐              ┌───────┴───────┐
     │             │              │               │
Procedural    Object-        Functional        Logic
              Oriented
```

### Why Different Paradigms Exist
- Different paradigms are **suited to different tasks**
- Simple applications can use lightweight procedural languages
- Complex enterprise-level software may require object-oriented approaches
- New paradigms arise in response to changes in computing and software challenges
- Most programming languages (e.g., Python) support **more than one paradigm**

---

## Imperative Programming

**Imperative programming** paradigms use code that **clearly specifies the actions to be performed**. The programmer defines exactly how the computer should accomplish a task through step-by-step instructions.

### Procedural Programming

**Procedural programming** is a subtype of imperative programming, structured around **procedure calls** and a **sequence of instructions** executed in a **step-by-step manner**.

**Key Characteristics:**
- Uses **traditional data types** (integers, strings) built into the language
- Provides **data structures** like arrays and dictionaries
- **Simple to implement** and widely applicable
- Clear **flow of control** (top to bottom)
- Not possible or efficient to solve **all kinds of problems**

**Example Languages:** Pascal, Python, C, Go, Rust

#### Structured Programming Constructs

Structured programming is a popular subsection of procedural programming using four main control flow structures:

| Construct | Description | Implementation |
|-----------|-------------|----------------|
| **Sequence** | Code executed **line-by-line**, from top to bottom | Default execution order |
| **Selection** | A block of code runs **if a specific condition is met** | IF statements |
| **Iteration** | A block executes a **certain number of times** or **while a condition is met** | FOR, WHILE, REPEAT UNTIL loops |
| **Recursion** | Functions **expressed in terms of themselves**, calling themselves until a **base case** is met | Recursive function calls |

---

### Object-Oriented Programming (OOP)

**Object-oriented programming** organises code around **objects** (which combine data and functionality) rather than functions. It is applicable to problems with **lots of reusable components** with **similar characteristics**.

**Key Characteristics:**
- Built on entities called **objects** formed from **classes**
- Objects have **attributes** (state/properties) and **methods** (behaviour/actions)
- Focuses on making programs **reusable** and **easy to update and maintain**
- Requires **advance planning** to determine class structure

**Example Languages:** Python, Java, C#, Delphi, Swift

---

## Declarative Programming

**Declarative programming** focuses on **stating the desired result** rather than the exact series of instructions needed. The programming language determines **how best to obtain the result**, with implementation details **abstracted from the user**.

Common in **expert systems** and **artificial intelligence**.

### Functional Programming

**Functional programming** uses the concept of **reusing a set of functions** which form the core of the program. Programs consist of **function calls**, often combined within each other. It is **closely linked to mathematics**.

**Example Languages:** Haskell, C#, Java

### Logic Programming

**Logic programming** uses code which defines a **set of facts and rules** based on the problem. **Queries** are used to find answers to problems.

**Example Language:** Prolog

---

## Paradigm Comparison

| Paradigm | Strengths | Weaknesses |
|----------|-----------|------------|
| **Procedural** | Efficient execution of straightforward tasks; Clear flow of control; Easy implementation for algorithms | Can become unwieldy for large programs; Lack of modularity leads to code redundancy; Difficult to manage and scale |
| **Object-Oriented** | High level of reusability through inheritance and polymorphism; Enhances modularity with encapsulation; Enables real-world modelling; Easy to maintain and update; High level of abstraction | Can lead to unnecessary complexity; Inefficiency due to overhead (memory for objects); Requires different style of thinking; Not suited to all problems; Unsuitable for smaller problems |
| **Assembly** | Direct control over hardware; Optimised performance; Transparent understanding of machine operations; Potential for very efficient code | Extremely steep learning curve; Hardware-specific (lack of portability); Tedious and error-prone; Difficult to write, debug, and maintain |

---

## Assembly Language

**Assembly language** is a **low-level language**, one level up from machine code. It is converted to machine code using an **assembler** when executed.

**Key Characteristics:**
- Uses **mnemonics** rather than binary, making it easier than direct machine code
- Each mnemonic is represented by a **numeric code**
- Commands are **processor-specific** as it directly interacts with the CPU's **special purpose registers**
- Allows **direct interaction with hardware** (useful in embedded systems)
- Each instruction is typically equivalent to **almost one line of machine code**

### Little Man Computer (LMC)

The **Little Man Computer** is a hypothetical computer model used for understanding fundamental computer operations. It has key elements: **memory**, a **calculator**, an **accumulator**, and an **instruction set**.

### LMC Instruction Set

| Mnemonic | Instruction | Function | Alternative |
|----------|-------------|----------|-------------|
| **ADD** | Add | Add the value at the given memory address to the value in the Accumulator | - |
| **SUB** | Subtract | Subtract the value at the given memory address from the value in the Accumulator | - |
| **STA** | Store | Store the value in the Accumulator at the given memory address | STO |
| **LDA** | Load | Load the value at the given memory address into the Accumulator | LOAD |
| **INP** | Input | Allows user to input a value which will be held in the Accumulator | IN, INPUT |
| **OUT** | Output | Prints the value currently held in the Accumulator | - |
| **HLT** | Halt | Stops the program, preventing rest of code from executing | COB, END |
| **DAT** | Data | Creates a flag with a label at which data is stored | - |
| **BRZ** | Branch if zero | Branches to a given address if the value in the Accumulator is zero (conditional branch) | BZ |
| **BRP** | Branch if positive or zero | Branches to a given address if the value in the Accumulator is positive or zero (conditional branch) | BP |
| **BRA** | Branch always | Branches to a given address regardless of the Accumulator value (unconditional branch) | BR |

### LMC Example: Modulus (Remainder)

This program returns the remainder when num1 is divided by num2:

```
        INP
        STA num1
        INP
        STA num2
        LDA num1
positive STA num1       // Loop: subtract num2 while result
        SUB num2        // is positive or zero
        BRP positive    
        LDA num1        // When negative, load last positive value
        OUT
        HLT
num1    DAT
num2    DAT
```

### LMC Example: Add Two Numbers

```
INP             // Input first number
STA 90          // Store at memory location 90
INP             // Input second number
ADD 90          // Add value at location 90 to accumulator
OUT             // Output result
HLT             // End program
DAT             // Memory location for storing data
```

---

## Modes of Addressing Memory

Machine code instructions consist of two parts:
- **Opcode**: specifies the instruction to be performed
- **Operand**: holds a value related to the data on which the instruction is performed

**Addressing modes** specify **how the operand should be interpreted**. The addressing mode is **part of the opcode**. They allow for a **much greater number of locations** for data storage, as the operand size would otherwise constrain addressable memory.

```
┌─────────────────────────┬───────────────────┐
│        OPCODE           │     OPERAND       │
├─────────────┬───────────┼───────────────────┤
│ Instruction │ Addressing│                   │
│             │   Mode    │                   │
└─────────────┴───────────┴───────────────────┘
```

### Four Addressing Modes

| Mode | Description | Example |
|------|-------------|---------|
| **Immediate** | The operand is the **actual value** upon which the instruction is performed (represented in binary) | `MOV AX, 1234h` - Moves the value 1234h directly to AX |
| **Direct** | The operand gives the **address which holds the value** upon which the instruction is performed. **Used in LMC** | `MOV AX, [1234h]` - Moves the value stored at memory location 1234h to AX |
| **Indirect** | The operand gives the **address of a register which holds another address**, where the data is located | `MOV AX, [BX]` - If BX contains 2000h, moves the value from memory location 2000h to AX |
| **Indexed** | An **index register** stores a value; the address is determined by **adding the operand to the index register**. Used to access **contiguous data** (e.g., arrays) | `MOV AX, [BX + SI]` - If BX=0050h and SI=1000h, accesses memory location 1050h |

**Note:** In assembly, brackets [ ] indicate the value inside should be treated as a **memory address**, not the value itself.

---

## Object-Oriented Programming Concepts

### Classes and Objects

| Term | Definition |
|------|------------|
| **Class** | A **template for an object** that defines the state and behaviour of an object |
| **Object** | A **particular instance of a class**, created through **instantiation** |
| **Attributes** | Give an object's **properties** (state) |
| **Methods** | Describe the **actions** a class can perform (behaviour) |

A class can be used to create **multiple objects** with the same set of attributes and methods.

### Example Class Structure

```
┌─────────────────────┐      ┌─────────────────────┐
│       Library       │      │        Book         │
├─────────────────────┤      ├─────────────────────┤
│ Methods:            │      │ Methods:            │
│   add_book          │      │   set_reserved      │
│   remove_book       │      │   set_onloan        │
├─────────────────────┤      ├─────────────────────┤
│ Attributes:         │      │ Attributes:         │
│   no_of_books       │      │   reserved          │
│   no_of_computers   │      │   onloan            │
└─────────────────────┘      │   author            │
                             │   title             │
                             └─────────────────────┘
```

### Getters and Setters

- **Setter**: A method that **sets the value** of a particular attribute
- **Getter**: A method that **retrieves the value** of a given attribute

These ensure attributes **cannot be directly accessed and edited** by users.

### Constructor

Every class must have a **constructor method** (called `new`). A constructor **allows a new object to be created** and initialises its attributes.

### Pseudocode Example

```
class Book:
    private reserved
    private onLoan
    private author
    private title
    
    public procedure new(givenTitle, givenAuthor, givenReserved, givenOnLoan)
        title = givenTitle
        author = givenAuthor
        reserved = givenReserved
        onLoan = givenOnLoan
    end procedure
    
    public function set_reserved()
        reserved = True
    end function
end class
```

**Creating an object:**
```
myBook = new Book('Great Expectations', 'Charles Dickens', 'False', 'False')
```

**Calling a method:**
```
myBook.set_reserved()
```

---

### Encapsulation

**Encapsulation** is the property of OOP where **attributes cannot be directly accessed and edited** by users. Attributes are declared as **private** so can only be altered by **public methods**.

**Benefits:**
- Makes code **more reliable** by protecting attributes
- Code for different classes can be **produced independently**
- Allows objects to be used as a **black box** without knowing implementation details

---

### Inheritance

**Inheritance** allows a class to **inherit from another class**, possessing all methods and attributes of the parent while having its own additional properties.

```
┌─────────────────────┐
│    Superclass       │
│   (Parent Class)    │
├─────────────────────┤
│ Methods             │
│ Attributes          │
└─────────┬───────────┘
          │ inherits
          ▼
┌─────────────────────┐
│     Subclass        │
│  (Derived Class)    │
├─────────────────────┤
│ Methods             │
│ Attributes          │
│ + Additional        │
└─────────────────────┘
```

**Example:** A `Biography` class could inherit from `Book` and have its own attributes (e.g., `Subject`) while still having `author` and `title`.

**Syntax:**
```
class Biography inherits Book
```

---

### Polymorphism

**Polymorphism** means objects can **behave differently depending on their class**. The same method can produce **different outputs** depending on the object involved.

**Two categories:**

| Type | Description |
|------|-------------|
| **Overriding** | **Redefining a method** within a subclass so it functions differently and produces a different output |
| **Overloading** | Passing **different parameters** into a method to produce different results |

---

## OOP Advantages and Disadvantages

### Advantages
- **High level of reusability** through inheritance and polymorphism
- Classes can be **used across multiple projects**
- **Encapsulation** makes code more reliable
- **Advance planning** required leads to higher-quality software with fewer vulnerabilities
- **Modular structure** makes it easy to maintain and update
- **High level of abstraction** - classes can be reused as a black box, saving time

### Disadvantages
- Requires an **alternative style of thinking** (difficult for programmers used to other paradigms)
- **Not suited to all types of problems** - may result in longer, less efficient programs where few components are reused
- Generally **unsuitable for smaller problems**
- Can lead to **unnecessary complexity**
- **Inefficiency due to overhead** (e.g., memory for objects)

---

## Exam Tips

1. **LMC Programs**: Trace through each instruction carefully, tracking the Accumulator value at each step
2. **Addressing Modes**: Remember the key difference - immediate uses the value directly, direct uses it as an address, indirect uses it as an address containing another address
3. **OOP Terminology**: Be precise - encapsulation protects data, inheritance reuses code, polymorphism allows flexible behaviour
4. **Paradigm Selection**: Be able to justify why a particular paradigm suits a given problem
5. **BRP in LMC**: Branches if the accumulator is positive **or zero** (not just positive)
