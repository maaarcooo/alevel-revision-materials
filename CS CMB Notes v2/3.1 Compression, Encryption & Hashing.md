# 3.1 Compression, Encryption & Hashing

## Specification Coverage
- 1.3.1 a) Lossy vs Lossless compression
- 1.3.1 b) Run length encoding and dictionary coding for lossless compression
- 1.3.1 c) Symmetric and asymmetric encryption
- 1.3.1 d) Different uses of hashing

---

## Compression

### Why is Compression Needed?

**Compression** is the process used to **reduce the storage space** required by a file. This provides two key benefits:

1. **Storage efficiency** - More files can be stored with the same amount of storage space
2. **Faster transmission** - Smaller files transfer more quickly over networks, requiring less bandwidth consumption

Compression is particularly important for sharing files over networks or the Internet. The larger a file, the longer it takes to transfer.

---

### Lossy vs Lossless Compression

There are two categories of compression: **lossy** and **lossless**.

#### Lossy Compression
- **Reduces file size** while **removing some information permanently**
- Results in some quality degradation (e.g., more pixelated images, less clear audio)
- **Irreversible** - the original file **cannot be recovered** from the compressed version
- Achieves **greater file size reduction** than lossless compression

**Example:** Audio files can be compressed by removing very high or very low frequencies which are least noticeable to the human ear.

#### Lossless Compression
- **Reduces file size without losing any information**
- The **original file can be fully recovered** from the compressed version
- Results in **larger file sizes** than lossy compression
- **Maintains data integrity**

#### Comparison Table

| Aspect | Lossy | Lossless |
|--------|-------|----------|
| **File Size Reduction** | Greater reduction | Smaller reduction |
| **Data Loss** | Some data discarded | No data lost |
| **Reversibility** | Irreversible | Fully reversible |
| **Best For** | Media streaming, social media images | Text files, archival storage, professional images |
| **Drawbacks** | Quality degradation | Larger file sizes, higher bandwidth needs |

#### Choosing a Compression Type
- If **data integrity** is imperative → **lossless compression**
- If **small file size** or **quick transfer** is prioritised, and some data loss is acceptable → **lossy compression**

---

### Run Length Encoding (RLE)

**Run Length Encoding** is a method of **lossless compression** in which **repeated consecutive values** are removed and replaced with:
- **One occurrence** of the data
- Followed by the **number of times** it should be repeated

#### Example
Original string: `AAAAAABBBBBCCC`  
Compressed: `A6B5C3`

#### Decompression Example
Compressed: `3C3M4C`  
Decompressed: `CCCMMMCCCC`

#### Compression Example
Original: `CCCCOLLLCCCCCMOCCCCC`  
Compressed: `4C1O3L5C1M1O5C`

#### Limitations
- RLE relies on **consecutive pieces of data being the same**
- If there's **little repetition**, RLE doesn't offer a significant reduction in file size
- Most effective when data has **lots of repetition** (e.g., bitmap images with sequences of the same colour)

---

### Dictionary Encoding (Dictionary Coding)

**Dictionary encoding** is another method of **lossless compression** where:
- **Frequently occurring sequences** are replaced with **shorter, unique codes**
- A **dictionary** is compiled to map original sequences to special codes
- Compressed data is stored **alongside the dictionary**
- The original data can be **restored using the dictionary**

#### Example

**Original text:**
```
We shall go on to the end.
We shall fight in France,
we shall fight on the seas and oceans,
we shall fight with growing confidence and growing strength in the air,
we shall defend our island, whatever the cost may be.
```

**Dictionary:**
| Index | Phrase |
|-------|--------|
| 1 | We shall |
| 2 | fight |
| 3 | the |
| 4 | on |
| 5 | in |
| 6 | and |

**Compressed text:**
```
1 go on to 3 end.
1 2 5 France,
1 2 on 3 seas 6 oceans,
1 2 with growing confidence 6 growing strength 5 3 air,
1 defend our island, whatever 3 cost may be.
```

#### Important Points
- Data compressed using dictionary compression **must be transferred alongside its dictionary**
- Without the dictionary, the data **cannot be used**
- More versatile than RLE but may require **more computational resources**
- Effective for both **text and binary data**

---

## Encryption

**Encryption** is used to **keep data secure** when it's being transmitted. It scrambles data before transmission and deciphers it at the destination.

Encryption methods use **keys** - specialised programs designed to scramble or unscramble data.

---

### Symmetric Encryption

In **symmetric encryption**:
- Both sender and receiver share the **same private key**
- This key is distributed through a process called a **key exchange**
- The **same key** is used for both **encrypting and decrypting** data

#### Characteristics
- **Faster** than asymmetric encryption
- Ideal for encrypting **large amounts of data**
- Suitable for scenarios where the **same person encrypts and decrypts** (e.g., backing up data)

#### Security Risk
- The private key must be **kept secret**
- If the key is **intercepted during the key exchange**, all communications can be decrypted
- The challenge lies in **securely sharing the key** between parties

---

### Asymmetric Encryption

In **asymmetric encryption**, **two keys** are used:
- A **public key** for encryption (can be published anywhere)
- A **private key** for decryption (must be kept secret)

Together, these keys are known as a **key pair** and are **mathematically related** to one another.

#### How It Works
1. The receiver **openly shares their public key**
2. The sender uses this **public key to encrypt** the data
3. **Only the receiver's private key** can decrypt the data
4. A single key **cannot** be used to both encrypt and decrypt

#### Digital Signatures
- To prove a message was sent by you, encrypt it using **your private key**
- Anyone can decrypt it using your public key
- This **guarantees** you encrypted the message, as only you have access to the private key

#### Characteristics
- **Slower** than symmetric encryption
- **More secure** - solves the key distribution problem
- Best for **secure and smaller data transactions** (e.g., passwords, bank details, government communications)

---

### Comparison: Symmetric vs Asymmetric

| Aspect | Symmetric | Asymmetric |
|--------|-----------|------------|
| **Keys** | Single shared key | Public/private key pair |
| **Speed** | Faster | Slower |
| **Key Distribution** | Challenging (security risk) | Easier (public key shared openly) |
| **Best For** | Large files, databases, bulk data | Confidential communications, passwords |
| **Security Risk** | Key interception during exchange | Private key compromise |

---

## Hashing

**Hashing** is a process in which an **input (called a key)** is converted into a **fixed-size value (called a hash or digest)** using algorithms called **hash functions**.

### Key Properties of Hashing

1. **One-way function** - Unlike encryption, the output **cannot be reversed** to form the original key
2. **Consistency** - The same input will **always produce the same hash**
3. **Sensitivity** - Even a minor change in input produces a **radically different hash**
4. **Fixed-size output** - The hash digest is always the same length regardless of input size

#### Example of Hash Sensitivity

| Input | Algorithm | Hash (Truncated) |
|-------|-----------|------------------|
| "hello123" | SHA-256 | 8d9389d5a0375bd6... |
| "hello124" | SHA-256 | 9ac12bac3a0843a1... |

---

### Common Hashing Algorithms

- **MD5 (Message Digest 5)** - Widely used but considered weak due to vulnerabilities to collision attacks
- **SHA-1 (Secure Hash Algorithm 1)** - Previously used in SSL certificates; now considered weak
- **SHA-256 (SHA-2 family)** - Commonly used in cryptographic applications; considered secure for most purposes
- **SHA-3** - Most recent; designed to provide higher levels of security

---

### Properties of a Good Hash Function

1. **Low chance of collision** - Different inputs should produce different hashes
2. **Quick to calculate** - Efficient computation
3. **Output smaller than input** - Otherwise searching for the hash could take longer than searching for the key

---

### Hash Collisions

A **collision** occurs when two different pieces of data (keys) produce the **same hash**.

**Example:** Keys "John" and "Sandra" both hash to "02"

#### Methods to Handle Collisions
- Storing items together **in a list** under the hash value (chaining)
- Using a **second hash function** to generate a new hash (rehashing)

---

### Uses of Hashing

#### 1. Password Storage

Hashing is commonly used for **storing passwords securely**:

**Sign-up process:**
1. User provides password
2. Password is **hashed**
3. **Hashed password** (not plaintext) is stored in database

**Login process:**
1. User enters password
2. System **hashes the entered password**
3. Hashed value is **compared against stored hash**
4. If hashes **match** → access granted
5. If hashes **don't match** → access denied

**Security Benefits:**
- Even if the database is compromised, attackers only gain access to **hashes, not passwords**
- Hashes **cannot be reversed** to obtain original passwords
- Minimises risk and legal repercussions in case of data breach

#### 2. Hash Tables

A **hash table** is a data structure that holds **key-value pairs**:
- Formed from a **bucket array** and a **hash function**
- Enables data lookup in **constant time O(1)**
- When data is inserted, it's used as the key for the hash function and stored in the corresponding bucket

**Uses:** Caches, databases - anywhere requiring **fast data retrieval** with constant access times

#### 3. Data Integrity Verification

- When data is transferred over a network, it's susceptible to **loss or malicious interference**
- If two hashes are compared and are **identical**, it verifies the **integrity of data**
- The same data hashed by the same function will produce the **same digest**
- Comparing **fixed-size hashes** is computationally less intensive than string comparison

---

### Comparison: Encryption vs Hashing

| Aspect | Encryption | Hashing |
|--------|------------|---------|
| **Purpose** | Securing data; reversible | Data verification; irreversible |
| **Reversibility** | Can be decrypted | Cannot be reversed |
| **Keys** | Uses keys for encryption/decryption | No keys involved |
| **Speed** | Generally slower | Generally faster |
| **Use Cases** | Secure communications, file storage | Password storage, data integrity |
| **Output Length** | Varies | Fixed length |

---

## Exam Tips

1. When recommending a compression type, the choice **always depends on specific scenario requirements**
2. RLE is more effective with **lots of repetition**; Dictionary coding is more **versatile**
3. For encryption questions, consider whether **speed or security** is more critical
4. Remember that hashing is a **one-way function** - this is its key distinction from encryption
5. Hash tables provide **O(1) constant time** lookup - link to Data Structures topic (1.4.2)

---

## Key Terminology Summary

| Term | Definition |
|------|------------|
| **Compression** | Process to reduce storage space required by a file |
| **Lossy** | Compression that permanently removes some data |
| **Lossless** | Compression that preserves all original data |
| **RLE** | Lossless compression replacing repeated consecutive values with count |
| **Dictionary encoding** | Lossless compression replacing frequent sequences with codes |
| **Symmetric encryption** | Uses same key for encryption and decryption |
| **Asymmetric encryption** | Uses public key for encryption, private key for decryption |
| **Key pair** | Mathematically related public and private keys |
| **Key exchange** | Process of distributing shared key in symmetric encryption |
| **Digital signature** | Authentication using private key encryption |
| **Hashing** | One-way function converting input to fixed-size output |
| **Hash digest** | The fixed-size output of a hash function |
| **Collision** | When different inputs produce the same hash |
| **Hash table** | Data structure using hashing for O(1) lookup |
