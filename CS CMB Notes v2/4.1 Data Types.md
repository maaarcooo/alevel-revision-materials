# 4.1 Data Types

## Specification Reference
**OCR A Level Computer Science - Component 1: 1.4.1**

---

## Primitive Data Types

All data is stored in **binary** by computers, but the way data is represented varies between different types. Using the correct data type ensures appropriate operations can be performed on the data.

### Integer
A **whole number** that includes zero and negative numbers but **cannot have a fractional part**. Used for **counting** things.

Examples: `6`, `47238`, `-12`, `0`, `15`

### Real / Floating Point
**Positive or negative numbers** that **can have a fractional part** (but don't necessarily need one). Used for **measuring** things. All integers are also real numbers.

Examples: `0`, `-71.5`, `5.01`, `-80.8`, `15`

### Character
A **single symbol** used by a computer. Includes letters A-Z, numbers 0-9, and hundreds of symbols.

Examples: `R`, `{`, `7`, `Σ`, `ほ`

### String
A **collection of characters**. Can store single or multiple characters in succession. Useful for storing text and **phone numbers that start with 0** (which numeric types would truncate).

Examples: `Hello, world!`, `07789`

### Boolean
Named after mathematician **George Boole** (hence capital B). Values restricted to **True** and **False**. Useful for data with only two possible values (e.g., power button state, code execution status).

---

## Representing Positive Integers in Binary

Computers use **base 2** (binary), where each position represents a value **two times** the previous place.

**Key terminology:**
- **Bit**: A single binary digit (0 or 1)
- **Byte**: Eight binary digits
- **Nybble**: Half a byte (four bits)
- **Least Significant Bit (LSB)**: Rightmost bit (lowest place value)
- **Most Significant Bit (MSB)**: Leftmost bit (highest place value)

### Binary to Decimal Conversion

Multiply each digit by its place value and sum the results.

**Example:** Convert `1101` to decimal

| 8 (2³) | 4 (2²) | 2 (2¹) | 1 (2⁰) |
|--------|--------|--------|--------|
| 1      | 1      | 0      | 1      |

Calculation: (8×1) + (4×1) + (2×0) + (1×1) = **13**

### Decimal to Binary Conversion

1. Find the **largest power of two smaller than** the number
2. Write out place values up to this power
3. Working from MSB to LSB:
   - Write `1` if place value ≤ remaining value, then subtract place value
   - Write `0` otherwise

**Example:** Convert 47 to binary

| 32 | 16 | 8 | 4 | 2 | 1 |
|----|----|---|---|---|---|
| 1  | 0  | 1 | 1 | 1 | 1 |

- 32 ≤ 47 → write 1, remainder = 15
- 16 > 15 → write 0
- 8 ≤ 15 → write 1, remainder = 7
- 4 ≤ 7 → write 1, remainder = 3
- 2 ≤ 3 → write 1, remainder = 1
- 1 ≤ 1 → write 1

Result: **101111** (or **00101111** as a full byte with leading zeros)

---

## Binary Addition

**Four rules:**
1. 0 + 0 + 0 = 0
2. 0 + 0 + 1 = 1
3. 0 + 1 + 1 = 10 (write 0, carry 1)
4. 1 + 1 + 1 = 11 (write 1, carry 1)

**Method:**
1. Align numbers vertically by place value
2. Add columns from LSB to MSB
3. **Carry** digits to the next column when result exceeds 1

**Example:** 1011 + 1110

```
    1 0 1 1
  + 1 1 1 0
  ---------
  1 1 0 0 1
```

Verification: 11 + 14 = 25; and 11001 = 16+8+1 = 25 ✓

---

## Negative Numbers in Binary

### Sign Magnitude

The **most basic method** - equivalent to adding a + or - sign.

- **Leading 0** = positive number
- **Leading 1** = negative number

**Example:** 173 in binary is `10101101`
- Sign magnitude +173: `010101101`
- Sign magnitude -173: `110101101`

**Converting from sign magnitude:** Note the MSB (sign), remove it, convert remaining bits to decimal, apply the sign.

### Two's Complement

**Preferred method** because it makes arithmetic with negative numbers **much simpler**.

The MSB represents a **negative value**. In an 8-bit system:
- MSB represents **-128** instead of +128

**Converting to two's complement:**
1. Write the positive binary number
2. **Flip all bits** (0→1, 1→0)
3. **Add 1**

**Example:** Convert 7 to -7 in two's complement (8-bit)
- +7 = `00000111`
- Flip bits = `11111000`
- Add 1 = `11111001`

**Verification:** -128 + 64 + 32 + 16 + 8 + 1 = **-7** ✓

**Recognising sign in two's complement:**
- MSB = 0 → positive number
- MSB = 1 → negative number

---

## Binary Subtraction Using Two's Complement

Subtraction is performed by **adding a negative number**.

**Method:**
1. Convert the subtrahend (number being subtracted) to **two's complement**
2. Add the two numbers using standard binary addition
3. Read the result (in two's complement)

**Example:** 8 - 12 (using 5-bit two's complement)

- 8 = `01000`
- 12 = `01100` → -12 = `10100` (flip and add 1)

```
    0 1 0 0 0
  + 1 0 1 0 0
  -----------
    1 1 1 0 0
```

Result: `11100` = -16 + 8 + 4 = **-4** ✓

---

## Hexadecimal

**Base 16** number system using digits 0-9 and letters A-F.

| Decimal | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---------|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|
| Hex     | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A  | B  | C  | D  | E  | F  |

**Place values:** Powers of 16 (1, 16, 256, 4096, ...)

### Hexadecimal to Decimal

Multiply each digit by its place value and sum.

**Example:** 4E7F

| 4096 (16³) | 256 (16²) | 16 (16¹) | 1 (16⁰) |
|------------|-----------|----------|---------|
| 4          | E (14)    | 7        | F (15)  |

(4×4096) + (14×256) + (7×16) + (15×1) = **20095**

### Hexadecimal to Binary

Convert each hex digit to a **4-bit binary nybble**, then combine.

**Example:** B2
- B = 11 = `1011`
- 2 = 2 = `0010`
- Combined: **10110010**

### Binary to Hexadecimal

Split binary into 4-bit groups (from right), convert each to hex.

### Decimal to Hexadecimal

Convert decimal to binary, then binary to hexadecimal (or use repeated division by 16).

---

## Floating Point Numbers in Binary

Similar to **scientific notation** (e.g., 6.67 × 10⁻¹¹).

**Components:**
- **Mantissa**: The significant digits (precision)
- **Exponent**: The power/scale factor

Both are stored in **two's complement**.

### Structure
The **binary point** is assumed to be **after the first bit** of the mantissa.

**Sign determination:**
- Mantissa MSB = 0 → positive number
- Mantissa MSB = 1 → negative number

### Converting Floating Point to Decimal

1. Identify mantissa and exponent portions
2. Convert exponent to decimal (two's complement)
3. Shift the binary point by the exponent value:
   - Positive exponent → shift **right**
   - Negative exponent → shift **left**
4. Convert the resulting fixed-point binary to decimal

**Example:** 11-bit mantissa `01100100111`, 6-bit exponent `000110`

- Mantissa with binary point: `0.1100100111`
- Exponent: 4 + 2 = **6**
- Shift right 6 places: `0110010.0111`
- Convert: 32 + 16 + 2 + 0.25 + 0.125 + 0.0625 = **50.4375**

**Example with negative exponent:** 10-bit mantissa `0101101000`, 6-bit exponent `111101`

- Mantissa: `0.101101000`
- Exponent (two's complement): -32 + 16 + 8 + 4 + 1 = **-3**
- Shift left 3 places: `0.000101101`
- Convert: 1/16 + 1/64 + 1/128 + 1/512 = **45/512**

---

## Normalisation

Ensures floating point numbers are **as precise as possible** within the available bits by maximising use of the mantissa.

**Normalised form requirements:**
- **Positive numbers** start with `01`
- **Negative numbers** start with `10`

**Method:**
1. Shift mantissa bits to achieve `01` or `10` at the start
2. Adjust exponent to compensate:
   - Left shift (making mantissa larger) → **decrease** exponent
   - Right shift (making mantissa smaller) → **increase** exponent

**Example:** Normalise `000110100101` (8-bit mantissa, 4-bit exponent)

- Original mantissa: `00011010` (needs normalising - starts `00`)
- Original exponent: `0101` = 5
- Shift mantissa left 2 places: `01101000`
- New exponent: 5 - 2 = 3 = `0011`
- Result: `011010000011`

---

## Floating Point Arithmetic

### Addition

1. **Equalise exponents** - shift mantissa of smaller exponent number right, increasing its exponent to match
2. **Add mantissas** using standard binary addition
3. **Normalise** the result if necessary

**Example:** Add `000100 0011` and `000101 0010` (6-bit mantissa, 4-bit exponent)

- Exponents differ (3 vs 2)
- Shift first number: `001000 0010` (shifted right 1, exponent reduced by 1)
- Add mantissas: `001000 + 000101 = 001101`
- Result: `001101 0010`
- Normalise: shift left 1, decrease exponent → `011010 0001`

### Subtraction

1. **Equalise exponents**
2. **Convert** the subtrahend's mantissa to **two's complement**
3. **Add** the two mantissas
4. **Normalise** the result

---

## Bitwise Manipulation and Masks

### Logical Shifts

Moving all bits a specified number of places left or right.

**Logical Shift Left:**
- Add **trailing zeros**
- Equivalent to **multiplying** by 2ⁿ (where n = shift amount)
- Shift left by 1 = **doubling**

**Logical Shift Right:**
- Add **leading zeros**
- Equivalent to **integer division** by 2ⁿ

**Example:** `10010110` shifted left by 3 = `10010110000`
Effect: multiply by 2³ = 8

### Masks (Bitwise Operations)

Combining binary numbers using logic gates.

**AND Mask:**
- Output is 1 **only if both** inputs are 1
- Used to **extract** or **clear** specific bits

```
    00101011
AND 10111011
-----------
    00101011
```

**OR Mask:**
- Output is 1 if **either or both** inputs are 1
- Used to **set** specific bits to 1

```
    00101011
OR  10111011
-----------
    10111011
```

**XOR Mask:**
- Output is 1 if inputs are **different**
- Used to **toggle** (flip) specific bits

```
    00101011
XOR 10111011
-----------
    10010000
```

---

## Character Sets

A **published collection of codes** mapping to corresponding characters for representing text.

### ASCII (American Standard Code for Information Interchange)

- Uses **7 bits** per character
- Represents **2⁷ = 128** different characters
- **A-Z** = codes 65-90
- **a-z** = codes 97-122
- Includes numbers and common symbols

**Limitation:** Insufficient for representing non-Latin alphabets and international characters.

### Unicode

- Uses a **varying number of bits** (typically 8-32 bits per character)
- Supports **over 1 million** different characters
- **Backward compatible** with ASCII (first 128 characters match)
- Supports multiple languages, symbols, and emoji
- Solves ASCII's internationalisation limitations

---

## Summary Table: Number Systems

| System | Base | Digits Used | Example |
|--------|------|-------------|---------|
| Binary | 2 | 0, 1 | 1010 |
| Decimal (Denary) | 10 | 0-9 | 10 |
| Hexadecimal | 16 | 0-9, A-F | A |

## Key Exam Tips

1. **Always check conversions** by converting back to the original format
2. **Show working** for all binary arithmetic questions
3. For **two's complement**, remember: flip all bits AND add 1
4. **Normalised** floating point numbers must start with `01` (positive) or `10` (negative)
5. When equalising exponents, always shift the **smaller** number's mantissa
6. **Hexadecimal to binary**: each hex digit = exactly 4 binary bits
