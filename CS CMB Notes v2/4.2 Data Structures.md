# 4.2 Data Structures

## Specification Coverage
- **1.4.2 a)** Arrays, Records, Lists, Tuples
- **1.4.2 b)** Linked List, Graphs, Stack, Queue, Tree, Binary Search Tree, Hash Table
- **1.4.2 c)** Traversing data structures, Adding and removing data from data structures

---

## Arrays, Records, Lists, and Tuples

### Arrays

An **array** is an **ordered**, **finite set of elements** of a **single type**.

**Key Characteristics:**
- A **1D (one-dimensional) array** is a **linear array**
- Arrays are **zero-indexed** by default (first element at position 0)
- **Static data structure** with fixed size at declaration

**One-Dimensional Array:**
```
oneDimensionalArray = [1, 23, 12, 14, 16, 29, 12]
print(oneDimensionalArray[3])
>> 14
```

**Two-Dimensional Array:**
- Visualised as a **table** or **spreadsheet**
- Access order: **row first, then column** (down then across)
- This is the reverse of coordinate notation (x, y)

```
twoDimensionalArray = [[23, 28, 90, 38, 88, 23, 47],
                       [1, 23, 12, 14, 16, 29, 12]]
print(twoDimensionalArray[1,3])  // Row 1, Column 3
>> 14
```

**Three-Dimensional Array:**
- Visualised as a **multi-page spreadsheet** (multiple 2D arrays)
- Syntax: `threeDimensionalArray[z,y,x]`
  - **z** = array number (page)
  - **y** = row number
  - **x** = column number

```
threeDimensionalArray = [[[12,8],[9,6,19]],[[241,89,4,1],[19,2]]]
print(threeDimensionalArray[0,1,2])  // Array 0, Row 1, Column 2
>> 19
```

---

### Records

A **record** is a **row in a file** made up of **fields**. Records are used in **databases**.

| ID  | FirstName | Surname |
|-----|-----------|---------|
| 001 | Antony    | Joshua  |
| 002 | Tyson     | Fury    |
| 003 | Deonte    | Wilder  |

The table above contains **three records**, each with **three fields**.

**Declaring a Record:**
```
fighterDataType = record
    integer  ID
    string   FirstName
    string   Surname
end record
```

**Creating and Accessing a Record:**
```
fighter : fighterDataType          // Declare variable of record type
fighter.FirstName                  // Access field using recordName.fieldName
```

---

### Lists

A **list** is a data structure consisting of **ordered items** where items can **occur more than once**.

**Key Differences from Arrays:**
- Values stored **non-contiguously** (not next to each other in memory)
- Can contain elements of **more than one data type**
- **Dynamic** size (can grow and shrink)

**List Operations:**

| Operation | Example | Description |
|-----------|---------|-------------|
| `isEmpty()` | `List.isEmpty()` → False | Checks if the list is empty |
| `append(value)` | `List.append(15)` | Adds value to the **end** of the list |
| `remove(value)` | `List.remove(23)` | Removes **first occurrence** of value |
| `search(value)` | `List.search(38)` → False | Searches for value, returns Boolean |
| `length()` | `List.length()` → 7 | Returns the length of the list |
| `index(value)` | `List.index(23)` → 0 | Returns the **position** of the item |
| `insert(position, value)` | `List.insert(4, 25)` | Inserts value at given position |
| `pop()` | `List.pop()` → 12 | Returns and **removes last** value |
| `pop(position)` | `List.pop(3)` | Returns and removes value at position |

---

### Tuples

A **tuple** is an **ordered set of values** of **any type** that is **immutable** (cannot be changed after creation).

**Key Characteristics:**
- Elements **cannot be added or removed** once created
- Initialised using **regular brackets** `()` instead of square brackets `[]`
- Elements accessed like arrays but **cannot be modified**

```
tupleExample = ("Value1", 2, "Value3")
print(tupleExample[0])
>> Value1

tupleExample[0] = "ChangedValue"
>> Syntax Error    // Cannot modify tuple elements
```

---

## Linked Lists, Graphs, Stacks, Queues, and Trees

### Linked Lists

A **linked list** is a **dynamic data structure** used to hold an **ordered sequence** where items do not need to be stored in **contiguous** memory locations.

**Structure:**
- Each item is called a **node**
- Each node contains:
  - **Data field**: the actual value
  - **Pointer field** (link): address of the next item

| Index | Data | Pointer |
|-------|------|---------|
| 0 | 'Linked' | 2 |
| 1 | 'Example' | 0 |
| 2 | 'List' | - |
| 3 | | |

**Start = 1, NextFree = 3**

**Key Pointers:**
- **Start pointer**: index of the first item in the list
- **NextFree pointer**: index of the next available space

**Traversal:**
- Begin at the **Start** pointer
- Output values, following pointers until a **null/empty** pointer is found
- Output: 'Example', 'Linked', 'List'

**Adding a Node** (e.g., add 'OCR' after 'Example'):
1. Add new value at NextFree position, update NextFree pointer
2. Update the pointer of the preceding node to point to the new node
3. Set the new node's pointer to the next item in sequence

**Removing a Node** (e.g., remove 'Linked'):
1. Update the pointer of the preceding node to bypass the removed node
2. The node is **not physically deleted**, just **bypassed** (ignored)

**Advantages:**
- Easy to add/remove values by editing pointers
- Dynamic size

**Disadvantages:**
- **Wastes memory** (deleted nodes remain)
- **More memory required** for storing pointers
- **No random access** - must traverse sequentially from start

> **Random Access**: The ability to access a specific element directly given its index. This is possible in arrays but **not in linked lists**.

---

### Graphs

A **graph** is a set of **vertices/nodes** connected by **edges/arcs**.

**Types of Graphs:**
- **Directed Graph**: edges can only be traversed in **one direction**
- **Undirected Graph**: edges can be traversed in **both directions**
- **Weighted Graph**: a **cost/weight** is attached to each edge

**Graph Representations:**

**Adjacency Matrix:**

|   | A  | B  | C  | D  | E  |
|---|----|----|----|----|----| 
| A | -  | 4  | 18 | 12 | -  |
| B | 4  | -  | 5  | -  | 8  |
| C | 18 | 5  | -  | 5  | -  |
| D | 12 | -  | -  | -  | 3  |
| E | -  | 8  | -  | 3  | -  |

**Adjacency List:**
```
A → {B:4, C:18, D:12}
B → {A:4, C:5, E:8}
C → {A:18, B:5, D:5}
D → {A:12, E:3}
E → {B:8, D:3}
```

**Comparison:**

| Adjacency Matrix | Adjacency List |
|------------------|----------------|
| Convenient with **quicker access times** | More **space efficient** for large, sparse networks |
| **Easy to add nodes** | Less memory for sparse graphs |
| Better for **dense graphs** | Better for **sparse graphs** |

---

### Stacks

A **stack** is a **Last In First Out (LIFO)** data structure. Items can only be added to or removed from the **top** of the stack.

**Uses:**
- **Undo** functionality in applications
- **Back button** in web browsers
- Reversing actions
- Function call stack in programming

**Implementation:**
- Can be **static** (fixed size, easier, more memory efficient) or **dynamic**
- Uses a **top pointer** indicating where the next item will be inserted

**Stack Operations:**

| Operation | Example | Description |
|-----------|---------|-------------|
| `isEmpty()` | `Stack.isEmpty()` → True | Checks if stack is empty (checks top pointer) |
| `push(value)` | `Stack.push("Nadia")` | Adds value to top; must check stack **not full** first |
| `peek()` | `Stack.peek()` → "Elijah" | Returns top value **without removing**; checks not empty |
| `pop()` | `Stack.pop()` → "Elijah" | **Removes and returns** top value; checks not empty |
| `size()` | `Stack.size()` → 2 | Returns the size of the stack |
| `isFull()` | `Stack.isFull()` → False | Checks if full (compares size to top pointer) |

---

### Queues

A **queue** is a **First In First Out (FIFO)** data structure. Items are added to the **end** (rear) and removed from the **front**.

**Uses:**
- Print queues
- Keyboard buffers
- Simulators
- Process scheduling

**Types of Queues:**

**Linear Queue:**
- Uses an array with **front** and **rear** pointers
- Items added at rear, removed from front
- **Problem**: spaces at the front cannot be reused after dequeue operations

**Circular Queue:**
- FIFO structure like linear queue
- Rear pointer **wraps around** to the front when reaching maximum size
- **More efficient use of space** than linear queues
- **Harder to implement**

**Circular Queue Wraparound:**
```
// When rearPointer reaches maxSize, it wraps to 0
rearPointer = (rearPointer + 1) MOD maxSize
```

**Queue Operations:**

| Operation | Example | Description |
|-----------|---------|-------------|
| `enQueue(value)` | `Queue.enQueue("Nadia")` | Adds item to **rear**; increments rear pointer |
| `deQueue()` | `Queue.deQueue()` | Removes item from **front**; increments front pointer |
| `isEmpty()` | `Queue.isEmpty()` → False | Compares front and rear pointers |
| `isFull()` | `Queue.isFull()` → False | Compares rear pointer to queue size |

---

### Trees

A **tree** is a **connected form of graph** with a hierarchical structure.

**Terminology:**

| Term | Definition |
|------|------------|
| **Node** | An item in the tree |
| **Edge** | Connects two nodes (also called **branch** or **arc**) |
| **Root** | Single node with **no incoming edges** (top node) |
| **Child** | A node with **incoming edges** |
| **Parent** | A node with **outgoing edges** |
| **Subtree** | Subsection containing a parent and **all its children** |
| **Leaf** | A node with **no children** |

### Binary Search Tree

A **binary tree** is a tree where each node has a **maximum of two children**.

**Key Properties:**
- Used for **binary searches** - easy to search through
- Left child contains values **less than** parent
- Right child contains values **greater than** parent

**Representation:**
- Each node stores: **left pointer**, **data value**, **right pointer**
- Usually implemented using **2D arrays**

| Index | Left Pointer | Data | Right Pointer |
|-------|--------------|------|---------------|
| 0 | 1 | G | 3 |
| 1 | 2 | C | 4 |
| 2 | - | A | - |
| 3 | - | J | 5 |
| 4 | - | F | - |
| 5 | - | L | - |

### Traversing a Binary Tree

Three methods using the **outline method** (tracing around the tree):

**Pre-order Traversal:**
- Order: **Root → Left subtree → Right subtree**
- Outline method: nodes visited when passing on the **left**
- Use: **Prefix notation** (operator before operands: `+ a b`)
- Example output: 15, 9, 5, 7, 11, 10, 12, 20, 25, 34

**In-order Traversal:**
- Order: **Left subtree → Root → Right subtree**
- Outline method: nodes visited when passing **underneath**
- Use: Outputs values in **sequential/sorted order**
- Example output: 5, 7, 9, 10, 11, 12, 15, 20, 25, 34

**Post-order Traversal:**
- Order: **Left subtree → Right subtree → Root**
- Outline method: nodes visited when passing on the **right**
- Use: **Postfix notation** (operator after operands: `a b +`)
- Example output: 7, 5, 10, 12, 11, 9, 34, 25, 20, 15

---

### Hash Tables

A **hash table** is an **array** coupled with a **hash function**.

**How It Works:**
1. **Hash function** takes a **key** (input data)
2. Produces a **hash** (output)
3. Hash **maps to an index** in the hash table
4. Data is stored at that index

**Key Concepts:**

**Collision:** When two different keys produce the **same hash value**.

**Good Hashing Algorithm:**
- **Low probability** of collisions
- Distributes data evenly across the table

**Collision Resolution:**
- When a collision occurs, the item is typically placed in the **next available location** (linear probing)
- Other methods: chaining, quadratic probing, double hashing

**Uses:**
- **Indexing** - provides **fast access** to data
- Keys have a **unique, one-to-one relationship** with storage addresses
- O(1) average time complexity for lookup

> **Synoptic Link:** Hashing is also used to **securely store data** such as passwords and PINs (covered in 1.3.1 Different Uses of Hashing).

---

## Summary Comparison Table

| Data Structure | Type | Access | Key Feature |
|----------------|------|--------|-------------|
| Array | Static | Random (O(1)) | Single data type, contiguous memory |
| List | Dynamic | Sequential | Multiple data types, non-contiguous |
| Tuple | Static | Random | Immutable |
| Linked List | Dynamic | Sequential | Nodes with pointers |
| Stack | Static/Dynamic | Top only | LIFO |
| Queue | Static/Dynamic | Front/Rear | FIFO |
| Binary Tree | Dynamic | Traversal | Max 2 children per node |
| Hash Table | Static | Direct (O(1)) | Key-value mapping via hash function |
| Graph | Dynamic | Traversal | Nodes connected by edges |

---

## Exam Tips

1. **Array indexing**: Remember 2D arrays go **row then column** (opposite to coordinates)
2. **Linked lists**: Adding/removing only changes pointers, not physical positions
3. **Stack vs Queue**: LIFO vs FIFO - remember common use cases
4. **Tree traversal**: Use the outline method - Pre (left), In (under), Post (right)
5. **Hash tables**: Understand collision resolution and why hash tables provide O(1) access
6. **Adjacency representations**: Matrix better for dense graphs, list better for sparse graphs
