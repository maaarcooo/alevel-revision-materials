# 4.3 Boolean Algebra

## Specification Reference
- **1.4.3 a)** Define problems using Boolean logic
- **1.4.3 b)** Manipulate Boolean expressions; Karnaugh maps to simplify Boolean expressions
- **1.4.3 c)** Use rules to derive or simplify statements: De Morgan's Laws, Distribution, Association, Commutation, Double negation
- **1.4.3 d)** Using logic gate diagrams and truth tables
- **1.4.3 e)** The logic associated with D type flip flops, half and full adders

---

## Boolean Logic

### What is Boolean Logic?
**Boolean logic** is used in computer science and electronics to make **logical decisions**. Boolean operators evaluate to either **TRUE (1)** or **FALSE (0)**, but never both. Inputs and outputs are represented using letters (A, B, C, etc.).

**Boolean algebra** is a mathematical system used to **manipulate Boolean values** and simplify complex expressions using defined rules.

### Order of Operations
When evaluating Boolean expressions with multiple operators:
1. **Brackets** (evaluated first)
2. **NOT** (highest precedence)
3. **AND** (next highest)
4. **OR** (lowest precedence)

---

## Logic Gates and Truth Tables

### The Four Core Logic Gates

| Operation | Name | Symbol | Alternative | Circuit Symbol |
|-----------|------|--------|-------------|----------------|
| Conjunction | AND | A ∧ B | A . B | Flat-backed D shape |
| Disjunction | OR | A ∨ B | A + B | Curved-backed D shape |
| Negation | NOT | ¬A | Ā | Triangle with circle |
| Exclusive Disjunction | XOR | A ⊕ B | A ⊻ B | OR gate with extra curved line |

### Truth Tables

**AND (Conjunction)** - Returns TRUE only if **both inputs** are TRUE

| A | B | A ∧ B |
|---|---|-------|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

**OR (Disjunction)** - Returns TRUE if **either input** is TRUE

| A | B | A ∨ B |
|---|---|-------|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

**NOT (Negation)** - **Inverts** the input value

| A | ¬A |
|---|-----|
| 0 | 1 |
| 1 | 0 |

**XOR (Exclusive Disjunction)** - Returns TRUE if inputs are **different**

| A | B | A ⊕ B |
|---|---|-------|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

### Combining Boolean Operations
Boolean equations combine operators to describe combinations of variables. Build truth tables by evaluating each part step by step.

**Example:** For ¬(A ∧ (B ∨ C))

| A | B | C | B ∨ C | A ∧ (B ∨ C) | ¬(A ∧ (B ∨ C)) |
|---|---|---|-------|-------------|----------------|
| 0 | 0 | 0 | 0 | 0 | 1 |
| 0 | 0 | 1 | 1 | 0 | 1 |
| 0 | 1 | 0 | 1 | 0 | 1 |
| 0 | 1 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 0 | 0 | 1 |
| 1 | 0 | 1 | 1 | 1 | 0 |
| 1 | 1 | 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 1 | 0 |

---

## Karnaugh Maps

### Purpose
A **Karnaugh map (K-map)** is a visual tool for **simplifying Boolean expressions**. It groups expressions with **common factors** to identify and **eliminate redundant terms**.

### Key Rules
- Columns and rows must use **Gray code** ordering (00, 01, 11, 10) where adjacent values differ by only **one bit**
- Groups must be **rectangular** and contain **powers of 2** cells (1, 2, 4, 8)
- Groups can **overlap** and **wrap around** edges
- Make groups **as large as possible**
- Use **as few groups as possible** to cover all 1s

### Creating a 2-Variable K-Map

For expression A ∨ B:

|   | A=0 | A=1 |
|---|-----|-----|
| B=0 | 0 | 1 |
| B=1 | 1 | 1 |

### Creating a 3-Variable K-Map

For a 3-variable expression, use the format:

|   | AB=00 | AB=01 | AB=11 | AB=10 |
|---|-------|-------|-------|-------|
| C=0 |   |   |   |   |
| C=1 |   |   |   |   |

### Creating a 4-Variable K-Map

|    | AB=00 | AB=01 | AB=11 | AB=10 |
|----|-------|-------|-------|-------|
| CD=00 |   |   |   |   |
| CD=01 |   |   |   |   |
| CD=11 |   |   |   |   |
| CD=10 |   |   |   |   |

### Simplification Process

1. **Create the map**: Fill cells with 1s and 0s based on the truth table
2. **Group the 1s**: Draw rectangles around groups of adjacent 1s (sizes must be powers of 2)
3. **Identify constant variables**: For each group, note which variables remain constant
4. **Write simplified terms**: Variables that are constant at 1 appear as-is; variables constant at 0 appear negated
5. **Combine with OR**: Join the simplified terms from each group using OR

**Example:** Simplifying ¬A∧¬B∧C ∨ ¬A∧B∧¬C ∨ A∧¬B∧C ∨ A∧B

|   | AB=00 | AB=01 | AB=11 | AB=10 |
|---|-------|-------|-------|-------|
| C=0 | 0 | 1 | 1 | 1 |
| C=1 | 1 | 0 | 1 | 1 |

Groups identified:
- Vertical group (AB=10): **A∧¬B** (A is always 1, B is always 0, C varies)
- Horizontal group covering corners and AB=11, C=0: Simplifies to **A ∨ ¬B**

---

## Simplifying Boolean Algebra

### General Rules

**AND Rules:**
- X ∧ 0 = 0
- X ∧ 1 = X
- X ∧ X = X
- ¬X ∧ X = 0

**OR Rules:**
- X ∨ 0 = X
- X ∨ 1 = 1
- X ∨ X = X
- ¬X ∨ X = 1

### De Morgan's Laws

Used when a **negation applies to an entire expression**. The key is to **break the negation**, **change the operator**, and **negate each term**.

**First Law:**
$$¬(A ∧ B) ≡ ¬A ∨ ¬B$$
NOT(A AND B) is the same as (NOT A) OR (NOT B)

**Second Law:**
$$¬(A ∨ B) ≡ ¬A ∧ ¬B$$
NOT(A OR B) is the same as (NOT A) AND (NOT B)

**Application:** De Morgan's Laws allow circuits to be built using only **NAND** or **NOR** gates, simplifying microprocessor design.

### Distribution

Similar to factorising in regular algebra.

**Conjunction over Disjunction:**
$$A ∧ (B ∨ C) ≡ (A ∧ B) ∨ (A ∧ C)$$

**Disjunction over Conjunction:**
$$A ∨ (B ∧ C) ≡ (A ∨ B) ∧ (A ∨ C)$$

**Same operator distribution:**
$$A ∧ (B ∧ C) ≡ (A ∧ B) ∧ (A ∧ C)$$
$$A ∨ (B ∨ C) ≡ (A ∨ B) ∨ (A ∨ C)$$

### Association

Allows **addition or removal of brackets** and **reordering** of literals.

$$(A ∧ B) ∧ C ≡ A ∧ (B ∧ C) ≡ A ∧ B ∧ C$$
$$(A ∨ B) ∨ C ≡ A ∨ (B ∨ C) ≡ A ∨ B ∨ C$$

### Commutation

The **order of variables** around an operator **does not matter**.

$$A ∨ B ≡ B ∨ A$$
$$A ∧ B ≡ B ∧ A$$

### Double Negation

Negating a literal **twice** returns the **original value**.

$$¬¬A ≡ A$$

### Absorption Law

$$A ∨ (A ∧ B) ≡ A$$
$$A ∧ (A ∨ B) ≡ A$$

---

## Logic Circuits

### D-Type Flip Flops

A **flip flop** is a logic circuit that can **store the value of one bit**. It is a **bistable circuit** with two stable states.

**Components:**
- **D (Data input)**: The value to be stored
- **CLK (Clock input)**: Regular pulse from the CPU used to coordinate components
- **Q (Output)**: The stored value
- **Q̄ (Inverted output)**: The complement of Q

**Operation:**
- The output Q can only change on a **rising edge** (when clock goes from 0 to 1)
- At each rising edge, Q updates to match the current value of D
- Q **holds its value** between clock pulses

**Clock Signal Terminology:**
- **Rising edge**: Transition from low (0) to high (1)
- **Falling edge**: Transition from high (1) to low (0)

**Applications:**
- Basic unit of **memory**
- Combined to form **registers**
- Used in **shift registers**, **counters**, and **memory units**
- Edge-triggered devices and **synchronous circuits**

**Note:** D-type flip flops are often built using **NAND gates**.

---

### Half Adder

A **half adder** is a logic circuit that adds together **two single-bit numbers**.

**Inputs:** A, B

**Outputs:**
- **Sum (S)**: The result of A XOR B
- **Carry (C)**: The result of A AND B

**Truth Table:**

| A | B | Carry (C) | Sum (S) |
|---|---|-----------|---------|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 0 |

**Logic Gates Required:**
- 1 × **XOR gate** (for Sum)
- 1 × **AND gate** (for Carry)

**Boolean Expressions:**
- Sum = A ⊕ B
- Carry = A ∧ B

---

### Full Adder

A **full adder** extends the half adder to handle **three bits**, including a **carry in** from a previous addition.

**Inputs:** A, B, C_in (Carry in)

**Outputs:**
- **Sum (S)**: The result bit
- **C_out (Carry out)**: The carry to the next position

**Truth Table:**

| A | B | C_in | C_out | Sum |
|---|---|------|-------|-----|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 |
| 0 | 1 | 0 | 0 | 1 |
| 0 | 1 | 1 | 1 | 0 |
| 1 | 0 | 0 | 0 | 1 |
| 1 | 0 | 1 | 1 | 0 |
| 1 | 1 | 0 | 1 | 0 |
| 1 | 1 | 1 | 1 | 1 |

**Logic Gates Required:**
- 2 × **XOR gates**
- 2 × **AND gates**
- 1 × **OR gate**

**Structure:** A full adder is constructed from **two half adders** and an **OR gate**.

**Boolean Expressions:**
- Sum = A ⊕ B ⊕ C_in
- C_out = (A ∧ B) ∨ (C_in ∧ (A ⊕ B))

### Ripple Adder

Full adders can be **chained together** to form a **ripple adder** for adding multi-bit binary numbers. The **carry out** of one adder connects to the **carry in** of the next.

For adding two **n-bit** numbers, **n full adders** are required.

---

## Exam Tips

1. **Truth tables**: Always show intermediate columns when building complex truth tables
2. **Karnaugh maps**: Draw groups clearly and ensure they follow Gray code ordering
3. **Simplification**: Show each step when applying Boolean algebra rules
4. **D-type flip flops**: Remember that Q only changes on the **rising edge** of the clock
5. **Adders**: For truth tables, simply add the binary inputs and write the result in 2-bit form (Carry, Sum)
6. **De Morgan's Laws**: Remember to change AND↔OR and negate both terms when breaking a negation

---

## Summary of Boolean Algebra Laws

| Law | Expression |
|-----|------------|
| **De Morgan's (1)** | ¬(A ∧ B) ≡ ¬A ∨ ¬B |
| **De Morgan's (2)** | ¬(A ∨ B) ≡ ¬A ∧ ¬B |
| **Distribution** | A ∧ (B ∨ C) ≡ (A ∧ B) ∨ (A ∧ C) |
| **Distribution** | A ∨ (B ∧ C) ≡ (A ∨ B) ∧ (A ∨ C) |
| **Association** | (A ∧ B) ∧ C ≡ A ∧ B ∧ C |
| **Commutation** | A ∧ B ≡ B ∧ A |
| **Double Negation** | ¬¬A ≡ A |
| **Absorption** | A ∨ (A ∧ B) ≡ A |
| **Identity** | A ∧ 1 = A, A ∨ 0 = A |
| **Annulment** | A ∧ 0 = 0, A ∨ 1 = 1 |
| **Complement** | A ∧ ¬A = 0, A ∨ ¬A = 1 |
| **Idempotent** | A ∧ A = A, A ∨ A = A |
