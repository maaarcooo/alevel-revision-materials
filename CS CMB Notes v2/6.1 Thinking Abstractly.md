# 6.1 Thinking Abstractly

## Specification Reference
- 2.1.1 a) The nature of abstraction
- 2.1.1 b) The need for abstraction
- 2.1.1 c) The difference between abstraction and reality
- 2.1.1 d) Devise an abstract model for a variety of situations

---

## The Nature of Abstraction

**Abstraction** is one of the most important principles in Computer Science and is a critical part of computational thinking. It is the process of **removing unnecessary details** of a problem to focus on the **important features** to implement in a solution.

### Types of Abstraction

**Representational Abstraction**
- Involves analysing what is **relevant** to a given scenario
- Simplifying a problem based on this information
- Focuses on retaining only the **key features** needed to represent the problem

**Abstraction by Generalisation**
- Involves **grouping together similarities** within a problem
- Identifies **what kind of problem** it is
- Allows problems to be **categorised as being of a particular type**
- Enables a **common solution** to be applied to similar problems

**Data Abstraction**
- Details about **how data is being stored are hidden**
- Programmers can use **abstract data structures** (e.g., stacks, queues) without concerning themselves with implementation details
- Programmers do not need to worry how primitive data types (integers, strings, booleans) are stored and represented

**Procedural Abstraction**
- Models **what a subroutine does** without considering **how** it is done
- Used in decomposition
- Once a procedure has been coded, it can be reused as a **black-box**
- Programmers can perform functions (e.g., pushing/popping items to/from a stack) without knowledge of the underlying code

### Levels of Abstraction

Complex problems use **multiple levels of abstraction**, where each level performs a different role:

| Level | Role | Example |
|-------|------|---------|
| **Highest** | Closest to the user; provides an **interface** for the user to interact with hardware | GUI, high-level programming languages |
| **Lowest** | Responsible for actually performing tasks through **execution of machine code** | Binary instructions executed by the processor |

---

## The Need for Abstraction

Abstraction allows **non-experts to make use of a range of systems or models** by hiding information that is too complex or irrelevant to the system's purpose.

### Benefits in Software Development

- Enables **more efficient design** as programmers can focus on essential elements
- **Reduces development time** by removing unnecessary complexity
- **Prevents programs from getting unnecessarily large** by removing wasteful details early
- Allows developers to focus on **solving the problem** rather than worrying about technical details

### Programming Language Abstraction

Programming languages exist on a spectrum demonstrating layers of abstraction:

| Generation | Language Type | Characteristics |
|------------|---------------|-----------------|
| **1st Generation** | Machine code (binary) | Uses 0s and 1s; time-consuming, tedious, error-prone |
| **2nd Generation** | Assembly language | Uses **mnemonics** to represent binary instructions; processor-specific instruction sets |
| **3rd Generation** | High-level languages (Python, Java, C) | Syntax **parallels natural language**; easier to learn and use; accessible to non-specialists |

**Key points about high-level languages:**
- Provide an abstraction for the machine code actually executed
- Abstract long, complicated instruction sequences into shorter instructions
- Allow developers to **ignore how data is stored in memory**
- Developers don't need to know specifics of how instructions are carried out in the processor

**Analogy:** A car driver doesn't need to know how the engine works to drive; similarly, a programmer doesn't need to know all underlying technical complexity to create programs.

### Network Abstraction: The TCP/IP Model

The **TCP/IP model** is an abstraction for how networks function, separated into **four layers**:

| Layer | Function |
|-------|----------|
| **Application** | User-facing protocols and services |
| **Transport** | Manages data transmission reliability |
| **Internet** | Handles logical addressing and routing |
| **Link** | Manages physical transmission |

**Key characteristics:**
- Each layer deals with a **different part of the communication process**
- Separating stages makes them **simpler to understand**
- Each layer **does not need to know how other layers work**
- **Standards/protocols** must be agreed in advance to ensure compatibility
- Each layer can be dealt with **individually**, with details about other layers hidden

---

## The Difference Between Abstraction and Reality

**Abstraction is a simplified representation of reality.** The real world is very complex with many variables that factor into problems.

### Computational Representations of Reality

| Real-World Element | Computational Representation |
|--------------------|------------------------------|
| Entities | Tables, databases, objects |
| Values | Variables |
| Characteristics | Attributes |
| Actions | Methods |
| Locations/Junctions | Graph nodes |
| Connections/Roads | Edges or arcs |

### Object-Oriented Programming and Abstraction

In OOP, abstraction considers:
- **Functionality** - what the entity can do
- **Interface** - how the entity interacts with other components
- **Properties** - the characteristics of the entity

**Attributes** are an abstraction for the **characteristics** of an object.
**Methods** are an abstraction for the **actions** a real-world object can perform.

### Examples of Abstraction

**London Underground Map**
- Travellers don't need geographical layout of routes
- Only need to know that stop A will transport them to stop B
- Removes unnecessary detail while retaining essential information

**Navigation/Route Finding**
- Reality: Roads weave and turn with different rules (speed limits, one-way systems)
- Abstraction: Remove greenspace and buildings, leaving only roads and junctions
- Further abstraction: Represent junctions as **graph nodes**, roads as **edges/arcs**
- One-way streets represented by **directed edges**
- Distances represented by **edge weights**
- Graph algorithms (Dijkstra's, A*) can then be applied

**Video Game Physics (e.g., Pong)**
- Highly abstracted game of tennis/badminton
- Momentum of ball is constant
- No extraneous factors (friction, gravity)
- The closer implementation is to reality, the **less abstract** the solution becomes

**Simulators (Car/Flight)**
- Model real-life objects, environments, actions
- Include only relevant physics and controls
- May or may not include factors like gravity, air resistance, friction depending on purpose

---

## Devising an Abstract Model

When devising an abstract model for a given scenario, consider the following questions:

### Key Questions to Ask

**1. What is the problem that needs to be solved?**
- Can the problem be solved computationally?
- What are the **key features** of the problem?
- Can the problem be broken down into milestones?

**2. How will the model be used?**
- What format does the model need to be displayed in?
- Consider factors: convenience, affordability, ease of access

**3. Who will the model be used by?**
- How many people will use the model?
- What **level of expertise** do they have in the subject?

**4. Which parts are relevant?**
- Remove sections **not relevant** to the problem being solved
- Remove details that will **confuse the audience**
- If an element were removed, would it impact the solution in any way?

### Data Abstractions

Higher-level languages allow programmers to create **abstracted data types** to represent logical structures (e.g., modelling a queue at a fast-food restaurant).

**Underlying implementation hierarchy:**
```
Queue → Array → Variables → Bytes → Bits → Flip-flops
```

A programmer does not need to worry about:
- The underlying implementation of a queue
- How it's stored in memory

They only need to know they can **add to and remove data from** the structure.

**Key principle:** Abstraction is about separating **what a program does** from the **implementation** (how it does it).

---

## Summary

| Concept | Definition |
|---------|------------|
| **Abstraction** | Removing unnecessary details to focus on important features |
| **Representational Abstraction** | Simplifying a problem by analysing what is relevant |
| **Abstraction by Generalisation** | Grouping similarities to categorise problems and apply common solutions |
| **Data Abstraction** | Hiding how data is stored; using abstract data structures |
| **Procedural Abstraction** | Modelling what a subroutine does without showing how (black-box) |
| **Levels of Abstraction** | Multiple layers from user interface (highest) to machine code (lowest) |

---

## Exam Tips

- When asked to identify abstractions, look for what **unnecessary details have been removed**
- Explain **why** certain details are unnecessary for the specific purpose
- When devising abstract models, clearly state the **problem**, **audience**, and **relevant features**
- Link abstraction to practical benefits: reduced complexity, easier maintenance, accessibility to non-experts
- Remember that abstraction separates **what** something does from **how** it does it
