# 6.2 Thinking Ahead

## Overview

**Thinking ahead** is a computational thinking skill that involves considering the different components of a problem and how they will be handled before implementation. This allows developers to anticipate problems or difficulties that may arise when software is used, enabling the design of strategies to make programs easy and intuitive to use.

---

## Inputs and Outputs

### Definitions

**Inputs** are any data required to solve a problem, entered into the system by the user. When identifying inputs, developers must consider:
- The **data type** of inputs
- The **order** in which data is input
- The **method of input** (input devices used)

**Outputs** are the results passed back once inputs have been processed and the problem has been solved. Designers must decide on:
- A suitable **data type**
- Appropriate **data structure**
- The **method** used to present the solution

> **Note:** Outputs do not necessarily have to be displayed on a screen or monitor. Output data includes information in visual or audio format, which may require an output device such as a printer or speaker.

### Design Process

When designing an algorithm, inputs and outputs must be **explicitly defined**, including their type, size, and format. Failure to define these explicitly makes algorithm creation more difficult and can cause errors when unexpected events occur.

Typically, designers:
1. Begin by considering what **outputs are required** based on user requirements
2. Identify the **inputs required**
3. Determine how inputs need to be **processed** to achieve the outputs

### Example: ATM System

| Inputs | Outputs |
|--------|---------|
| Transaction type (Deposit/Balance check/Withdrawal) | If deposit: Display total amount entered on screen |
| Card details (captured via card reader) | If balance check: Display account balance on screen |
| PIN (entered via keypad) | If withdrawal: Dispense correct amount of cash |
| | Print receipt to confirm transaction |
| | Speaker provides verbal feedback |

**Input devices:** Touch screen, magnetic stripe card reader, keypad

**Output devices:** Monitor, cash dispenser, printer, speakers

### Formal Definition Format

To formally define inputs and outputs:
- **Name:** LinearSearch
- **Input:** A list of integers my_list = (i₁, i₂, i₃, ..., iₙ)
- **Output:** The index of the element as an integer

---

## Preconditions

### Definition

**Preconditions** are requirements which must be met before a program can be executed. If preconditions are not met, the program will fail to execute or return an invalid answer.

Specifying preconditions means that a subroutine can safely expect the arguments passed to it to meet certain criteria.

### Where Preconditions Are Specified

Preconditions can be:
1. **Tested within the code** - validation checks are programmed into the subroutine
2. **Included in documentation** - the user is responsible for ensuring inputs meet requirements

### Example: Stack Pop Function

```
function pop():
    if top = 0 then
        print "No items in the stack."
    else:
        element = stack[top]
        top = top - 1
    endif
endfunction
```

The precondition here is that the stack must not be empty (top > 0). This is tested within the code because popping from an empty stack would cause a program crash.

### Example: Factorial Function

The factorial function can only be called on non-negative numbers. Rather than checking this within the code, this precondition is specified in the documentation accompanying the function.

### Common Preconditions

- The parameter list must not be empty (to avoid index out of bounds errors)
- Data must be of the correct/same data type
- Target data must match the data type of the list
- For binary search: the list must be **ordered/sorted**
- For inefficient algorithms (e.g., bubble sort O(n²)): limits on input size may be required

### Formal Definition with Preconditions

- **Name:** BinarySearch
- **Inputs:** A list of integers my_list(i₁, i₂, i₃, i₄, ..., iₙ)
- **Outputs:** The index of the element as an integer
- **Preconditions:** length of my_list > 0, type(my_list) = int, list is sorted

### Advantages of Specifying Preconditions

| In Documentation | In Code |
|------------------|---------|
| Reduces length and complexity of program | Prevents program from crashing due to invalid inputs |
| Saves time needed to debug and maintain longer programs | User doesn't need to read documentation |
| Developer is aware of required checks before calling the subroutine | Validation is handled automatically |

Defining preconditions (including inputs and outputs) makes subroutines **more reusable**.

---

## Caching *(A Level Only)*

### Definition

**Caching** is the process of storing instructions or values in cache memory after they have been used, as they may be used again. This saves time that would otherwise be needed to retrieve the instructions from secondary storage.

**Cache** is the small, fast storage on a processor used to temporarily store frequently used data and instructions while a program is running.

### Applications

**Web Caching:**
- Frequently accessed web pages are cached
- Next time the page is accessed, content loads without delay
- Images and text do not need to be downloaded again
- This frees up bandwidth for other network tasks

**Processor Cache:**
- Caching is usually performed automatically by the operating system
- Some languages (e.g., C) allow manipulation of the underlying hardware

### Prefetching

**Prefetching** is a more advanced variation of caching where algorithms predict which instructions are likely to be fetched soon. The predicted instructions and data are loaded into cache **before** they are actually needed.

This reduces waiting time for instructions to be loaded into RAM from the hard disk.

### Benefits of Caching

- Faster access to frequently used data and instructions
- Reduces retrieval time from secondary storage
- Saves bandwidth (for web caching)
- Improves overall system performance

### Drawbacks of Caching

- **Accuracy limitations:** Prefetching algorithms can only provide informed predictions; there is no guarantee they will be correct
- **Cache management:** Effectiveness depends on how well the caching algorithm manages the cache
- **Search time:** Larger caches take longer to search
- **Size limitations:** Cache size limits how much data can be stored
- **Implementation difficulty:** Can be difficult to implement effectively

---

## Reusable Program Components

### Definition

**Reusable program components** are commonly used functions and subroutines that are packaged into **libraries** for reuse across multiple programs or projects.

### Types of Reusable Components

- Implementations of **abstract data structures** (queues, stacks, linked lists)
- **Classes** (in object-oriented programming)
- **Subroutines/functions**
- Standard algorithms (quick sort, merge sort, search algorithms)

### Examples

Built-in library subroutines include:
- Printing
- Type casting
- Finding maximum/minimum values
- Generating random numbers

Custom library subroutines could include:
- Calculating the length of a linked list
- Bespoke data structure implementations
- Industry-specific calculations

### Connection to Decomposition

When designing software:
1. The problem is **decomposed** (broken down into smaller, simpler tasks)
2. Developers identify where reusable components can be applied
3. Components from past projects or external sources can simplify development

### Benefits of Reusable Components

- **More reliable** than newly-coded components (already tested, bugs dealt with)
- **Saves time, money and resources** during development
- Subroutines can be reused with **different arguments** to produce varied outputs
- Well-tested components can be **reused in future projects**
- Reduces overall development costs

### Drawbacks of Reusable Components

- **Compatibility issues** may prevent integration of third-party components
- Components may need **modification** to work with existing software
- Modification can sometimes be **more costly and time-consuming** than developing in-house

---

## Exam Tips

1. When identifying inputs/outputs, consider **data types** and **input/output devices**
2. Preconditions must be **evaluable conditions** (e.g., "room dimensions > 0" not just "room dimensions")
3. Remember that caching is an **A Level only** topic
4. Link reusable components to **decomposition** in problem-solving questions
5. Be able to explain both advantages **and** disadvantages of each concept
