# 6.3 Thinking Procedurally

## Specification Coverage
- 2.1.3 a) Identify the components of a problem
- 2.1.3 b) Identify the components of a solution to a problem
- 2.1.3 c) Determine the order of the steps needed to solve a problem
- 2.1.3 d) Identify sub-procedures necessary to solve a problem

---

## What is Thinking Procedurally?

**Thinking procedurally** is an approach to problem-solving that involves breaking a problem down into smaller parts which are easier to understand and consequently easier to design. It uses **procedural abstraction**, which means using procedures to execute sequences of instructions to achieve some goal.

---

## Identifying the Components of a Problem

### Problem Decomposition

**Problem decomposition** is the process of taking the problem defined by the user and breaking it down into its component parts. In this process, a large, complex problem is continually broken down into smaller **sub-problems** which can be solved more easily.

**Benefits of decomposition:**
- Makes problems more **feasible to manage**
- Can be **divided between a group of people** according to different skill sets
- Each subproblem becomes **easier to understand** and solve

### The Role of Abstraction

**Abstraction** is the act of removing unimportant details from a real problem and focusing on the details that will form part of the solution (component).

**Examples of abstraction:**
- **Modelling environments**: A garden or football field in a program does not require modelling every blade of grass - usually a green mesh or image forms the basis for representation
- **Saving files**: Users do not need to know the underlying complex procedures used to save a file on a hard disk drive or how the operating system represents data using paging and segmentation in RAM
- **Sending an email**: Users do not need to know which protocols are being used, how data is formatted, or what protocol handshaking occurs
- **Downloading content**: Users do not need to explicitly know how security checks are made using digital certificates, signatures, and protocols

### Top-Down Design (Stepwise Refinement)

**Top-down design** (also known as **stepwise refinement**) is the preferred method used to approach very large problems. It involves breaking down a problem into major tasks and breaking down these major tasks into smaller sub-tasks.

**Key characteristics:**
- Breaks problems down into **levels**
- **Higher levels** provide an overview of a problem
- **Lower levels** specify in detail the components of the problem
- Each sub-task is broken down until each can be solved using a **single subroutine or module**
- Each sub-task should be **unable to be broken down further**, be **easily solved**, and be **clear**

**Example - Adventure Game Decomposition:**

Level 1: Adventure Game
- Level 2: Characters
  - Characters' interactions
  - Characters' appearance
- Level 2: Adventures
  - Levels
  - Backgrounds and settings
- Level 2: Enemies
  - Enemies' interactions
  - Enemies' appearance

**Example - Book Reservation System:**

Level 1: Book Reservation System
- Level 2: Borrower Input
  - Borrower name
  - Book details
- Level 2: Process Request
  - Collection location
  - Check book availability
- Level 2: Confirm Request
  - Print estimated arrival date
  - Display account details

**Aim of top-down design:**
- Keep splitting problems into subproblems until each can be represented as a **single task** and ideally a **self-contained module or subroutine**
- Each task can be solved and developed as a subroutine by a **different person**
- Subroutines can be **tested separately** before being brought together and finally **integrated**

---

## Identifying the Components of a Solution

This stage considers the details about how each component is implemented. Separating out components makes it easier to identify a feasible and programmable solution.

### Technical Considerations

When identifying solution components, programmers must consider:

- **Input parameter and output data types**: Integer, real/float, string, boolean, etc.
- **Data structures required**: Array, list, dictionary, linked list, hash table
- **Libraries required**: Statistics module, math module, etc.
- **Output format**: Array, list, dictionary, output string, etc.
- **Data transformations and constructs**: Multiplication, division, for loop, while loop, select case
- **Algorithm efficiency**: Does the algorithm need to be O(n) or less?

### Implementation Examples (Book Reservation System)

**Borrower name** - Could be implemented as a procedure `getName()` which:
- Checks if user is signed-in to their library account
- If signed-in, retrieves name by querying the library's database
- If not signed-in, redirects to a page requesting registration or sign-in

**Book details** - Could be implemented as a function which:
- Allows user to enter the book name into a text entry field
- Displays books stocked by the library group
- Returns the ISBN of the selected book (easier to handle than a string)

**Collection location** - Could be implemented as a function which:
- Returns the location specified by the user
- Uses a **drop-down field** rather than text entry to prevent erroneous data

**Check book availability** - Could be implemented as a function which:
- Carries out a database query to check if books under the selected ISBN are available
- Returns 'True' if available, 'False' if not

### Reusing Existing Components

During this stage, it is useful to identify tasks which could be solved using an **already existing module, subroutine, or library**. This reduces the complexity of the development stage.

Finally, the components of the solution are combined to form a full, working solution.

---

## Determining the Order of Steps

When constructing the final solution, thinking about the **order in which operations are performed** becomes critical.

### Key Considerations

**Input and validation requirements:**
- Some programs require certain inputs to be entered before processing can be carried out
- Inputs need to be **validated** before being passed to the next subroutines

**Subroutine dependencies:**
- Some subroutines require **data from other subroutines** before they can execute
- Programmers must determine the **order in which subroutines are executed**
- Must determine **how subroutines interact with each other** based on their role in solving the problem

**Simultaneous execution:**
- Several subroutines may be able to execute **simultaneously** within a program
- Programmers must identify where this is possible by examining the data and inputs each subroutine requires

### Practical Application

Programs should be built to ensure operations are not carried out in an order that does not make sense or will raise an error.

**Examples:**
- **Adventure game**: Users should not be able to access and play levels ahead of those they have unlocked
- **Fast food delivery app**: Users should not select food until they have confirmed their location, nor pay before confirming their order

These logical constraints must be **explicitly written into software** for programs to work as intended.

---

## Sub-Procedures and Hierarchy Charts

### What is a Hierarchy Chart?

A **hierarchy chart** is a diagram used to show problem decomposition. It visually represents how modules and subroutines relate to each other as a **tree structure**.

**Characteristics:**
- Each problem is divided into multiple subproblems
- Subproblems are divided into further subproblems until they cannot be divided any further
- Can be created on paper, digitally, or programmatically by software

### Advantages of Decomposition into Sub-Problems

| Advantage | Explanation |
|-----------|-------------|
| **Simpler to test** | Each subroutine can be tested independently using unit testing |
| **Easier to maintain** | Self-contained and well-documented code is easier to work with |
| **Easier to find errors** | Smaller modules make debugging more straightforward |
| **Convenient to reuse** | Subroutines can be reused rather than rewriting code |
| **Team collaboration** | Tasks can be delegated to different developers |

### Example - Student Grade Calculation

**Step 1** - Calculate the grade for each assessment:
- For each question, **mark the question** and **store the value**
- **Sum the value** of each marked question

**Step 2** - For each student, calculate the average grade across all assessments:
- **Add up the grade** for each assessment
- **Divide by the number of assessments**
- **Store the result**

**Step 3** - **Repeat** steps 1-2 for each class

---

## Exam Tips

- When asked to describe sub-procedures, focus on what the procedure **does** and what **output or effect** it produces, not just basic input handling
- Basic input procedures (e.g., moving left/right) are typically not credit-worthy, but showing the **output of a move** would be
- Remember that "procedure" in thinking procedurally doesn't strictly mean a subroutine that doesn't return a value - it refers to a **unit of computation that performs a single task**
- A **function** returns a value; a **procedure** does not return a value
- When decomposing problems, ensure each sub-task is at the appropriate level of detail - not too broad, not too specific

---

## Key Terminology Summary

| Term | Definition |
|------|------------|
| **Thinking procedurally** | Breaking a problem into smaller, manageable parts using procedures |
| **Problem decomposition** | Breaking a large, complex problem into smaller sub-problems |
| **Abstraction** | Removing unimportant details to focus on relevant solution components |
| **Top-down design** | Breaking a problem into major tasks, then into smaller sub-tasks |
| **Stepwise refinement** | Alternative term for top-down design |
| **Hierarchy chart** | A tree-structure diagram showing problem decomposition |
| **Sub-procedure** | A self-contained unit of computation that performs a single task |
