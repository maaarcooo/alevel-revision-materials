# 6.4 Thinking Logically

## Specification Coverage
- **2.1.4 a)** Identify the points in a solution where a decision has to be taken
- **2.1.4 b)** Determine the logical conditions that affect the outcome of a decision
- **2.1.4 c)** Determine how decisions affect flow through a program

---

## Decisions in Computational Thinking

### Definition
A **decision** is a result reached after some consideration. When solving problems and designing programs, decisions determine which path of execution the program follows based on evaluated conditions.

### Structured Programming Techniques
Most languages use **structured programming techniques** to control the flow of execution:

| Construct | Description | Examples |
|-----------|-------------|----------|
| **Sequence** | Statements executed one after another in order | Linear code execution |
| **Selection** | Decision-making based on conditions | `if/then/else`, `switch/case` |
| **Iteration** | Repeating a sequence of instructions | `for`, `while`, `do while`, `do until` |

**Purpose:** These techniques **aid the readability, understanding and maintainability** of code.

### Block-Structured Languages
Python is an example of a **block-structured language** that uses only these three constructs. Each block of code should have:
- A **single entry point**
- A **single exit point**
- Minimal breaking out of iterative blocks (to prevent unintended consequences)

---

## Identifying Decision Points

### Where Decisions Occur in Programs
Decisions in programs typically occur in two situations:
1. **Selection statements** - `if statement/select case`
2. **Iteration structures** - typically a `while loop`

**Selection** (also known as **branching**) involves directing the flow of control dependent on a **Boolean condition** or set of conditions.

**Iteration** involves **repeating** a sequence of instructions based on a stopping Boolean condition.

### Common Programming Decisions
When developing software, decisions must be made about:
- Which programming paradigm to use
- Which programming language to use
- What input/output devices are needed
- How to collect and process information
- Data structures and algorithms to employ

### Factors Affecting Decision Outcomes
When making decisions, consider:
- **Effectiveness** - What produces the best results?
- **Convenience** - What is practical given constraints?
- **Feasibility** - Is this option reasonable and achievable?

Prioritise these factors based on the purpose and end-users of the software.

---

## Algorithm Design Tools

### Planning Before Coding
It is always best to **plan the algorithm** using **flowcharts**, **pseudocode** or **structured English** before coding in a language.

Languages have specific **syntax**, **constructs** and **idiosyncrasies** that differ between languages, making it challenging to create solutions immediately implementable in another language.

### Comparison of Design Tools

| Tool | Advantages | Disadvantages |
|------|------------|---------------|
| **Flowcharts** | **Visually** show flow of control; decisions are clear and easy to follow | **Time consuming to create** |
| **Pseudocode** | **More accurately** mimics programming constructs; no syntax rules; any expression is acceptable as long as **meaning is clear** | Less visual than flowcharts |
| **Structured English** | Alternative to pseudocode; uses natural language | Usually more **verbose** and **imprecise** |

### Flowchart Decision Symbol
In flowcharts, a decision is represented by a **diamond-shaped symbol** with two possible outcomes: **Yes (True)** or **No (False)**.

---

## Boolean Conditions

### Understanding Boolean Conditions
Most errors in programs occur when evaluating a **Boolean condition**, whether in a **sequence** as part of a statement, **iteration** or **selection**. Care must be taken when creating Boolean conditions, especially long, complex conditions involving multiple clauses.

### Comparison Operators

| Operator | Meaning |
|----------|---------|
| `==` | Equal to |
| `>` | Greater than |
| `>=` | Greater than or equal to |
| `<` | Less than |
| `<=` | Less than or equal to |
| `!=` | Not equal to |

### Logical Operators

| Operator | Description |
|----------|-------------|
| **AND** | Both conditions must be true |
| **OR** | Either or both conditions must be true |
| **NOT** | The condition is not true (negation) |
| **XOR** | Only one or the other condition must be true (exclusive OR) |

### Example: Compound Condition
```
if age >= 15 AND money >= 8 then
    entry = True
endif
```
This checks if a teenager is old enough AND has sufficient money for cinema entry.

---

## How Decisions Affect Program Flow

### Flow of Control
Decisions **affect the flow of control** of a program. Each decision point directs the program through different statements depending on the condition's evaluation.

### Selection Structures

#### If/Then/Else Example
```
if today == "Monday" then
    print("Eugh! Monday again!")
elseif today == "Tuesday" then
    print("Tuesday, one day closer to the weekend!")
elseif today == "Wednesday" then
    print("Half way there!")
else
    print("That's not a recognised day!")
endif
```

#### Switch/Case Example
```
switch entry:
    case "Monday":
        print("Eugh! Monday again!")
    case "Tuesday":
        print("Tuesday, one day closer to the weekend!")
    default:
        print("That's not a day!")
endswitch
```

### Nested Structures
**Iteration** and **selection** statements can be **nested**, creating complex decision structures:

```
Count ← 0
REPEAT
    INPUT Score[Count]
    IF Score[Count] >= 70 THEN
        Grade[Count] ← "A"
    ELSE
        IF Score[Count] >= 60 THEN
            Grade[Count] ← "B"
        ELSE
            IF Score[Count] >= 50 THEN
                Grade[Count] ← "C"
            ELSE
                Grade[Count] ← "F"
            ENDIF
        ENDIF
    ENDIF
    Count ← Count + 1
UNTIL Count = 30
```

Each **if statement** contains another **if statement** which affects the flow of the program.

---

## Practical Example: Identifying Decision Points

Consider an algorithm to remove numeric strings from a list:

```
i = 0
valid_element = True
while len(my_list) > 0:
    valid_element = True
    element = str(my_list[i])
    for index in element:
        if element[index] in ["0","1","2","3","4","5","6","7","8","9"] then
            valid_element = False
            break
        endif
    next index
    if valid_element == False then
        my_list.pop(i)
    endif
endwhile
```

### Decision Points Identified:
1. **While loop condition** (`len(my_list) > 0`): The list must have at least one element
2. **For loop**: Iterates over all characters; stopping condition is reaching the end
3. **First if statement**: Checks if each character is a numeric digit
4. **Second if statement**: Determines whether to remove the element

### Using Break Statements
**Break** instructions are powerful for controlling flow but should be used carefully as they can cause unintended problems if misused.

---

## Summary: Thinking Logically

**Thinking logically** involves:
- Identifying where decisions need to be made within a solution
- Planning out the outcomes of each decision
- Understanding that different decisions produce different routes through the program
- Preparing for different scenarios by foreseeing decisions throughout the program

**Key principle:** Good decision-making is fundamental to solving problems effectively. The program will follow different routes depending on decisions made by both the programmer (design decisions) and the user (runtime decisions).

---

## Exam Tips

1. **Identify decision points** by looking for selection (`if`, `switch`) and iteration (`while`, `repeat`) statements
2. **Trace through algorithms** carefully, noting how Boolean conditions change the execution path
3. **Be precise with Boolean operators** - AND requires both conditions true; OR requires at least one
4. **Watch for off-by-one errors** in comparison operators (e.g., `>` vs `>=`)
5. **Consider all possible paths** through nested structures when analysing algorithms
