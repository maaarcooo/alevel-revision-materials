# 7.1 Programming Techniques

## Contents
1. [Data Types](#data-types)
2. [Arithmetic, Logical & Boolean Operators](#arithmetic-logical--boolean-operators)
3. [Programming Constructs](#programming-constructs)
4. [Selection](#selection)
5. [Iteration](#iteration)
6. [Modularity, Functions & Procedures](#modularity-functions--procedures)
7. [Parameter Passing](#parameter-passing)
8. [Recursion](#recursion)
9. [Global & Local Variables](#global--local-variables)
10. [Integrated Development Environment (IDE)](#integrated-development-environment-ide)
11. [Object-Oriented Programming (OOP)](#object-oriented-programming-oop)

---

## Data Types

### What is a Data Type?
A **data type** is a classification of data into groups according to the kind of data they represent. Computers use different data types to represent different types of data in a program.

### Basic Data Types

| Data Type | Description | Examples |
|-----------|-------------|----------|
| **Integer** | Whole numbers (positive or negative) | `10`, `-5`, `0` |
| **Real** | Numbers with a fractional part (positive or negative) | `3.14`, `-2.5`, `0.0` |
| **Char** | A single character (letter, digit, or symbol) | `'a'`, `'B'`, `'5'`, `'$'` |
| **String** | A sequence of characters | `"Hello World"`, `"1234"`, `"@#$%"` |
| **Boolean** | True or false values | `True`, `False` |

It is important to choose the correct data type for a given situation to ensure accuracy and efficiency in the program.

### Casting (Type Conversion)
**Casting** is when you convert one data type to another data type.

When a user enters data into a program, this will more than likely be in a string format. It's essential to convert some of this string data to a numerical format where possible (e.g., for calculations or comparisons).

**Example**: If `"12"` is stored as a string and you want to check if this value is below 20, the string value must be cast as an integer for the comparison to take place.

#### Casting Examples (Python)
```python
int_value = int("123")      # Converts string "123" to integer 123
float_value = float("3.14") # Converts string "3.14" to float 3.14
```

#### Casting Conversions Table

| Conversion | Example (Python) | Output |
|------------|------------------|--------|
| Integer to Real | `float(5)` | `5.0` |
| Real to Integer | `int(5.7)` | `5` |
| String to Integer | `int("10")` | `10` |
| Integer to String | `str(5)` | `"5"` |
| Boolean to String | `str(True)` | `"True"` |
| String to Boolean | `bool("True")` | `True` |

---

## Arithmetic, Logical & Boolean Operators

### Arithmetic Operators
**Arithmetic operators** are symbols or keywords used to perform mathematical calculations and operations on numerical values.

| Operator | Name | Description | Example | Result |
|----------|------|-------------|---------|--------|
| `+` | Addition | Adds values or concatenates strings | `5 + 3` | `8` |
| `-` | Subtraction | Subtracts one value from another | `10 - 4` | `6` |
| `*` | Multiplication | Multiplies values together | `3 * 5` | `15` |
| `^` or `**` | Exponentiation | Raises to a power | `3 ^ 3` | `27` |
| `/` | Division | Divides one value by another | `10 / 2` | `5` |
| `MOD` or `%` | Modulus | Returns the remainder after division | `10 MOD 3` | `1` |
| `DIV` or `//` | Integer Division | Returns the integer quotient | `10 DIV 3` | `3` |

### Operator Precedence (BIDMAS/BODMAS)
Arithmetic operators follow **operator precedence** rules which determine the order in which operators are evaluated:
1. **B**rackets
2. **I**ndices (powers)
3. **D**ivision and **M**ultiplication (left to right)
4. **A**ddition and **S**ubtraction (left to right)

**Example**:
- `2 + 3 * 4` = `14` (multiplication first)
- `(2 + 3) * 4` = `20` (brackets first)

### Logical (Comparison) Operators
**Logical operators** are symbols or keywords used to compare values and return a boolean result.

| Operator | Name | Description | Example | Result |
|----------|------|-------------|---------|--------|
| `==` | Equal to | Returns true if values are equal | `5 == 6` | `False` |
| `!=` or `<>` | Not equal to | Returns true if values are not equal | `5 != 7` | `True` |
| `>` | Greater than | Returns true if left > right | `5 > 10` | `False` |
| `<` | Less than | Returns true if left < right | `5 < 10` | `True` |
| `>=` | Greater than or equal | Returns true if left >= right | `5 >= 10` | `False` |
| `<=` | Less than or equal | Returns true if left <= right | `5 <= 10` | `True` |

### Boolean Operators
**Boolean operators** are symbols or keywords used to combine and manipulate boolean values.

| Operator | Description | Truth Table |
|----------|-------------|-------------|
| `AND` | Returns `True` if **both** operands are true | `True AND True = True`; all others = `False` |
| `OR` | Returns `True` if **at least one** operand is true | `False OR False = False`; all others = `True` |
| `NOT` | Negates a boolean value | `NOT True = False`; `NOT False = True` |

**Examples**:
```python
x, y, z = 5, 10, 15
result = (x < y) AND (y < z)  # True (both conditions true)
result = (x > y) OR (y < z)   # True (second condition true)
result = NOT False            # True
```

---

## Programming Constructs

### What is a Programming Construct?
A **programming construct** determines the order in which lines of code are executed. There are **three programming constructs**:

1. **Sequence** - Lines of code run one at a time in the order they are written
2. **Selection (Branching)** - Flow is interrupted to test a condition; the outcome determines which code runs next
3. **Iteration** - Repeating a line or block of code using a loop

### Identifying Programming Constructs
- **Selection keywords**: `if`, `elseif`, `else`, `endif`, `switch`, `case`
- **Iteration keywords**: `for`, `while`, `do`
- **Sequence**: Any code without the above keywords

---

## Selection

### What is Selection?
**Selection** is used within the branching programming construct. It tests conditions, and the outcome determines which lines or block of code runs next.

Two ways to write selection statements:
1. `if... elseif... else...` statements (test conditions sequentially)
2. `switch... case...` statements (test an expression against multiple constant values)

### Writing a Condition
Think of it like writing a **yes/no question**:
- Is the number bigger than 10?
- Is the number between 50 and 100?
- Is the answer "Paris"?

### If Statements

#### Syntax of `if...`
```
if condition then
    // Code executed if condition is true
endif
```

#### Syntax of `if... else...`
```
if condition then
    // Code executed if condition is true
else
    // Code executed if condition is false
endif
```

#### Syntax of `if... elseif... else...`
```
if condition then
    // Code executed if first condition is true
elseif condition then
    // Code executed if second condition is true
else
    // Code executed if all conditions are false
endif
```

**Python Example**:
```python
score = 85
if score >= 90:
    print('Excellent!')
elif score >= 80:
    print('Good.')
elif score >= 70:
    print('Fair.')
else:
    print('Needs improvement.')
```

### Case (Switch) Statements
`switch/case` provides an alternative way to perform multiple comparisons based on the value of an expression.

#### Syntax
```
switch expression
    case value1:
        // Code if expression matches value1
    case value2:
        // Code if expression matches value2
    default:
        // Code if no case matches
endswitch
```

**Python Example (match-case)**:
```python
grade = 'b'
match grade:
    case 'a':
        print("Excellent")
    case 'b':
        print("Good")
    case 'c':
        print("Fair")
    case _:
        print("Needs improvement")
```

---

## Iteration

### What is Iteration?
**Iteration** is the process of doing something more than once (repeating), otherwise known as a **loop**.

Types of loops:
- **Count-controlled** - Code repeated a **fixed number** of times (e.g., `for` loop)
- **Condition-controlled** - Code repeated **until a condition is met** (e.g., `while`, `do while` loops)

### For Loops (Count-Controlled)
A **for loop** repeats a fixed number of times.

#### Syntax
```
for i = x to y
    // Code to be executed in each iteration
next i
```

**Python Example**:
```python
for i in range(0, 6):  # Outputs 0, 1, 2, 3, 4, 5
    print(i)
```

#### Iterating Over an Array
```python
fruits = ["apple", "banana", "orange"]
for i in range(len(fruits)):
    print(fruits[i])
```

### While Loops (Condition-Controlled)
A **while loop** repeats until a condition is met. The condition is checked **before** each iteration.

#### Syntax
```
while condition
    // Code executed while condition is true
endwhile
```

**Python Example**:
```python
password = ""
while password != "secret":
    password = input("What is the password? ")
```

### Do While Loops (Condition-Controlled)
A **do while loop** executes the code block **at least once** before checking the condition.

#### Syntax
```
do
    // Code executed at least once
until condition
```

**Key Difference**: A `while` loop may never execute if the condition is initially false; a `do while` loop always executes at least once.

> **Note**: Python does not have a native `do while` loop; use a `while True` loop with a `break` condition instead.

---

## Modularity, Functions & Procedures

### What is Modularity?
**Modularity** is a concept where problems are broken down into more manageable pieces. Each piece should be carried out by a single **subroutine** (also called a module).

**Subroutines** are standalone blocks of code that complete a task when called. They promote:
- Code reusability
- Modularity
- Organisation

### Functions vs Procedures

| Feature | Function | Procedure |
|---------|----------|-----------|
| Returns a value | **Yes** | **No** |
| Purpose | Performs a task and returns a result | Performs a task without returning a value |
| Example use | Calculations, data transformations | Printing output, modifying global state |

### Functions

#### Syntax
```
function functionName(parameter1, parameter2)
    // Code block
    return value
endfunction
```

**Python Example**:
```python
def add_numbers(a, b):
    return a + b

c = add_numbers(5, 10)
print(c)  # Output: 15
```

### Procedures

#### Syntax
```
procedure procedureName(parameter1, parameter2)
    // Code block (no return statement)
endprocedure
```

**Pseudocode Example**:
```
procedure addNumbers(a, b)
    total = a + b
    print(total)  // Result printed, not returned
endprocedure
```

### Best Practices
- **Naming**: Use descriptive, meaningful names indicating purpose
- **Parameters**: Use clear, meaningful parameter names
- **Focus**: Keep functions/procedures short and focused on a specific task
- **Return values**: Functions should have explicit return statements; procedures should not

---

## Parameter Passing

### What are Parameters?
A **parameter** is a piece of data input into a code block (function or procedure) so it can complete its task.

Two standard methods:
1. **Passing by Value (byVal)**
2. **Passing by Reference (byRef)**

### Passing by Value
- A **copy** of the actual value is made and assigned to the function's parameter
- Changes within the function do **not** affect the original value
- When the function ends, the copy is destroyed
- Suitable for protecting original data from modification

**Pseudocode Example**:
```
number = random(1, 10)
function printValue(number : byVal)
    return("The random value is:", number)
endfunction
```

### Passing by Reference
- The function receives the **memory address** of the value
- Changes within the function **directly affect** the original value
- More efficient for large data structures (no copying)
- Can lead to unexpected side effects if not handled carefully

**Pseudocode Example**:
```
number = random(1, 10)
function printValue(number : byRef)
    return("The random value is:", number)
endfunction
```

### Comparison Table

| Aspect | Passing by Value | Passing by Reference |
|--------|------------------|---------------------|
| **Parameter Handling** | Copy of value assigned | Memory address passed |
| **Data Protection** | Original data protected | Original data can be modified |
| **Performance** | Can incur overhead (copying) | More efficient (no copying) |
| **Memory** | Increased consumption (copies) | No duplication |
| **Scope** | Changes don't propagate outside | Changes affect original data |
| **Reusability** | Enhanced (doesn't modify original) | May reduce (affects caller's data) |

---

## Recursion

### What is Recursion?
**Recursion** is a programming technique where a **function calls itself** to solve a problem.

### Three Features of a Recursive Algorithm
1. The function must **call itself**
2. A **base case** - a condition that returns a value without further recursive calls
3. A **stopping condition** - must be reachable after a finite number of iterations

### How Recursion Works
The function calls itself with a modified input parameter until it reaches the **base case**, which stops the recursion.

**Example: Factorial Calculation**
```python
def factorial(n):
    # Base case
    if n == 0 or n == 1:
        return 1
    else:
        # Recursive call
        return n * factorial(n - 1)

result = factorial(5)  # Output: 120 (5! = 5 × 4 × 3 × 2 × 1)
```

### Importance of a Stopping Condition
Without a proper stopping condition, recursion will continue indefinitely, causing:
- **Stack overflow errors**
- Excessive memory usage
- Program crashes

### Recursion vs Iteration

| Aspect | Recursion | Iteration |
|--------|-----------|-----------|
| **Benefits** | Concise code; simple for tree structures | Better performance; easier debugging |
| **Drawbacks** | CPU/memory intensive; harder to debug | More complex code; less concise |
| **Memory** | Uses more (call stack) | Uses less |
| **Application** | Trees, fractals, divide-and-conquer | General-purpose looping |

### Translating Between Recursion and Iteration

**Recursive Approach**:
```python
def countdown_rec(n):
    print(n)
    if n == 0:
        return
    countdown_rec(n - 1)
```

**Iterative Approach**:
```python
def countdown_iter(n):
    while n >= 0:
        print(n)
        n = n - 1
```

---

## Global & Local Variables

### Global Variables
A **global variable** is declared at the outermost level of a program (outside any functions/procedures). It has **global scope** and can be accessed/modified from any part of the program.

**Python Example**:
```python
globalVariable = 10  # Global variable

def printValue():
    global globalVariable  # Access global variable
    print("Value:", globalVariable)
```

#### Uses for Global Variables
- **Data Sharing**: Facilitates data sharing between different parts of the program
- **Persistent Storage**: Retains values throughout program execution
- **Global Configuration**: Stores settings or constants relevant across the entire program

#### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Only needs to be declared once | Always stored in memory while program runs |
| No need to pass parameters between modules | Difficult to maintain (hard to track changes) |
| | Difficult to test individual blocks |

### Local Variables
A **local variable** is declared within a specific scope (function or code block). It is only accessible within that block, and its lifetime is limited to that block.

**Python Example**:
```python
def printValue():
    localVariable = 10  # Local variable
    print("Value:", localVariable)
```

#### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Encapsulates data; prevents unintended access | Repeated creation/destruction can cause overhead |
| Same variable name can be used in different functions | Excessive use reduces readability |
| Memory automatically reclaimed when block ends | |

---

## Integrated Development Environment (IDE)

### What is an IDE?
An **Integrated Development Environment (IDE)** is a software tool that provides programmers with a comprehensive platform to write, edit, compile, debug, and manage code efficiently.

**Examples**: IDLE (Python), Replit, Visual Studio Code, PyCharm

### IDE Features for Writing Code

| Feature | Description |
|---------|-------------|
| **Syntax Highlighting (Pretty Printing)** | Visually distinguishes code elements with different colours (keywords, strings, comments, variables) |
| **Autocomplete** | Suggests code completions as programmers type; adds closing brackets automatically |
| **Auto-indent** | Automatically indents code when starting a new line within a code block |
| **Code Comments** | Allows adding documentation/explanations that are not executed |

### IDE Features for Debugging Code

| Feature | Description |
|---------|-------------|
| **Syntax Error Highlighting** | Highlights syntax errors in the editor as developers type |
| **Variable Watch Window** | Monitors values of specific variables during runtime |
| **Breakpoints** | Markers that pause program execution at specific lines for inspection |
| **Error Message List** | Displays collection of errors, warnings, and messages with locations |
| **Stepping Mode** | Executes program one line at a time (step into, step over, step out) |
| **Crash Dump/Post-mortem Report** | Captures program state at the time of a crash |
| **Stack Contents** | Shows order of function calls and their parameters/local variables |

---

## Object-Oriented Programming (OOP)

### Classes
A **class** is a blueprint/template for creating objects. It defines attributes (data) and methods (behaviours).

**Pseudocode Example**:
```
class Cars
    private Manufacturer
    private Model
    private Price
    private Mileage
    private PreOwned
    
    public procedure new(manufacturer, model, price, mileage, preOwned)
        Manufacturer = manufacturer
        Model = model
        Price = price
        Mileage = mileage
        PreOwned = preOwned
    endprocedure
    
    public procedure Accelerate()
        // Code to make car go faster
    endprocedure
endclass
```

**Python Example**:
```python
class Cars:
    def __init__(self, manufacturer, model, price, mileage, preOwned):
        self.Manufacturer = manufacturer
        self.Model = model
        self.Price = price
        self.Mileage = mileage
        self.PreOwned = preOwned
    
    def Accelerate(self):
        # Code to make car go faster
        pass
```

### Objects
An **object** is an instance of a class. Creating an object is called **instantiation**.

**Python Example**:
```python
person1 = Person("Bob", "Jones", "06/10/1981", "E Sports")
person2 = Person("Jess", "Jones", "05/04/1980", "Astronomy")
```

### Methods
**Methods** are functions defined within a class that describe the behaviours of objects.

- **Public methods**: Accessible from outside the class
- **Private methods**: Only accessible from within the class (indicated by `_` prefix in Python)

### Attributes
**Attributes** are variables defined within a class that store data about objects.

- **Public attributes**: Accessible from outside the class
- **Private attributes**: Only accessible from within the class (indicated by `__` prefix in Python)

### Inheritance
**Inheritance** allows a class (subclass/child) to inherit attributes and methods from another class (superclass/parent).

**Python Example**:
```python
class Vehicle:  # Parent class
    def __init__(self, manufacturer, make, cost):
        self.manufacturer = manufacturer
        self.make = make
        self.cost = cost
    
    def turn_engine_on(self):
        pass

class Car(Vehicle):  # Child class inherits from Vehicle
    def __init__(self, manufacturer, make, cost, is_insured, engine_capacity):
        super().__init__(manufacturer, make, cost)  # Call parent constructor
        self.is_insured = is_insured
        self.engine_capacity = engine_capacity
    
    def gear_change(self):
        pass
```

### Encapsulation
**Encapsulation** is the bundling of data (attributes) and methods that operate on that data within a class, restricting direct access to some components.

#### Get Methods (Getters/Accessors)
Retrieve the value of private attributes:
```python
class NumberUpdater:
    def __init__(self):
        self.__number = 10  # Private attribute
    
    @property
    def number(self):
        return self.__number
```

#### Set Methods (Setters/Mutators)
Set the value of private attributes with validation:
```python
class NumberUpdater:
    def __init__(self):
        self.__oldnumber = 10
    
    def setNumber(self, newnumber):
        if newnumber < 0:
            self.__oldnumber = self.__oldnumber  # Keep same
        else:
            self.__oldnumber = newnumber  # Update
```

### Polymorphism
**Polymorphism** allows objects of different classes to be treated as objects of a common superclass. The same method name can behave differently depending on the object calling it.

**Python Example**:
```python
class Animal:
    def speak(self):
        pass  # Placeholder

class Dog(Animal):
    def speak(self):
        print("Woof")

class Cat(Animal):
    def speak(self):
        print("Meow")

def make_sound(animal):
    animal.speak()

dog = Dog()
cat = Cat()
make_sound(dog)  # Outputs: Woof
make_sound(cat)  # Outputs: Meow
```

This demonstrates **run-time polymorphism** - the method call is resolved based on the actual type of the object at runtime, not compile time.

---

## Exam Tips

1. **Data Types**: Always choose the most appropriate data type for efficiency and accuracy.

2. **Selection**: 
   - Check whether to use `AND` or `OR` carefully: `if number < 0 AND number > 100` is impossible; use `OR` instead.
   - You can use as many `elseif` statements as needed, but consider `switch/case` for clarity.

3. **Iteration**: 
   - Remember that `do while` always runs at least once.
   - Incrementing can be written as `i = i + 1`, `i += 1`, or `i++` depending on the language.

4. **Recursion**: 
   - Always ensure there is a proper stopping condition to avoid stack overflow.
   - A recursive algorithm has three features: calls itself, has a base case, has a reachable stopping condition.

5. **Parameter Passing**:
   - Use **by value** when you want to protect original data.
   - Use **by reference** when working with large data structures or when the function needs to modify the original.

6. **IDE Features**: 
   - Know which features help with **writing** code (autocomplete, auto-indent, syntax highlighting).
   - Know which features help with **debugging** code (breakpoints, stepping, watch window).

7. **OOP**:
   - **Attributes** store data; **Methods** define behaviours.
   - Use `super()` to call the parent class constructor in inheritance.
   - Encapsulation uses getters and setters to control access to private attributes.

8. **Pseudocode vs Code**: When questions allow program code, use consistent syntax from your chosen language (Python, Java, etc.).
