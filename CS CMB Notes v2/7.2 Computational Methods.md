# 7.2 Computational Methods

## Features of Computation

### What are Computational Methods?

**Computational methods** are a set of problem-solving techniques that use algorithms and mathematical models to analyse, simulate, and solve complex problems efficiently using a computer.

It is important to consider whether problems can be solved using algorithms and programming code:
- **Suitable for computation**: Sorting a list of numbers using quick sort or merge sort
- **Not suitable for computation**: Ethical or social problems (e.g., loan approval decisions) may incorporate human input that algorithms could oversimplify or misinterpret

### Real-World Constraints on Computable Problems

**Practical limitations** such as computing power, speed, and memory can affect whether a problem is solvable:
- Running complex machine learning models on a regular laptop may be constrained by limited processing power and memory
- Some problems are theoretically solvable but not practical due to resource limitations (e.g., calculating Pi to a billion decimal places)

**Advances in technology** have expanded the types of problems that can be computationally solved:
- Genome sequencing has become quicker and more affordable due to technological improvements

### Identifying Computational Problems

| Problem | Computational? | Justification |
|---------|----------------|---------------|
| Inventory not updated in real-time | Yes | Real-time syncing achievable through algorithms |
| High employee turnover | No | Root causes are cultural or managerial, not algorithmic |
| Incorrectly sorted products in delivery van | Yes | Sorting algorithms can optimise placement |
| Long customer service wait times | Yes | Queue algorithms can improve response times |
| Poor route optimisation | Yes | Routing algorithms exist for this specific problem |
| Inadequate marketing strategies | No | Requires creative and human-centric solutions |

---

## Problem Recognition

### What is Problem Recognition?

**Problem recognition** is determining if there is a problem that needs to be solved.

For example, if customers complain that a checkout process is slow, problem recognition can be used to determine:
1. That there is a problem to be solved
2. What the problem actually is (e.g., too many steps, poor organisation of information)

Not all problems should or can be solved with software.

### Example: Computational Problem (GP Surgery Booking System)

**The Big Problem**: Slow response time in the online appointment booking system, leading to user frustration and abandoned bookings.

**Sub-problems**:
1. **Peak hour bottlenecks** - System experiences significant slowdown, indicating potential scalability issues
2. **Delayed confirmation** - Several minutes wait for confirmation screen, pointing to inefficient processing
3. **User experience** - Frustrated users may lose faith in the system
4. **Abandoned bookings** - Patients not seeking help with their health

### Example: Non-Computational Problem (Low Employee Morale)

**The Big Problem**: High employee turnover and declining morale affecting team performance and company reputation.

**Sub-problems**:
1. Unrealistic sales targets causing stress
2. Lack of support and resources
3. Poor work-life balance
4. Disrupted team cohesion

This requires **human-centric solutions** like revised management practices, team-building exercises, and counselling services rather than software solutions.

---

## Problem Decomposition

### What is Decomposition?

**Decomposition** is breaking down a big problem into smaller problems so that they can be solved independently.

Programmers use decomposition to:
- Break problems down into manageable parts
- Identify the steps, parts, or processes involved
- Identify reusable components
- Split tasks between programmers

### Process of Decomposition

1. **Apply abstraction** - Remove non-essential elements to focus on critical aspects
2. **Identify the big problem** - Define the main issue to be solved
3. **Decompose into sub-problems** - Break down into smaller, manageable components
4. **Prioritise sub-problems** - Order by impact and dependencies

### Example: Decomposing Slow Response Times

**Big Problem**: Slow response times during online appointment booking

**Sub-problems**:
1. Server limitations causing bottlenecks during peak hours
2. Inefficient algorithms leading to delayed confirmation screens
3. Poor user interface contributing to bad user experience

**Prioritisation**:
1. Address server limitations (broad impact on system performance)
2. Optimise algorithms (speed up booking and confirmation)
3. Make UI improvements (enhance user experience)

---

## Divide and Conquer Algorithms

### What is the Divide and Conquer Strategy?

**Divide and conquer** is a strategy to make a complex task easier by breaking it into smaller, more manageable tasks.

### The Three Steps

| Step | Description |
|------|-------------|
| **Divide** | The problem needs to be broken down into sub-problems |
| **Conquer** | The sub-problems need to be solved independently |
| **Combine** | The solutions to sub-problems are combined to form the overall solution |

### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Can make programs more time efficient | Not all problems can be broken down and solved independently |
| Sub-problems can make effective use of cache memory | Can possibly cause stack overflows if recursion is used |

### Task Parallelism

**Task parallelism** is when several tasks or sub-tasks can be carried out **concurrently** (at the same time) to speed up the overall completion time.

Example: On a factory assembly line, different components can be assembled simultaneously by different teams or machines.

---

## Use of Abstraction

### What is Abstraction?

**Abstraction** is the removal of unnecessary components of a problem to allow focus on only those that are necessary.

Without abstraction, many real-world applications would have far too many variables to take into consideration.

### Examples of Abstraction

**Computer Games**:
- Users see a realistic, visually appealing environment and response to actions
- Users do not need to know the complex algorithms controlling NPCs
- Aim: Make the game realistic while keeping it fun to play

**Cooking with a Recipe**:
- Users follow steps to achieve the desired result
- Users don't need to understand the chemistry behind processes (e.g., 'browning')
- Abstraction allows focus on the recipe's intent rather than the science

**Driving a Car**:
- Driver uses a key/button to start and pedals to control movement
- Driver does not need to know the intricacies of how the engine works
- Abstraction empowers people to utilise complex machines

---

## Backtracking Algorithms

### What is Backtracking?

**Backtracking** is a technique used when:
- You don't have enough information to find a solution
- You have many possible ways of solving a problem

It explores all possible paths in the search space to determine if these come to dead ends.

### How Backtracking Works

1. Build up **partial solutions** to a problem incrementally
2. If the solution fails at some point, **abandon** partial solutions
3. **Backtrack** to the last potentially successful point
4. Continue searching from there

### Use Cases

- **Ideal for**: Logic problems, navigating mazes, traversing trees and graphs
- **Not ideal for**: Strategic problems

In a **binary search tree**, backtracking helps return from leaf nodes (dead ends) so that other subtrees can be explored.

### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Guaranteed to find a solution if one exists | Not ideal for strategic problems |
| Easy to implement and use | Can have high time complexity |
| Can be applied to a variety of logic problems | Not always the most efficient method when many solutions exist |
| Comprehensively explores all possible paths | Can consume a lot of memory |
| | May not always find the best solution available |
| | Often requires complete search of entire solution space |

---

## Data Mining

### What is Data Mining?

**Data mining** is when large quantities of data are turned into useful information so that patterns can be found.

It can be used to:
- Search for relationships and facts not immediately obvious to people
- Extract valuable insights using algorithms and statistical methods
- Make informed decisions in fields including retail, healthcare, and finance

### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Can identify patterns and trends not obvious to humans | Requires very powerful computers with significant processing power |
| Can help organisations make better future predictions | Inaccurate data can produce inaccurate results |
| Organisations can ensure demand is met during busy periods | May spot patterns but not explain why they exist |

### Example Uses of Data Mining

| Industry | Application | Example |
|----------|-------------|---------|
| **Retail** | Analyse purchase history and browsing behaviour for customised suggestions | Amazon suggests items based on past activity |
| **Healthcare** | Predict disease outbreaks or patient admissions | Hospitals anticipate flu cases for better resource allocation |
| **Finance** | Identify suspicious activities among transactions | Credit card companies flag fraudulent transactions in real-time |
| **Automotive** | Predict component failures for proactive maintenance | Tesla collects data to anticipate battery failures |
| **Entertainment** | Understand viewer preferences for content recommendations | Netflix targets shows to audiences based on viewing history |

### Complexities in Data Mining

- Requires knowledge of complex algorithms for data sorting, pattern recognition, and anomaly detection
- Requires significant maintenance and expertise
- Must ensure all mining follows **GDPR** regulations
- Specialist data engineers and data scientists are in short supply

---

## Heuristics for Problem Solving

### What are Heuristics?

**Heuristics** is making use of experience to find a solution to a problem quickly.

Key characteristics:
- Uses **'rules of thumb'** and **'educated guesses'**
- Prioritises **speed over accuracy**
- Aims to find a solution that is **'good enough'** rather than perfect

### Trade-off Between Speed and Accuracy

The "Hot and Cold" game illustrates heuristic principles:
- Clues indicate proximity but don't give exact location
- May get stuck in a **local optimum** (a spot that seems "hot" but isn't the target)
- Finds the object more quickly than random searching
- Doesn't guarantee the quickest or most direct route

### Heuristic Methods in Software

The **A* algorithm** is a common example that uses heuristics in pathfinding and graph traversal:
- Uses heuristics to find a path from start to end node quickly
- The path found may not always be the most efficient path possible

### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Can usually find a solution close to the best available | Won't guarantee finding the 'best' solution |
| Saves time by not investigating every possibility | Requires careful consideration between accuracy and time |
| Very practical and can be easily implemented | Incorrect heuristic values can lead to inaccurate solutions |

---

## Performance Modelling

### What is Performance Modelling?

**Performance modelling** is when the behaviour of something is tested or simulated before it is used in the real world.

It is a systematic approach for evaluating and predicting the performance characteristics of a software system.

### Using Performance Modelling in Software Production

Performance modelling can:
- Help understand how software will behave under different load conditions
- Use metrics like **response time** and **throughput** to identify bottlenecks
- Allow developers to address performance issues before they affect end-users

Integration into software development stages:
- **Design phase**: Make architectural decisions
- **Testing phase**: Simulate real-world scenarios and measure performance

### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Stress testing ensures systems can cope with large data/users | Outcome is only as useful as the accuracy of input data |
| Can predict problems before they occur in the real world | Wrong model rules produce incorrect results |

### Example Applications

| Application | Use |
|-------------|-----|
| **Database optimisation** | Simulate different architectures and query strategies; select best indexing strategy; estimate query response times |
| **Caching mechanisms** | Model different caching strategies; determine optimal cache sizes; assess hit/miss ratio and latency improvements |
| **Energy efficiency** | Estimate power consumption under different usage patterns for battery-powered devices |

---

## Pipelining as a Computational Method

### What is Pipelining?

**Pipelining** is the process of carrying out multiple instructions concurrently. It improves overall efficiency and performance.

### Steps to Implement Pipelining

1. **Breakdown the task** - Analyse the process to identify individual tasks
2. **Arrange in sequential order** - Organise tasks where output of one becomes input for the next
3. **Allow multiple tasks to operate simultaneously** - Don't wait for one task to complete before starting the next

### Pipelining in Programming

In languages like Python and Java, pipelining is **chaining multiple instructions together**.

**Python Example**:
```python
list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
squared = [x**2 for x in list]
filtered = [x for x in squared if x % 2 == 0]
print(filtered)  # Output: [4, 16, 36, 64, 100]
```

**Unix Example** (using the `|` pipe symbol):
```bash
grep "hello" docs | grep "world"
```
- First command searches for lines containing "hello" in files named 'docs'
- Pipe `|` connects output of first command to input of second
- Second command searches filtered results for lines containing "world"

### Key Points

- Commands in a pipeline are separated
- Data flows left to right
- Result from one process feeds into the next

---

## Visualisation for Problem Solving

### What is Visualisation?

**Visualisation** is when data or concepts are presented in simpler form for humans to understand. It creates graphical or visual representations to understand complex systems or data.

### Benefits and Drawbacks

| Benefits | Drawbacks |
|----------|-----------|
| Simplifies concepts for human understanding | Cannot explain why something is the way it is |
| Easier to spot new trends and patterns | Different people may interpret visualisations differently |
| Helps programmers understand problems in current systems | Presentation method can impact understanding |

### Types of Visualisation

**Flowcharts**:
- Diagrams representing workflows or processes
- Help map out each step
- Make it easier to predict outcomes
- Useful for complex user journeys (e.g., checkout processes)

**UML Diagrams** (Unified Modeling Language):
- Provide a standard way to visualise system architecture
- Useful for understanding how classes and objects interact

**Wireframes**:
- Low-fidelity design plans representing skeletal framework
- Help with layout planning and user experience design
- Used for programs or websites

---

## Exam Tips

- When identifying computational problems, consider whether an algorithm could solve it or if human judgement is required
- Remember the three steps of divide and conquer: **Divide**, **Conquer**, **Combine**
- Backtracking is suitable for **logic problems**, not strategic ones
- Heuristics prioritise **speed over accuracy** - solutions are 'good enough' not optimal
- Data mining requires both **powerful computers** and **GDPR compliance**
- Performance modelling is only as accurate as the **input data**
- In pipelining, the result of one process **feeds into the next**
