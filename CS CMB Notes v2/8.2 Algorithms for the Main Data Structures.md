# 8.2 Algorithms for the Main Data Structures

## Overview

Algorithms and data structures are closely linked. Each data structure has its own associated algorithms that allow data to be manipulated in useful ways.

---

## Stacks

A **stack** is a **First In, Last Out (FILO)** data structure. Stacks are often **implemented as an array** and use a **single pointer** called the **top pointer**, which points to the element currently at the top of the stack.

The **top pointer is initialised at -1** because the first element occupies position 0. Initialising at 0 would incorrectly suggest an element exists when the stack is empty.

### Stack Operations

| Operation | Name | Description |
|-----------|------|-------------|
| Check size | `size()` | Returns number of elements |
| Check if empty | `isEmpty()` | Returns True if empty |
| Return top element (without removing) | `peek()` | Views top element |
| Add to stack | `push(element)` | Adds element to top |
| Remove top element and return it | `pop()` | Removes and returns top element |

### Stack Algorithm Implementations

**size()**
```
size()
    return top + 1
```

**isEmpty()**
```
isEmpty()
    if top < 0:
        return True
    else:
        return False
    endif
```

**peek()**
```
peek()
    if isEmpty():
        return error
    else:
        return A[top]
    endif
```
*Note: Always check the stack is not empty before attempting to return data.*

**push(element)**
```
push(element)
    top += 1
    A[top] = element
```
*The top pointer is incremented first, then the element is inserted at that position.*

**pop()**
```
pop()
    if isEmpty():
        return error
    else:
        toRemove = A[top]
        A[top] = ""
        top -= 1
        return toRemove
    endif
```
*The element is recorded, removed, and the top pointer is decremented before returning the removed item.*

---

## Queues

A **queue** is a **First In, First Out (FIFO)** data structure. Like stacks, queues are often represented as arrays. However, queues use **two pointers**: **front** and **back**.

- **Front** holds the position of the first element
- **Back** stores the **next available space**

### Queue Operations

| Operation | Name | Description |
|-----------|------|-------------|
| Check size | `size()` | Returns number of elements |
| Check if empty | `isEmpty()` | Returns True if empty |
| Return front element (without removing) | `peek()` | Views front element |
| Add to queue | `enqueue(element)` | Adds element to back |
| Remove front element and return it | `dequeue()` | Removes and returns front element |

### Queue Algorithm Implementations

**size()**
```
size()
    return back - front
```

**isEmpty()**
```
isEmpty()
    if front == back:
        return True
    else:
        return False
    endif
```
*When a queue is empty, front and back point to the same position.*

**peek()**
```
peek()
    return A[front]
```

**enqueue(element)**
```
enqueue(element)
    A[back] = element
    back += 1
```
*The element is placed at the back pointer position, then back is incremented.*

**dequeue()**
```
dequeue()
    if isEmpty():
        return error
    else:
        toDequeue = A[front]
        A[front] = ""
        front += 1
        return toDequeue
```
*Items are removed from the front pointer position. Always check the queue is not empty first.*

---

## Linked Lists

A **linked list** is composed of **nodes**, each of which has a **pointer to the next item** in the list.

- If a node is referred to as N, the next node is accessed using **N.next**
- The first item is called the **head**
- The last item is called the **tail**

**Searching a linked list** is performed using a **linear search**, carried out by sequential `next` operations until the desired element is found.

---

## Trees

Trees are formed from **nodes** and **edges**. They **cannot contain cycles** and are **not directed**. Trees are useful because they can be **traversed**.

There are two types of traversal required:
- **Depth-first (post-order)**
- **Breadth-first**

Both traversals can be implemented **recursively** and differ only in the order nodes are visited.

---

## Tree Traversal

### Depth-First (Post-Order) Traversal

Depth-first search goes **as far down into the tree as possible** before backtracking. The algorithm uses a **stack**.

**Process:**
1. Go to the **left child node** when possible
2. If no left child, go to the **right child**
3. If no child nodes, **visit** the current node (output its value)
4. **Backtrack** to the next node on the stack and move right
5. A node is only output after **all its children have been visited**

**Visual Method:** Draw a line around the tree. For post-order, **output nodes as the line passes on the right side**.

**Example Tree:**
```
        5
       / \
      3   8
     / \
    2   4
```

**Post-order traversal result:** 2, 4, 3, 8, 5

*Note: Pre-order (output on left) and in-order (output underneath) traversals exist but are not required for the exam.*

### Breadth-First Traversal

Breadth-first visits **all children** of the start node first, then visits all nodes **directly connected** to each of those nodes in turn. Unlike depth-first (which uses a stack), breadth-first uses a **queue**.

**Process:**
1. Visit the start node immediately
2. Visit all children from left to right
3. Move to the next level and repeat
4. Continue until every node has been visited

**Example Tree:**
```
        5
       / \
      3   8
     / \
    2   4
```

**Breadth-first traversal result:** 5, 3, 8, 2, 4

---

## Comparison: Depth-First vs Breadth-First

| Aspect | Depth-First (Post-Order) | Breadth-First |
|--------|--------------------------|---------------|
| Data structure used | Stack | Queue |
| Strategy | Goes deep before backtracking | Visits level by level |
| Visit order | Children visited before parent | Parent visited before children |
| Memory usage | Lower for deep, narrow trees | Lower for wide, shallow trees |

---

## Key Terminology Summary

| Term | Definition |
|------|------------|
| FILO | First In, Last Out (stack behaviour) |
| FIFO | First In, First Out (queue behaviour) |
| Top pointer | Points to the current top element in a stack |
| Front pointer | Points to the first element in a queue |
| Back pointer | Points to the next available space in a queue |
| Head | First item in a linked list |
| Tail | Last item in a linked list |
| Node | A data element in a linked list or tree |
| Edge | A connection between nodes in a tree |

---

## Exam Tips

- Always check for **empty/full conditions** before performing operations on stacks and queues
- Remember stack top pointer starts at **-1**, not 0
- For queues, **back - front = size** (not back - front + 1)
- When tracing stack/queue operations, draw the data structure state after each operation
- For tree traversals, use the **line-drawing method** to verify your answer
- Depth-first uses a **stack**; breadth-first uses a **queue** (remember: DFS = stack, BFS = queue)
