# 2.1 Systems Software

## Operating Systems

An **operating system (OS)** is a collection of programs that work together to provide an **interface between the user and computer hardware**. It manages hardware and software resources, enabling users to interact with the system and run applications.

**Examples**: Windows, macOS, Linux, Ubuntu (desktop); iOS, Android (mobile)

### Functions of an Operating System

- **Memory management** — allocation and deallocation of RAM using paging, segmentation, and virtual memory
- **Resource management** — scheduling CPU time fairly between processes
- **File management** — storage, retrieval, moving, editing, and deleting files and folders
- **Input/Output management** — communication with hardware via device drivers
- **Interrupt handling** — responding to signals requiring immediate processor attention
- **Security** — firewall, user accounts, password protection, file encryption, virus scanning
- **Providing a user interface** — GUI (graphical) or CLI (command-line)
- **Providing utilities** — disk defragmenter, backup, file compression, disk cleanup, file encryption
- **Providing a platform for software** — allowing applications access to system resources

---

## Memory Management

**Memory management** is a fundamental OS role dealing with the **allocation and deallocation** of primary memory (RAM). It ensures multiple programs can run efficiently and securely by preventing programs from accessing memory reserved for other programs.

### Paging

**Paging** divides memory into **fixed-size blocks** called **pages**. Programs are split into equally-sized pages that can be **swapped between main memory and the hard disk** as needed.

- Facilitates efficient memory management and enables virtual memory
- **Drawback**: Can cause **internal fragmentation** — wasted space within pages when data doesn't fill a complete page

**Example**: A 200KB file divided into four 64KB pages leaves 56KB unused in the final page.

### Segmentation

**Segmentation** divides memory into **variable-sized blocks** called **segments** based on the **logical structure of the program** (e.g., loops, conditional statements, functions).

- Segments match the logical flow of code — more intuitive memory access
- Space-efficient as segments are sized according to actual data requirements
- **Drawback**: Can cause **external fragmentation** — gaps between segments reduce available contiguous memory over time

### Virtual Memory

**Virtual memory** uses a section of the **hard drive to act as an extension of RAM** when main memory is insufficient. Sections of programs not currently in use are temporarily moved to virtual memory, freeing RAM for active programs.

- Creates an **illusion of larger memory** and enables continued multitasking
- **Drawback**: Accessing virtual memory is **considerably slower** than RAM (even SSDs are slower than RAM)
- Over-reliance can cause **performance degradation**

### Disk Thrashing

**Disk thrashing** occurs when pages are **swapped too frequently** between main memory and the hard disk. The system spends more time transferring pages than executing programs, causing the computer to "freeze". This problem worsens as virtual memory fills up.

---

## Interrupts

An **interrupt** is a **signal generated by software or hardware** to indicate to the processor that a process needs immediate attention. Interrupts have different **priorities** which the OS must consider when allocating processor time.

### Types of Interrupts

| Type | Description | Examples |
|------|-------------|----------|
| **Hardware interrupts** | Generated by external devices | Keyboard input, mouse movements, disk I/O requests, printer completion, power failure |
| **Software interrupts** | Triggered by software or the OS | Application file requests, division by zero errors |
| **Trap interrupts** | Intentionally triggered by a program | Software debugging, handling unexpected errors |

### Interrupt Handling

Interrupts are stored in order of priority in a **priority queue** within a special **interrupt register**.

### Interrupt Service Routine (ISR)

The **Interrupt Service Routine** is a special function that handles a particular interrupt type. Each interrupt type has a corresponding routine.

**The Interrupt Process:**

1. **Interrupt Request (IRQ)** — A device or software generates an interrupt signal
2. **Interrupt Acknowledge** — The processor checks the interrupt register at the **end of each Fetch-Decode-Execute cycle**
3. If the interrupt has **higher priority** than the current process:
   - Current contents of CPU registers are **saved to a stack**
   - A **flag is set** to indicate ISR has begun
4. **ISR Lookup** — The processor fetches the appropriate ISR for that interrupt type
5. **ISR Execution** — The ISR is loaded into RAM and executed
6. **Interrupt Exit** — Once serviced:
   - The flag is reset
   - The interrupt queue is checked for more high-priority interrupts
   - If none, register contents are **restored from the stack**
   - The Fetch-Decode-Execute cycle resumes

### Interrupt Priority and Nesting

- **Interrupt prioritisation** allows the processor to switch to resolving higher-priority interrupts
- Lower-priority ISRs may be **temporarily suspended** until higher-priority ISRs complete
- **Nesting** refers to handling interrupts within interrupts — proper management avoids conflicts and ensures system stability

---

## Scheduling

**Scheduling** ensures all processes (jobs) receive a **fair amount of processing time**. The OS implements various **scheduling algorithms** to decide which tasks to process, for how long, and in what order.

### Pre-emptive vs Non-pre-emptive

| Category | Description | Examples |
|----------|-------------|----------|
| **Pre-emptive** | Jobs are actively started and stopped by the OS; allocated CPU for **time-limited slots** | Round Robin, Shortest Remaining Time, Multi-level Feedback Queues |
| **Non-pre-emptive** | Once started, a job runs until completion or enters a waiting state; **unlimited time slots** | First Come First Served, Shortest Job First |

### Scheduling Algorithms

#### Round Robin (RR)

- **Pre-emptive** algorithm distributing processor time equally
- Each job receives a **time slice/quantum** to execute
- If incomplete, the job moves to the **back of the queue**
- **Advantage**: Every job gets CPU time (fair)
- **Disadvantages**: Longer jobs take much longer overall; does not consider priority; choosing optimal time quantum is difficult

#### First Come First Served (FCFS)

- **Non-pre-emptive** — jobs processed in the order they arrive
- Current job blocks all others until complete
- **Advantage**: Simple to implement and understand
- **Disadvantages**: Does not allocate based on priority; poor performance if long jobs arrive before short ones

#### Multi-level Feedback Queues (MLFQ)

- **Pre-emptive** priority algorithm using **multiple queues** ordered by different priorities
- Shorter/more critical tasks are processed first
- Jobs that exceed their time quantum **trickle down** to lower-priority queues
- **Advantage**: Prioritises smaller tasks; groups similar-sized tasks together
- **Disadvantage**: Complex to implement; difficult to set correct parameters

#### Shortest Job First (SJF)

- **Non-pre-emptive** — queue ordered by **time required for completion** (shortest first)
- Suited to **batch systems** where minimising waiting time is important
- **Advantage**: Minimises average waiting time; efficient for short processes
- **Disadvantages**: Requires knowing/calculating job duration in advance; risk of **processor starvation** for long jobs if short jobs keep arriving

#### Shortest Remaining Time (SRT)

- **Pre-emptive** version of SJF — queue ordered by **time left for completion**
- Jobs with least remaining time are prioritised
- Before each cycle, processes are re-ordered by shortest remaining time
- **Advantage**: Ideal for short burst times; aligns well with CPU time quantum
- **Disadvantage**: Requires knowing burst times; high context switching overhead; risk of **processor starvation** for longer jobs

### Processor Starvation

**Processor starvation** occurs when a process does not receive enough processor time to execute and complete — a risk with priority-based algorithms when high-priority jobs continuously arrive.

---

## Types of Operating System

| Type | Description | Use Cases |
|------|-------------|-----------|
| **Distributed** | Runs across **multiple devices**, allowing load to be spread across multiple processors | Task distribution, load balancing, big data processing (e.g., Hadoop) |
| **Embedded** | Performs a **small range of specific tasks** for a particular device; limited functionality; low power consumption; hard to update | Consumer appliances (microwaves, washing machines), in-car systems, IoT devices |
| **Multi-tasking** | Enables users to run **multiple tasks seemingly simultaneously** using **time slicing** to switch quickly between programs | Desktop/laptop computers (Windows, macOS, Linux) |
| **Multi-user** | Multiple users access **one computer** (often a supercomputer) concurrently; requires scheduling to share processor time fairly; provides data security and user privacy | Servers, mainframes, shared computing resources |
| **Real-Time** | Performs tasks within a **guaranteed time frame**; used in **time-critical systems** where response within a certain period is crucial to safety | Nuclear power station control, self-driving cars, aerospace, automotive systems |

---

## BIOS

The **Basic Input Output System (BIOS)** is **firmware** stored on a memory chip on the motherboard. It is the **first program to run** when a computer is switched on.

### BIOS Functions

1. **POST (Power-On Self-Test)** — diagnostic testing to ensure all hardware (keyboard, disk drives, etc.) is correctly connected and functional
2. **Checks CPU clock, memory, and processor** are operational
3. **Tests for external memory devices** connected to the computer
4. If all tests pass, runs the **Bootstrap/Bootloader** — the program that loads the OS from the hard disk into RAM

The **Program Counter register** points to the location of the BIOS on startup. The OS can only be loaded into RAM after BIOS checks are completed.

---

## Device Drivers

A **device driver** is software that enables **communication between the operating system and specific hardware** (printers, graphics cards, network cards, keyboards, etc.).

- Allows the OS to **control and interact** with hardware devices
- **Bridges the gap** between a major OS and embedded hardware systems
- Enables specific operations (e.g., a printer driver sends print commands and manages print jobs)
- **Specific to**:
  - The **computer's architecture** (different drivers for smartphones, PCs, games consoles)
  - The **operating system** installed on the device
- Hardware manufacturers typically write their own drivers — a single OS may have multiple drivers for the same device type

**Example**: When a keyboard key is pressed, the device driver communicates this to the OS, which then displays the corresponding letter on screen.

Device drivers are an example of **abstraction** — users interact with hardware without needing to understand the underlying implementation.

---

## Virtual Machines

A **virtual machine (VM)** is a **software implementation of a computer system** — a "theoretical computer" that runs within a physical machine. It mimics a complete computer system including virtual CPU, memory, storage, and network interface.

- A physical machine can run **multiple VMs** using **hypervisor software**
- Each VM behaves as a separate system with its own **independent OS and applications**
- Provides an environment with a **translator for intermediate code** to run

### Intermediate Code

**Intermediate code** (e.g., Java bytecode) is code that is **between high-level source code and machine code**. It is **independent of processor architecture**, allowing the same program to run across different machines and operating systems.

- Generated through compilation
- Executed by a virtual machine (e.g., Java Virtual Machine)
- Enables **cross-platform compatibility**

### Uses of Virtual Machines

- **Software testing** — creates isolated test environments separate from the host OS; allows testing across multiple OS versions and hardware configurations without risking the host system
- **Cross-platform compatibility** — run software designed for different operating systems (e.g., macOS apps on Windows)
- **Legacy support** — run older OS versions for outdated applications that haven't received forward-compatibility updates
- **Protection from malware** — malware affects the VM rather than the host device
- **Running incompatible software** — programs specific to different OS versions can run within a VM (e.g., games console emulators)

### Advantages and Disadvantages

| Advantages | Disadvantages |
|------------|---------------|
| Cross-platform software execution | Uses host system resources (CPU, RAM, storage) |
| Supports legacy applications | Performance slower than running directly on hardware |
| Isolated test environments | Can be complex to set up and manage |
| Enables intermediate code execution | May require additional OS licences |
| Multiple VMs on single hardware | Resource limits can cause crashes/lag if poorly configured |
| Easy reset/rollback using snapshots | Not all hardware features can be virtualised accurately |
| Saves time and money vs buying multiple physical devices | |

### Resource Considerations

- VMs **share hardware resources** with the host OS
- Over-use can **exhaust** CPU, hard disk, and memory
- VM management software (e.g., VirtualBox) can set **maximum resource limits**
- Intermediate code in a VM runs **considerably slower** than low-level code on native hardware
