# 2.2 Applications Generation

## Nature of Applications

Software is categorised as either **applications software** or **systems software**.

### Applications Software

**Applications software** is designed for end-users to perform specific tasks. It requires systems software to run.

**Examples**: word processors, spreadsheets, web browsers, database management systems, graphics manipulation software, presentation software, video editing software, IDEs, email clients.

| Type | Purpose | Examples |
|------|---------|----------|
| Word Processor | Creating, editing, formatting and printing text documents | Microsoft Word, Google Docs |
| Database Management Software | Storing, retrieving, manipulating and managing data | MySQL, Oracle |
| Web Browser | Browsing the web and accessing online information | Chrome, Firefox |
| Spreadsheet Software | Organising, calculating and analysing numerical data | Excel, Google Sheets |
| Graphics Manipulation | Editing images, photos and graphic designs | Adobe Photoshop, GIMP |
| Presentation Software | Creating visual and multimedia presentations | PowerPoint, Keynote |
| IDE | Developing, testing and debugging software code | Visual Studio, IntelliJ IDEA |

### Systems Software

**Systems software** is low-level software responsible for running the computer system smoothly, interacting with hardware, and providing a platform for applications software. Users do not directly interact with it.

**Examples**: operating systems, utility programs, device drivers, library programs.

---

## Utilities

**Utility software** is system software designed to analyse, configure, optimise, or maintain a computer. Each utility has a specific function linked to operating system maintenance.

| Utility | Purpose | How It Works |
|---------|---------|--------------|
| **Compression** | Reduce file sizes for transmission/storage | Compresses and decompresses files (e.g., for sending over the Internet) |
| **Disk Defragmentation** | Improve hard disk read/write performance | Rearranges fragmented files into contiguous blocks so they can be accessed faster |
| **Antivirus** | Protect against malware | Detects potential threats, alerts the user, and removes malicious software |
| **Automatic Updating** | Keep OS secure and bug-free | Automatically installs updates when the computer restarts, addressing security flaws |
| **Backup** | Prevent data loss | Creates routine copies of user-specified files at specified intervals |
| **File Management** | Organise files on the system | Creating, deleting, moving, renaming files and folders (e.g., Windows Explorer) |
| **System Cleanup** | Free up disk space | Removes temporary files, cache, unused applications and other unnecessary data |
| **Device Drivers** | Interface between hardware and OS | Enables OS and programs to communicate with hardware without needing precise hardware details |

**Note**: SSDs generally do not require defragmentation.

---

## Open Source vs Closed Source

**Source code** is the code written by a programmer before compilation. Software is described as open or closed source based on whether the source code is publicly accessible.

### Comparison Table

| Aspect | Open Source | Closed Source |
|--------|-------------|---------------|
| **Definition** | Source code freely available, can be modified and redistributed | Source code proprietary; users need a licence; cannot access source code |
| **Cost** | Often free | Requires purchase/licence |
| **Modification** | Can be modified and improved by anyone | Users cannot modify the software |
| **Support** | Community support; may be insufficient or incorrect; no official manuals | Professional support and user manuals from the company |
| **Security** | Potentially lower security (developed in uncontrolled environments) | Higher security (developed professionally in controlled environments) |
| **Updates** | Community-driven; variable quality | Thorough, regular, well-tested updates |
| **Control** | Less control for creator; user requests can be burdensome | Greater control; revenue through sales; IP protection |

### Choosing Between Open and Closed Source

Consider:
- **Costs**: implementation, maintenance, training, licensing
- **Functionality**: features available, ease of use
- **Suitability**: match software to the specific task requirements

---

## Translators

A **translator** converts high-level source code into low-level object code (machine code) that can be executed by a computer. There are three types: **compilers**, **interpreters**, and **assemblers**.

### Compiler

- Translates **entire source code into machine code all at once**
- Performs checks and reports all errors after compilation
- **Initial compilation is slower** than interpreting
- If changes are made, the **whole program must be recompiled**
- Compiled code is **specific to a particular processor and OS**
- Code can run **without the translator present**
- **Faster execution** once compiled (no translation at runtime)
- Harder to debug (errors reported after full compilation)

### Interpreter

- Translates and **executes code line-by-line**
- **Stops immediately** when an error is encountered
- **Appears faster initially** as code executes immediately
- **Slower overall** — code is re-translated every time it runs
- **Useful for testing and debugging** — pinpoints errors quickly without compiling the entire program
- **Requires the interpreter** to be present on the device to run
- Code is **more portable** — can run on any platform with the correct interpreter

### Assembler

- Translates **assembly language into machine code**
- Assembly code is a **low-level language** — the "next level up" from machine code
- Assembly code is **platform-specific** (dependent on the processor's instruction set)
- Translation is on an **almost one-to-one basis** (each assembly instruction ≈ one machine code instruction)

### Translator Comparison Summary

| Feature | Compiler | Interpreter | Assembler |
|---------|----------|-------------|-----------|
| Input | High-level code | High-level code | Assembly code |
| Output | Machine code (executable) | Executes directly | Machine code |
| Translation | All at once | Line-by-line | One-to-one |
| Execution speed | Fast (after compilation) | Slower (translates each run) | Fast |
| Error detection | After full compilation | Immediately on error line | After assembly |
| Portability | Platform-specific | More portable | Platform-specific |
| Translator needed at runtime | No | Yes | No |

---

## Stages of Compilation

Compilation involves **four stages** to convert high-level source code into executable object code.

### 1. Lexical Analysis

**Purpose**: Break code into tokens and prepare for syntax analysis.

**Process**:
1. **Removes whitespace and comments** from the source code
2. Analyses remaining code for **keywords**, **identifiers**, **operators**, and **separators**
3. Replaces these with **tokens**
4. Stores information about each token in a **symbol table**

**Token types**:
- **Keywords**: `var`, `const`, `function`, `for`, `while`, `if`, `return`
- **Identifiers**: variable names, function names
- **Operators**: `+`, `-`, `*`, `/`, `=`, `>`, `<`
- **Separators/Delimiters**: `,`, `;`, `{`, `}`, `(`, `)`

**Output**: Token table and symbol table

### 2. Syntax Analysis

**Purpose**: Check tokens against the grammar rules of the programming language.

**Process**:
1. Tokens are **analysed against the rules** of the programming language
2. Any tokens breaking the rules are **flagged as syntax errors** and added to an error list
3. If no errors, an **Abstract Syntax Tree (AST)** is produced — a tree-based representation of the source code
4. Further details about identifiers are added to the **symbol table**

**Parsing**: The process of checking each line of code is well-formed.

**Syntax errors** (examples): undeclared variable type, incomplete/mismatched brackets, missing semicolons

**Semantic analysis** also occurs at this stage — detecting **logic errors** in the program.

**Semantic errors** (examples): multiple declaration of the same identifier, use of undeclared identifiers

### 3. Code Generation

**Purpose**: Convert the AST into machine code.

**Process**:
- The **Abstract Syntax Tree is traversed** to generate **object code** (machine code) that can be executed by the computer

### 4. Optimisation

**Purpose**: Make code more efficient without changing functionality.

**Process**:
1. Searches through code for areas that could be **made more efficient**
2. Removes **redundant/insignificant code**
3. Groups **repeated sections** and replaces them with more efficient equivalents
4. Aims to make code **faster to execute** and **use less memory**

**Trade-offs**:
- Optimisation **adds to overall compilation time**
- **Excessive optimisation** may alter program behaviour

---

## Linkers, Loaders and Libraries

Most programs use external code including **subroutines** and **libraries** from outside sources.

### Libraries

**Libraries** are **pre-compiled programs** containing reusable functions and procedures that can be incorporated into other programs.

**Benefits**:
- **Ready-to-use and error-free** — saves development and testing time
- **Reusable** across multiple programs
- Provide **specialised functions** (e.g., mathematical, graphical) that would otherwise require significant effort to develop
- Programmers don't need to "reinvent the wheel"
- Often **well-tested and optimised**
- Strong **community support and documentation** for popular libraries

**Drawbacks**:
- **Dependency issues** — problems if library is discontinued or unmaintained
- **Compatibility issues** with different versions
- **Overhead** — using a large library for a small task adds unnecessary complexity

### Linkers

A **linker** is software responsible for **linking external modules and libraries** into the compiled code.

**Two types of linking**:

| Type | How It Works | Advantages | Disadvantages |
|------|--------------|------------|---------------|
| **Static Linking** | Modules/libraries are **added directly into the main file** at compile time | Specific library version can be used; no external dependencies at runtime | Increases file size; external updates don't affect the program |
| **Dynamic Linking** | **Addresses of modules/libraries** are included; retrieved at runtime | Files remain small; external updates automatically feed through; no need to rewrite code | Requires library to be present at runtime |

### Loaders

**Loaders** are programs provided by the operating system. When a file is executed, the loader **retrieves the library or subroutine from the specified memory location** so it can be executed.

### Summary: How They Work Together

1. **Libraries** provide pre-written, tested code
2. **Linkers** combine object files and libraries into a single executable (either statically or dynamically)
3. **Loaders** load the executable into memory for execution, retrieving any dynamically linked libraries as needed

---

## Key Definitions Summary

| Term | Definition |
|------|------------|
| **Applications software** | Software designed for end-users to perform specific tasks |
| **Systems software** | Low-level software that runs the computer system and provides a platform for applications |
| **Utility software** | System software that analyses, configures, optimises, or maintains the computer |
| **Open source** | Software where source code is freely available to view, modify, and distribute |
| **Closed source** | Proprietary software where source code is hidden and requires a licence to use |
| **Translator** | Program that converts source code to object code |
| **Compiler** | Translates entire high-level code into machine code at once |
| **Interpreter** | Translates and executes high-level code line-by-line |
| **Assembler** | Translates assembly language into machine code |
| **Lexical analysis** | First compilation stage — removes whitespace/comments, creates tokens and symbol table |
| **Syntax analysis** | Second stage — checks tokens against language rules, produces AST |
| **Code generation** | Third stage — converts AST to machine code |
| **Optimisation** | Fourth stage — improves code efficiency |
| **Library** | Pre-compiled, reusable code modules |
| **Linker** | Combines object files and libraries into an executable |
| **Loader** | Loads executable into memory for execution |
| **Static linking** | Libraries added directly to executable at compile time |
| **Dynamic linking** | Library addresses included; retrieved at runtime |
| **Abstract Syntax Tree** | Tree-based representation of source code structure |
| **Symbol table** | Data structure storing information about identifiers and tokens |
