# 2.3 Software Development

## Software Development Life Cycles (SDLCs)

Software can be developed using various approaches. The chosen methodology depends on the type of software being developed, but most **software development life cycles (SDLCs)** share common stages.

### Common SDLC Stages

**Analysis**: **Stakeholders** state their requirements for the finished product. This information is used to clearly define the problem and the **system requirements**. Requirements are defined by analysing strengths and weaknesses of current solutions, and considering data types including inputs, outputs, stored data, and data volumes.

**Design**: Different aspects of the new system are designed, including inputs (volume, methods, frequency), outputs (volume, methods, frequency), security features (level required, access levels), hardware setup (compatibility), and user interface (menus, accessibility, navigation). A **test plan** may also be designed at this stage.

**Development**: The design is used to split the project into **individual, self-contained modules**, which are allocated to teams for programming.

**Testing**: The program is tested against the test plan. Types of testing include:

- **Alpha testing**: Carried out **in-house** by software development teams. Bugs are identified and fixed.
- **Beta testing**: Carried out by **end-users** after alpha testing. User feedback informs the next development stage.
- **White box testing**: Carried out by developers where the test plan is based on the **internal structure** of the program. **All possible routes** through the program are tested.
- **Black box testing**: Software is tested **without testers knowing the internal structure**. Can be carried out in-house or by end-users. The test plan traces **inputs and outputs**.

**Implementation**: Once testing is complete and changes made, software is installed onto users' systems.

**Evaluation**: The software's effectiveness is evaluated against the system requirements defined at analysis. Criteria include **robustness**, **reliability**, **portability**, and **maintainability**.

**Maintenance**: End-users flag errors or improvements. Programmers send **software updates** to fix bugs, security issues, or make improvements.

---

## Waterfall Lifecycle

The **waterfall model** is a traditional, well-defined approach based on stages **completed in sequence** from start to finish. Each phase must be completed before the next begins.

### Stages

1. **Requirement Gathering and Analysis**: All system requirements captured and documented
2. **System Design**: Requirements translated into design; architecture and main components defined
3. **Implementation**: Code written based on design documents
4. **Integration and Testing**: Components integrated and tested as a complete system
5. **Deployment**: Product released to market or client (installation, customisation, training)
6. **Maintenance**: Regular maintenance to fix bugs, improve performance, or add features

### Feasibility Study (TELOS)

The analysis stage includes a **feasibility study** evaluating project viability:

- **Technical**: Is the project possible given available technology?
- **Economic**: Can the project be financed short-term and long-term?
- **Legal**: Can the project be completed within the law?
- **Operational**: Can the project be successfully implemented and maintained?
- **Scheduling**: Can the project be completed in the available time?

### Characteristics

If changes are needed, programmers must **revisit all levels** between the current stage and the stage requiring change. This makes the model **inflexible** and unsuitable for projects with changing requirements. Users have **limited input** as they are only involved at the beginning (analysis) and end (evaluation).

### Benefits

- Simple and linear — easy to understand and follow
- Clear stages and milestones — progress easy to measure
- Suitable for **well-defined projects** with stable requirements
- Clearly documented

### Drawbacks

- **Lack of flexibility** — changes difficult once started
- **No risk analysis**
- **Limited user involvement**
- **Expensive to fix late problems**
- Long development cycle

### Suitable For

Static, low-risk projects with well-understood requirements that are unlikely to change (e.g., general-purpose software).

---

## Agile Methodologies

**Agile** refers to a collection of methodologies aimed at improving the **flexibility** of software development and adapting to changes in user requirements faster.

### Key Characteristics

- Problem **broken down into sections** developed **in parallel**
- Design and analysis phases often occur together
- Different sections can be at **different stages of development**
- **Working prototype delivered early** and built upon **iteratively**
- New prototypes delivered regularly throughout the development cycle
- **Less focus on documentation**, more priority on **user satisfaction**

### Agile Process (Sprint-Based)

1. **Identify user stories and requirements**: Work with stakeholders to gather functional and non-functional requirements, often written as **user stories** (e.g., "As a user, I want to...")
2. **Sprint Planning**: Break requirements into tasks, choose features for the current **sprint** (1-4 weeks), define sprint goal
3. **Design**: Decide how features will be built — focus on **simple and adaptable design**
4. **Development**: Write code for selected tasks, often using **pair programming**
5. **Testing**: Continuous **unit testing**, **integration testing**, and **acceptance testing** during sprint
6. **Sprint Review**: Demo working software to stakeholders, collect feedback
7. **Sprint Retrospective**: Team reflects on process and identifies improvements
8. **Release**: Deploy working software
9. **Repeat**: Move to next sprint with updated priorities

### Benefits

- Produces **high quality code**
- **Flexible** to changing requirements
- **Regular user input**
- Highly adaptable — can respond to changes even late in development
- Frequent communication between team and stakeholders
- Quality focus with continuous testing

### Drawbacks

- **Poor documentation**
- Requires **consistent interaction** between user and programmer
- Requires experienced team members
- Intensive collaboration can lead to burnout
- **Scope creep** — flexible nature may lead to uncontrolled requirement changes

### Suitable For

Small to medium projects with unclear initial requirements where customer involvement is high.

---

## Extreme Programming (XP)

**Extreme programming** is an agile model where the development team consists of a **pair of programmers alongside a representative end-user**.

### Key Features

- Built on **user stories**: System requirements specified by end-user and used in design
- **Paired programming**: Code written by one person, critiqued by another — produces **high-quality code** as it's improved while written
- Programmers work **no longer than 40 hours per week** to maintain quality
- Each iteration generates a **working version** that could function as the final product
- Effective communication between programmers is essential

### Benefits

- Produces high quality code
- **Constant user involvement** ensures high usability

### Drawbacks

- **High cost** of two people working on one project
- **Teamwork essential** — requires effective communication
- End-user may not always be able to be present
- Hard to produce high quality documentation due to iterative nature

### Suitable For

Small to medium projects with unclear initial requirements requiring excellent usability.

---

## Spiral Model

The **spiral model** combines aspects of both **iterative (agile)** and **sequential (waterfall)** processes, with a focus on effectively managing **risk-heavy projects**.

### Four Key Stages (Repeated Cyclically)

1. **Planning**: Define objectives, alternatives, and constraints for current phase
2. **Risk Analysis**: Identify and assess potential risks; plan **mitigation strategies**
3. **Engineering**: Develop next version — design, coding, testing, integration
4. **Evaluation and Feedback**: Review progress with stakeholders; plan next iteration

Each spiral loop represents a development phase until the final product is ready.

### Key Characteristic

If the project is found to be **too risky** at any point, the project is **terminated**.

### Benefits

- **Thorough risk-analysis and mitigation**
- Caters to changing user needs
- **Produces prototypes throughout**
- Flexibility — allows changes at various stages
- Strong customer involvement
- Incremental releases — early partial working solutions

### Drawbacks

- **Expensive** to hire risk assessors
- **Lack of focus on code efficiency**
- High costs due to constant prototyping
- Complex and harder to manage
- Time-consuming
- Not suitable for small projects

### Suitable For

Large, risk-intensive projects with a high budget where requirements may change and risk management is essential.

---

## Rapid Application Development (RAD)

**RAD** is an **iterative methodology** emphasising **fast and iterative development** using **partially functioning prototypes** that are continually built upon.

### Process

1. **Requirement Planning**: User requirements initially gathered using **focus groups**; define constraints and assumptions
2. **User Design and Prototyping**: Develop an **incomplete version** of the solution; collaborate with users to ensure alignment with needs
3. **Construction**: System built incrementally with continuous **user feedback** and adaptation; generate improved prototypes
4. **Cutover/Deployment**: Transition to live environment (training, support, documentation)
5. **Maintenance**: Continue adapting based on user feedback

The cycle continues until the prototype matches end-user requirements, at which point it becomes the **final product**.

### Benefits

- Caters to **changing user requirements**
- **Highly usable** finished product
- **Focus on core features** — reduces development time
- **Speed** — rapid development at relatively low cost
- User involvement throughout ensures alignment with needs
- Flexible — quick adaptations as requirements evolve

### Drawbacks

- **Poorer quality documentation**
- Fast pace may **reduce code quality**
- Additions and changes to code may be **inefficient** as requirements change
- Dependent on strong team collaboration
- Can lead to scope creep
- Not suitable for small projects (overkill)

### Suitable For

Small to medium, low-budget projects with short timeframes where user requirements are incomplete or unclear at the start, and rapid delivery is required.

---

## Comparing Software Development Models

| Method | Key Processes | Benefits | Drawbacks | Suitable For |
|--------|---------------|----------|-----------|--------------|
| **Waterfall** | Linear stages: Requirements → Design → Coding → Testing → Deployment → Maintenance | Simple, clear stages, well-documented | Inflexible, expensive late changes, long cycle, no risk analysis | Well-defined projects with stable requirements |
| **Agile** | Iterative: Planning → Design → Coding → Testing → Review → Repeat | Flexible, customer involvement, rapid delivery, high quality code | Poor documentation, scope creep, requires collaboration | Fast-paced projects with changing requirements |
| **Extreme Programming** | Pair programming, user stories, 40-hour weeks, working versions | High quality code, constant user involvement, high usability | High cost (two people), teamwork essential, user may not be present | Small-medium projects needing excellent usability |
| **Spiral** | Cyclic: Planning → Risk Analysis → Engineering → Evaluation | Risk management focus, flexible, prototypes throughout | Complex, expensive, expert risk assessment required | Large, complex, high-risk projects with high budget |
| **RAD** | Requirements Planning → User Design → Construction → Cutover | Fast development, user feedback, adaptable, focus on core features | Collaboration dependence, quality issues, poor documentation | Projects requiring quick delivery with active user participation |

---

## Writing and Following Algorithms

An **algorithm** is a **set of instructions used to solve a problem**. They are core to computer science and can tackle a wide range of problems.

### Key Qualities of Good Algorithms

- **Inputs clearly defined** — what is valid and invalid
- Must **always produce a valid output** for any defined input
- Must be able to **deal with invalid inputs**
- Must always reach a **stopping condition**
- Must be **well-documented** for reference
- Must be **well-commented** so modifications can be made easily
