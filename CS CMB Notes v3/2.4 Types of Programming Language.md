# 2.4 Types of Programming Language

## Programming Paradigms

**Programming paradigms** are different approaches to using a programming language to solve a problem. They dictate how programs are structured and developed. Different paradigms suit different tasks.

### Paradigm Categories

Programming paradigms split into two broad categories:

**Imperative** — code clearly specifies the actions to be performed
- **Procedural** — sequence of instructions contained within procedures, executed step-by-step
- **Object-Oriented** — organises code around objects (combining data and functionality)

**Declarative** — focuses on stating the desired result rather than the exact instructions; the language determines how to obtain the result (details abstracted from user)
- **Functional** — programs consist of function calls, often combined within each other; closely linked to mathematics
- **Logic** — defines facts and rules based on the problem; queries find answers

Most programming languages (e.g. Python) allow for more than one paradigm.

### Paradigm Comparison

| Paradigm | Description | Example Languages | Key Concepts |
|----------|-------------|-------------------|--------------|
| Procedural | Subtype of imperative; structured around procedure calls | C, Go, Rust, Pascal, Python, Logo | Procedures, function calls, structured programming |
| Object-Oriented | Organises code around objects rather than functions | Java, C#, Swift, Python, Delphi | Classes, inheritance, polymorphism, encapsulation |
| Functional | Reuses sets of functions; closely linked to mathematics | Haskell, C#, Java | Function calls, mathematical basis |
| Logic | Defines facts and rules; uses queries | Prolog | Facts, rules, queries |
| Assembly | Low-level mnemonic representation of machine code | x86-64, ARMv8 | Registers, mnemonics, memory addresses, opcodes |

### Strengths and Weaknesses

**Procedural**
- Strengths: Efficient execution, clear top-to-bottom control flow, easy to implement algorithms, applied to wide range of problems, easy to write and interpret
- Weaknesses: Unwieldy for large programs, lacks modularity (code redundancy), not ideal for complex states/behaviours, difficult to scale

**Object-Oriented**
- Strengths: High reusability, real-world modelling, code reuse through inheritance, flexibility via polymorphism, encapsulation protects attributes, modular structure easy to maintain and update, classes reusable across projects, high abstraction (black box reuse)
- Weaknesses: Can lead to unnecessary complexity, inefficiency due to overhead, not intuitive for all problems, can create overly complex inheritance hierarchies, requires advance planning, not suited where few components reused, unsuitable for smaller problems

**Assembly**
- Strengths: Direct hardware control, optimised performance, transparent understanding of machine operation, potential for very efficient code, useful for embedded systems
- Weaknesses: Steep learning curve, hardware-specific (lacks portability), tedious and error-prone, difficult to write/debug/maintain large programs

---

## Procedural Programming

**Procedural programming** uses a sequence of step-by-step instructions which may be contained within procedures. It is simple to implement but cannot efficiently solve all types of problems.

Procedural languages use **traditional data types** (integers, strings) and **data structures** (dictionaries, arrays).

### Structured Programming

**Structured programming** is a subsection of procedural programming where control flow is given by four main programming structures:

**Sequence** — code executed line-by-line, from top to bottom

**Selection** — a block of code runs if a specific condition is met (using IF statements)

**Iteration** — a block of code executes a certain number of times or while a condition is met (FOR, WHILE, REPEAT UNTIL loops)

**Recursion** — functions expressed in terms of themselves; functions call themselves until a **base case** (which does not call the function) is met

### Core Programming Concepts

| Concept | Description |
|---------|-------------|
| **Variables** | Store data values that can change |
| **Constants** | Store values that remain unchanged |
| **Selection** | Decision-making constructs (IF/ELSE) |
| **Iteration** | Loops to repeat actions |
| **Sequence** | Executing statements sequentially |
| **Subroutines** | Organising code into reusable parts |
| **String Handling** | Operations on character strings |
| **File Handling** | Reading from and writing to files |
| **Boolean Operators** | Logical operations (AND, OR, NOT) |
| **Arithmetic Operators** | Mathematical operations (+, -, *, /) |

Procedural programming suits problems that can easily be expressed as a series of instructions using these constructs.

---

## Assembly Language

**Assembly language** is part of the family of **low-level languages** — one level above machine code. It is converted to machine code using an **assembler**.

### Key Characteristics

- Uses **mnemonics** (abbreviations for machine code instructions) rather than binary
- Each mnemonic represented by a numeric code
- Commands are **processor-specific** as it directly interacts with CPU's special purpose registers
- Allows **direct interaction with hardware** — useful for embedded systems
- Typically, each instruction is equivalent to almost one line of machine code

### Little Man Computer (LMC)

The **Little Man Computer** is a hypothetical model for understanding fundamental computer operations. It has memory, a calculator, an accumulator, and an instruction set.

### LMC Instruction Set

| Mnemonic | Instruction | Function |
|----------|-------------|----------|
| **ADD** | Add | Add value at given memory address to Accumulator |
| **SUB** | Subtract | Subtract value at given memory address from Accumulator |
| **STA** (or STO) | Store | Store Accumulator value at given memory address |
| **LDA** (or LOAD) | Load | Load value at given memory address into Accumulator |
| **INP** (or IN, INPUT) | Input | User inputs a value held in Accumulator |
| **OUT** | Output | Print value currently in Accumulator |
| **HLT** (or COB, END) | Halt | Stop program, preventing rest of code from executing |
| **DAT** | Data | Create a flag with label at which data is stored |
| **BRZ** (or BZ) | Branch if zero | Branch to given address if Accumulator is zero (conditional) |
| **BRP** (or BP) | Branch if positive | Branch to given address if Accumulator is positive or zero (conditional) |
| **BRA** (or BR) | Branch always | Branch to given address regardless of Accumulator value (unconditional) |

### Example LMC Program — Modulus (Remainder)

```
        INP
        STA num1
        INP
        STA num2
        LDA num1
positive STA num1
        SUB num2
        BRP positive
        LDA num1
        OUT
        HLT
num1    DAT
num2    DAT
```

This repeatedly subtracts num2 from num1 while the result is positive, outputting the remainder.

### Example LMC Program — Add Two Numbers

```
INP
STA 90
INP
ADD 90
OUT
HLT
DAT
```

---

## Modes of Addressing Memory

Machine code instructions consist of two parts:
- **Opcode** — specifies the instruction to be performed
- **Operand** — holds a value related to the data on which the instruction is performed

**Addressing modes** specify how the operand should be interpreted. The addressing mode is part of the opcode. They allow a greater number of memory locations to be accessed than the operand size alone would permit.

### Four Addressing Modes

**Immediate Addressing**
- The operand is the **actual value** upon which the instruction is performed (represented in binary)
- Example: `MOV AX, 1234h` — moves the value 1234h directly to AX register

**Direct Addressing**
- The operand gives the **address which holds the value**
- Used in LMC
- Example: `MOV AX, [1234h]` — moves value stored at memory location 1234h to AX

**Indirect Addressing**
- The operand gives the **address of a register which holds another address** where the data is located
- Example: If BX contains 2000h, `MOV AX, [BX]` moves the value from memory location 2000h to AX
- Brackets [ ] indicate treating the register's value as a memory address

**Indexed Addressing**
- An **index register** stores a value; the address is determined by **adding the operand to the index register**
- Used to add an offset to access **data stored contiguously** in memory (e.g. arrays)
- Example: If BX=0050h and SI=1000h, `MOV AX, [BX + SI]` accesses memory location 1050h

---

## Object-Oriented Programming (OOP)

**Object-oriented programming** is built around **classes** — templates that define the state and behaviour of objects.

### Core OOP Terminology

**Class** — a template for an object; defines state and behaviour; usually associated with an entity

**Object** — a particular instance of a class; created through **instantiation**

**Attributes** — give an object's properties (its state); declared as **private**

**Methods** — describe actions a class can perform (its behaviour)

**Constructor** — a special method (called `new`) that creates a new object

**Getter** — a method that retrieves the value of an attribute

**Setter** — a method that sets the value of an attribute

### Encapsulation

**Encapsulation** ensures attributes cannot be directly accessed and edited by users. Attributes are declared as **private** and can only be altered by **public methods** (getters and setters).

Benefits:
- Makes code more reliable by protecting attributes
- Code for different classes can be produced independently

### Inheritance

**Inheritance** allows a class to inherit from another class.

- **Subclass** (derived class) — possesses all methods and attributes of the superclass and can have additional properties
- **Superclass** (parent class) — the class being inherited from

Syntax: `class Biography inherits Book`

Benefits: Allows programmers to effectively reuse components while making changes.

### Polymorphism

**Polymorphism** means objects can behave differently depending on their class. The same method can produce different outputs depending on the object involved.

Two categories:
- **Overriding** — redefining a method within a subclass so it functions differently and produces different output
- **Overloading** — passing different parameters into a method

### Example Class (Pseudocode)

```
class Book:
    private reserved
    private onLoan
    private author
    private title
    
    public procedure new(title, author, reserved, onLoan)
        title = givenTitle
        author = givenAuthor
        reserved = givenReserved
        onLoan = givenOnLoan
    end procedure
    
    public function set_reserved()
        reserved = True
    end function
end class
```

Creating an object:
```
myBook = new Book('Great Expectations', 'Charles Dickens', 'False', 'False')
```

Calling a method:
```
myBook.set_reserved()
```

### Advantages of OOP

- High level of **reusability** through inheritance and polymorphism
- Classes can be **used across multiple projects**
- **Encapsulation** makes code reliable and allows independent development
- Requires **advance planning** — thorough design produces higher-quality software with fewer vulnerabilities
- **Modular structure** easy to maintain and update
- High level of **abstraction** — classes reused as black boxes, saving time and effort

### Disadvantages of OOP

- Requires **alternative style of thinking** — difficult for programmers accustomed to other paradigms
- **Not suited to all problems** — may result in longer, more inefficient programs where few components are reused
- Generally **unsuitable for smaller problems**
