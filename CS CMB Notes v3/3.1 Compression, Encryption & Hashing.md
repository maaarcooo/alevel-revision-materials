# 3.1 Compression, Encryption & Hashing

## Compression

**Compression** is the process of reducing the storage space required by a file. This allows more files to be stored in the same amount of storage space and enables faster file transfer over networks due to reduced file sizes and lower bandwidth consumption.

### Lossy vs Lossless Compression

| Aspect | Lossy | Lossless |
|--------|-------|----------|
| Data loss | Some data permanently discarded | No data lost |
| File size | Greatly reduced | Larger than lossy |
| Reversibility | Original cannot be recovered | Original can be fully recovered |
| Best for | Media streaming, images, audio where some quality loss is acceptable | Text, archival storage, data requiring integrity |
| Drawbacks | Irreversible quality loss | Requires higher bandwidth for streaming |

**Lossy compression** reduces file size by removing some information permanently. For example, audio files can be compressed by removing very high or very low frequencies that are least noticeable to the human ear.

**Lossless compression** reduces file size without losing any information. The original file can be fully recovered from the compressed version.

**Choosing compression type**: If data integrity is essential, use lossless. If small file size or quick transfer is prioritised and some data loss is acceptable, use lossy.

---

## Lossless Compression Methods

### Run Length Encoding (RLE)

**Run Length Encoding** is a lossless compression method where consecutive repeated values are replaced with one occurrence of the data followed by the number of times it should be repeated.

**Example**: `AAAAAABBBBBCCC` becomes `A6B5C3`

**Effectiveness**: RLE works best when data has lots of consecutive repetition. If there is little repetition, RLE offers minimal file size reduction.

**Application**: Used in bitmap images to compress sequences of the same colour (e.g., 5 red pixels followed by 3 blue pixels = `5R3B`).

### Dictionary Coding (Dictionary Encoding)

**Dictionary coding** is a lossless compression method where frequently occurring sequences are replaced with shorter index codes. The compressed data is stored alongside a **dictionary** that maps each index to its original data.

**Process**:
1. Scan data for recurring sequences
2. Create a dictionary mapping frequent sequences to short indices
3. Replace occurrences with their index values
4. Store compressed data with the dictionary

**Example**:
Original: "We shall fight in France, we shall fight on the seas"

| Index | Phrase |
|-------|--------|
| 1 | We shall |
| 2 | fight |

Compressed: "1 2 in France, 1 2 on the seas"

**Important**: Data compressed using dictionary coding must be transferred alongside its dictionary. Without the dictionary, the data cannot be used.

**Comparison**: RLE is more effective for highly repetitive data; dictionary coding is more versatile but may require more computational resources.

---

## Encryption

**Encryption** converts readable data into an unreadable format to keep it secure during transmission. It uses **keys** (specialised programs) to scramble and unscramble data.

### Symmetric Encryption

**Symmetric encryption** uses a **single shared private key** for both encryption and decryption. Both sender and receiver must have the same key, distributed through a **key exchange**.

**Characteristics**:
- Same key encrypts and decrypts
- Faster than asymmetric encryption
- Ideal for encrypting large amounts of data
- Key distribution is a vulnerability — if intercepted during exchange, all communications can be decrypted

**Use cases**: Encrypting large files, databases within secure networks where key distribution is not problematic.

### Asymmetric Encryption

**Asymmetric encryption** uses **two mathematically related keys**: a **public key** (for encryption) and a **private key** (for decryption). Together, these form a **key pair**.

**How it works**:
1. Receiver shares their public key openly
2. Sender encrypts message using receiver's public key
3. Only the receiver's private key can decrypt the message
4. Private key is kept secret and stored locally

**Key property**: A single key cannot both encrypt and decrypt — messages encrypted with the public key can only be decrypted with the corresponding private key.

**Digital signatures**: To prove message authenticity, the sender encrypts with their private key. Anyone can decrypt it using the sender's public key, verifying the sender's identity since only they have access to that private key.

**Characteristics**:
- More secure key distribution (public key can be shared openly)
- Slower than symmetric encryption
- Used for secure, smaller data transactions

**Use cases**: Secure email, online banking, passwords, government communications — situations demanding high security.

### Comparison

| Aspect | Symmetric | Asymmetric |
|--------|-----------|------------|
| Keys | One shared key | Public + private key pair |
| Speed | Faster | Slower |
| Security weakness | Key distribution | Computationally intensive |
| Best for | Large files, bulk data | Confidential communications, small secure transactions |

---

## Hashing

**Hashing** is a process where an input (called a **key**) is converted by a **hash function** into a fixed-size output value (called a **hash** or **digest**).

**Key properties**:
- Same input always produces the same hash (consistency)
- Even minor input changes produce radically different outputs (sensitivity)
- Output is a fixed length regardless of input size
- **Irreversible** — the hash cannot be reversed to obtain the original input

### Hashing vs Encryption

| Aspect | Encryption | Hashing |
|--------|------------|---------|
| Purpose | Securing data for transmission/storage | Data verification, quick retrieval |
| Reversibility | Reversible with key | Irreversible |
| Keys | Uses keys | No keys involved |
| Speed | Generally slower | Generally faster |
| Output length | Variable | Fixed length |

### Common Hash Algorithms

- **MD5** (Message Digest 5): Widely used but now considered weak due to collision vulnerabilities
- **SHA-1**: Previously used in SSL certificates; now considered weak
- **SHA-256** (SHA-2 family): Commonly used in cryptographic applications; considered secure
- **SHA-3**: Most recent; designed for higher security levels

### Uses of Hashing

#### Password Storage

1. User creates password → password is hashed → **hash stored** (not plaintext)
2. User logs in → entered password is hashed → compared against stored hash
3. If hashes match → access granted; if not → access denied

**Security benefits**:
- Raw passwords never stored — minimises breach impact
- If database compromised, attackers only get hashes which cannot be reversed to obtain passwords
- Same hash function always produces same output, enabling quick verification

#### Hash Tables

A **hash table** is a data structure holding **key-value pairs**, formed from a **bucket array** and a hash function. It enables data lookup in **constant time** O(1).

**Process**: When data is inserted, it is used as the key for the hash function and stored in the bucket corresponding to the resulting hash.

**Applications**: Caches, databases — anywhere large amounts of data need constant access times.

#### Data Integrity Verification

Hashing verifies that data has not been altered during transfer:
- Original data is hashed before transmission
- Received data is hashed upon arrival
- If hashes match, data integrity is confirmed
- Comparing fixed-size hashes is computationally efficient

### Collisions

A **collision** occurs when two different inputs produce the same hash value.

**Collision resolution methods**:
- Store items together in a list under the same hash value (chaining)
- Use a second hash function to generate a new hash (rehashing/double hashing)

### Properties of a Good Hash Function

- **Low collision probability** — distributes keys uniformly across the hash table
- **Quick to calculate** — computationally efficient
- **Output smaller than input** — otherwise searching for the hash could take longer than searching for the key itself
