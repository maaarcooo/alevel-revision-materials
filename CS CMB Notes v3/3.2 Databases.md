# 3.2 Databases

## Database Fundamentals

A **database** is an organised collection of data that allows easy storage, retrieval, and management of information.

**Electronic databases** offer key benefits: easier to add, delete, modify and update data; data can be backed up more easily; multiple users from multiple locations can access the same database simultaneously.

### Database Terminology

**Entity** — an item of interest about which information is stored. Entities become tables in a relational database.

**Attribute** — a characteristic of an entity; a category about which data is collected. Attributes become columns/fields in a table.

**Field** — a single piece of data in a record (one column value).

**Record** — a group of related fields representing one data entry (one row in a table).

**Table** — a collection of records with a similar structure.

---

## Flat File vs Relational Databases

### Flat File Database

A **flat file database** consists of a **single file** based around a **single entity** and its attributes.

Notation: `Entity(Attribute1, Attribute2, Attribute3, ...)`

Example: `Car(CarID, Age, Price)`

**Problems with flat files:**
- Data redundancy (unnecessary duplicates)
- Inefficient storage
- Update anomalies — changing one piece of data requires finding and updating all instances

### Relational Database

A **relational database** recognises the differences between entities by creating **different tables** for each entity, linked using keys.

**Benefits:**
- Reduces data redundancy
- Efficient storage
- Data only needs updating in one place
- Maintains data consistency

---

## Keys

### Primary Key

A **primary key** is a **unique identifier** for each **record** in a table. Each table has exactly one primary key.

- Shown by **underlining** the attribute name: `Car(CarID, Age, Price)`
- Often an ID number that is auto-generated
- Cannot contain NULL values
- Must be unique for every record

### Composite (Compound) Primary Key

A **composite primary key** uses a combination of two or more fields that together uniquely identify each record.

Used when no single field can uniquely identify records.

### Foreign Key

A **foreign key** is an attribute that **links two tables together**. It exists in one table as the primary key and acts as the foreign key in another.

- Shown using an **asterisk** (*): `Patient(PatientID, Name, DoctorID*)`
- Creates relationships between tables
- Must match a primary key value in the related table (or be NULL if permitted)

### Secondary Key

A **secondary key** allows a database to be **searched quickly**. It creates an index on frequently searched attributes.

- Primary keys are automatically indexed but rarely queried directly (users don't remember ID numbers)
- Secondary keys enable **ordering and searching** by commonly used fields (e.g., surname)

---

## Indexing

**Indexing** is a method used to store the position of each record ordered by a certain attribute, enabling fast data lookup.

Works like a book index — instead of scanning every page, you look up the location directly.

- **Primary key** is **automatically indexed**
- **Secondary keys** are indexed to make searching faster on those attributes
- Fields that are indexed are known as secondary keys

---

## Entity Relationship Modelling

Tables have different kinds of relationships depending on how entities are related in the real world.

### Relationship Types

**One-to-One (1:1)** — each entity can only be linked to one other entity.
- Example: A person and their passport
- Shown with a single line connecting entities
- Relatively rare in databases

**One-to-Many (1:M)** — one entity can be associated with many other entities.
- Example: One customer can place many orders; each order belongs to one customer
- Shown with a branch (crow's foot) on the "many" side
- Most common relationship type

**Many-to-Many (M:M)** — one entity can be associated with many others, and vice versa.
- Example: Students and courses — each student can enrol in multiple courses, each course has multiple students
- Shown with branches on both sides
- **Cannot be directly implemented** in a database

### Resolving Many-to-Many Relationships

Many-to-many relationships must be resolved by creating a **link table** (junction table) between the two entities.

The link table contains foreign keys referencing both original tables, converting the M:M relationship into two 1:M relationships.

### Entity Relationship Diagrams (ERDs)

An **ERD** represents the entities (tables) in a database and the relationships between them using standard notation.

---

## Normalisation

**Normalisation** is the process of coming up with the **best possible layout** for a **relational database**.

### Goals of Normalisation

- **No redundancy** (unnecessary duplicates)
- **Consistent data** throughout linked tables
- Records can be **added and removed without issues**
- **Complex queries** can be carried out

### First Normal Form (1NF)

A table is in 1NF if:
- **No attribute contains more than a single value** (no arrays, lists, or repeating groups)
- Each column has a unique name
- Each row has a unique identifier (primary key)

### Second Normal Form (2NF)

A table is in 2NF if:
- It is already in **1NF**
- It has **no partial dependencies**
- All non-key attributes depend on the **entire** primary key, not just part of a **composite key**

*Note: 2NF only applies to tables with composite primary keys. Tables with single-field primary keys in 1NF are automatically in 2NF.*

### Third Normal Form (3NF)

A table is in 3NF if:
- It is already in **2NF**
- It contains **no non-key dependencies** (transitive dependencies)
- Each non-key attribute depends **only on the primary key** and nothing else

A transitive dependency occurs when a non-key attribute depends on another non-key attribute rather than directly on the primary key.

---

## Capturing, Selecting, Managing and Exchanging Data

### Data Capture Methods

**Manual entry** — data entered directly by a person (e.g., survey responses).

**OMR (Optical Mark Recognition)** — detects marked areas on paper using a special scanner. Used for multiple-choice tests, surveys, lottery tickets.

**OCR (Optical Character Recognition)** — converts printed or handwritten text into digital format.

**MICR (Magnetic Ink Character Recognition)** — used by banks to scan cheques. Details (except amount) are printed in special magnetic ink readable by computers; amount must be entered manually.

**Sensors** — devices that detect and respond to environmental changes. Enable automated data collection and real-time monitoring.

**Barcodes** — machine-readable representation of data using parallel lines of varying widths. Used for inventory management and point-of-sale systems.

### Selecting and Managing Data

Selecting correct data is part of **data preprocessing**. This involves:
- Selecting only data that fits certain criteria to reduce input volume
- Removing irrelevant background information
- Using SQL to sort, restructure and select data sections

Example: A speed camera only captures cars exceeding the limit, then extracts just the number plate.

### Exchanging Data

**Exchanging data** is the process of **transferring collected data**.

**EDI (Electronic Data Interchange)** — enables data transfer from one computer to another. **Does not require human interaction**.

---

## SQL (Structured Query Language)

**SQL** is a **declarative language** used to **manipulate databases**. It enables creating, removing, and updating databases and their contents.

### Data Types

| Type | Description |
|------|-------------|
| `CHAR(n)` | String of fixed length n |
| `VARCHAR(n)` | String of variable length with upper limit n |
| `BOOLEAN` | TRUE or FALSE values |
| `INTEGER` / `INT` | Whole number |
| `FLOAT` | Number with floating decimal point |
| `DATE` | Date (format varies by system) |
| `TIME` | Time in Hour:Minute:Second format |
| `CURRENCY` | Monetary amount |

### SELECT, FROM, WHERE

**SELECT** — specifies which fields to retrieve  
**FROM** — specifies which table(s) to query  
**WHERE** — specifies the search criteria (conditions)

```sql
SELECT MovieTitle, DatePublished
FROM Movie
WHERE DatePublished BETWEEN #01/01/2000# AND #31/12/2005#;
```

**Wildcards:** Use `LIKE` with `%` for pattern matching:
```sql
SELECT Name FROM Customers WHERE Country LIKE 'U%';
```

### ORDER BY

Specifies **ascending or descending** order for results.

- Values are automatically placed in **ascending** order (default)
- Add `DESC` for **descending** order

```sql
SELECT * FROM Products ORDER BY Price DESC;
```

### JOIN

**JOIN** provides a method of **combining rows from multiple tables** based on a **common field** between them.

```sql
SELECT Movie.MovieTitle, Director.DirectorName
FROM Movie
JOIN Director ON Movie.DirectorID = Director.DirectorID;
```

### Nested SELECT

A SELECT statement within another SELECT statement:
```sql
SELECT * FROM Employees WHERE Salary > (SELECT AVG(Salary) FROM Employees);
```

### CREATE TABLE

Creates a new table, specifying each attribute's data type, constraints, and keys.

```sql
CREATE TABLE TableName (
    Attribute1 INTEGER NOT NULL PRIMARY KEY,
    Attribute2 VARCHAR(20) NOT NULL,
    Attribute3 DATE
);
```

Must specify: whether it is the primary key, its data type, whether it must be filled in (`NOT NULL`).

### ALTER TABLE

Used to **add, delete, or modify** columns in a table.

**Add a column:**
```sql
ALTER TABLE TableName ADD AttributeX DataType;
```

**Delete a column:**
```sql
ALTER TABLE TableName DROP COLUMN AttributeX;
```

**Modify a column's data type:**
```sql
ALTER TABLE TableName MODIFY COLUMN AttributeX NewDataType;
```

### INSERT INTO

**Inserts a new record** into a table.

```sql
INSERT INTO TableName (column1, column2)
VALUES (value1, value2);
```

### UPDATE

**Updates existing records** in a table.

```sql
UPDATE TableName
SET column1 = value1, column2 = value2
WHERE condition;
```

### DELETE

**Deletes records** from a table.

```sql
DELETE FROM TableName WHERE columnX = value;
```

### DROP TABLE

Removes an entire table from the database:
```sql
DROP TABLE TableName;
```

---

## Referential Integrity

**Referential integrity** is the process of **ensuring consistency** between related tables.

### Key Principle

Information cannot be removed if it is required elsewhere in a linked database. Every foreign key value must either:
- Match a primary key value in the related table, OR
- Be NULL (if permitted)

There should be no "orphaned" records — foreign keys pointing to non-existent primary keys.

### Maintaining Referential Integrity

**CASCADE** — automatically updates or deletes related records when the primary key changes.

**SET NULL** — sets foreign key values to NULL when the referenced primary key is deleted.

**SET DEFAULT** — sets foreign key values to their default when the referenced primary key is deleted.

---

## Transaction Processing

A **transaction** is a **single operation executed on data**. A collection of related operations can also be considered a single transaction.

Example: Bank transfer — withdrawal from one account and deposit into another must both succeed or both fail.

### Problems with Transaction Processing

- **Concurrency** — multiple transactions accessing/modifying the same data simultaneously
- **Deadlock** — two or more transactions waiting for each other to release resources
- **Data integrity** — transactions failing partway through, leaving inconsistent state
- **Isolation** — one user's transaction affecting another's

### Solutions

- **Locking** — prevents simultaneous access to the same data
- **Logging and recovery** — maintains a log of changes to recover to consistent state
- **Commit and rollback** — commit saves changes permanently; rollback reverts changes

---

## ACID Properties

**ACID** is a set of rules that Database Management Systems must follow to ensure data integrity and reliable transaction processing.

### Atomicity

A transaction must be **processed in its entirety or not at all**. If any operation fails, the entire transaction is rolled back.

### Consistency

A transaction must **maintain the referential integrity rules** between linked tables. The database starts in a consistent state and ends in a consistent state.

### Isolation

**Simultaneous executions** of transactions should lead to the **same result** as if they were executed one after the other. Intermediate states are not visible to other transactions.

### Durability

Once a transaction has been executed, it **will remain so regardless** of subsequent circumstances (e.g., power failure). Committed data persists.

---

## Record Locking

**Record locking** is the process of **preventing simultaneous access** to records in a database. It is used to **prevent inconsistencies** or **loss of updates**.

While one person is editing a record, the record is "locked" preventing others from accessing it.

### Lock Types

**Shared lock (Read lock)** — allows multiple transactions to read simultaneously; prevents modifications until released.

**Exclusive lock (Write lock)** — allows only one transaction to access and modify a record; blocks all other access.

### Deadlock

The biggest problem with record locking is **deadlock**:

1. User 1 locks Record A; User 2 locks Record B
2. User 1 tries to access Record B; User 2 tries to access Record A
3. Both users wait for the other to release their lock
4. Neither can progress — **deadlock**

**Solutions:** Timeout mechanisms, resource ordering, deadlock detection algorithms.

---

## Redundancy (Data Backup)

**Redundancy** (in the context of backup) is the process of having **one or more copies** of data in **physically different locations**.

If one copy is damaged, others remain unaffected and can be recovered.

*Note: This is distinct from "data redundancy" in normalisation, which refers to unnecessary duplicate data within a database — something to be avoided.*
