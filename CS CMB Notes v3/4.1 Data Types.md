# 4.1 Data Types

## Primitive Data Types

Data is always stored in **binary** by computers, but the way data is represented varies between different types. Choosing the correct **data type** ensures the right **operations** can be performed on data.

**Integer**: A **whole number** (positive, negative, or zero) with no fractional part. Used for **counting** things.
- Examples: 6, 47238, -12, 0, 15

**Real / Floating Point**: Positive or negative numbers that can have a **fractional part**. Used for **measuring** things. All integers are real numbers.
- Examples: 0, -71.5, 5.01, -80.8, 15

**Character**: A **single symbol** used by a computer — letters A-Z, digits 0-9, and symbols like %, £, ௹.
- Examples: R, {, 7, Σ, ほ

**String**: A **collection of characters**. Useful for storing text and phone numbers starting with 0 (which numeric types would truncate).
- Examples: "Hello, world!", "07789"

**Boolean**: Named after mathematician **George Boole**. Values restricted to **True** and **False**. Useful for data with only two possible values (e.g., power button state, whether code executed).

---

## Representing Positive Integers in Binary

Computers store whole numbers using **binary** (base 2), where each place value is **two times** the previous place.

**Key terminology:**
- **Bit**: A single **b**inary dig**it** (0 or 1)
- **Byte**: Eight binary digits combined
- **Nybble**: Half a byte (four bits)

**Least significant bit (LSB)**: Furthest to the right, represents value of 1
**Most significant bit (MSB)**: Furthest to the left

### Binary to Decimal Conversion

Multiply each digit by its place value and sum the results.

| 8 (2³) | 4 (2²) | 2 (2¹) | 1 (2⁰) |
|--------|--------|--------|--------|
| 1 | 1 | 0 | 1 |

Calculation: (8×1) + (4×1) + (2×0) + (1×1) = **13**

So binary 1101 = decimal 13.

### Decimal to Binary Conversion

1. Find the largest power of two ≤ your number
2. Write out place values up to this power
3. From MSB to LSB: write 1 if place value ≤ remaining value (then subtract), otherwise write 0

**Example: Convert 47 to binary**

| 32 | 16 | 8 | 4 | 2 | 1 |
|----|----|----|---|---|---|
| 1 | 0 | 1 | 1 | 1 | 1 |

47 = 32 + 8 + 4 + 2 + 1 = **101111**

Binary numbers are often shown as **whole bytes** by adding **leading zeros** (e.g., 47 = 00101111).

---

## Binary Addition

**Four rules to remember:**
1. 0 + 0 + 0 = 0
2. 0 + 0 + 1 = 1
3. 0 + 1 + 1 = 10 (write 0, carry 1)
4. 1 + 1 + 1 = 11 (write 1, carry 1)

**Method:**
1. Align numbers so digits line up
2. Add from LSB (right) to MSB (left)
3. If result > 1 digit, carry to next column
4. Read result from full-size digits at bottom

**Example: 1011 + 1110**
```
    1 0 1 1
+   1 1 1 0
-----------
  1 1 0 0 1
```
Result: 11001 (Check: 11 + 14 = 25 ✓)

---

## Negative Numbers in Binary

### Sign Magnitude

The most basic method — equivalent to adding + or - in front of a number.
- **Leading 0** = positive number
- **Leading 1** = negative number

| Binary 173 | Sign Magnitude +173 | Sign Magnitude -173 |
|------------|---------------------|---------------------|
| 10101101 | 010101101 | 110101101 |

**Converting sign magnitude to decimal:** Note the MSB (for sign), discard it, convert remaining bits, then apply the sign.

Example: 101101001 → MSB is 1 (negative) → 01101001 = 105 → Result: **-105**

### Two's Complement

Makes binary arithmetic with negative numbers **much more simple**. The MSB represents a **negative** value.

For an 8-bit byte: MSB represents **-128** instead of +128.

**Converting to two's complement:**
1. Flip all bits in the positive number
2. Add one

**Example: Convert 7 to two's complement**
- Binary 7: 00000111
- Flip bits: 11111000
- Add one: **11111001** = -7

**Verification:**

| -128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |
|------|----|----|----|----|---|---|---|
| 1 | 1 | 1 | 1 | 1 | 0 | 0 | 1 |

(-128) + 64 + 32 + 16 + 8 + 1 = **-7** ✓

---

## Binary Subtraction Using Two's Complement

Subtraction = adding a negative number.

**Example: 8 - 12**

In 5-bit two's complement:
- 8 = 01000
- -12 = 10100

```
    0 1 0 0 0
+   1 0 1 0 0
-------------
    1 1 1 0 0
```

Check: -16 + 8 + 4 = **-4** ✓

---

## Hexadecimal

**Base 16** number system using digits 0-9 and letters A-F for values 10-15.

| Decimal | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---------|---|---|---|---|---|---|---|---|---|---|----|----|----|----|----|----|
| Hex | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F |

Place values: powers of 16 (1, 16, 256, 4096, ...)

**Example: 4E7F in decimal**

| 4096 (16³) | 256 (16²) | 16 (16¹) | 1 (16⁰) |
|------------|-----------|----------|---------|
| 4 | E (14) | 7 | F (15) |

(4×4096) + (14×256) + (7×16) + (15×1) = **20095**

### Hexadecimal to Binary

Convert each hex digit to a **decimal digit**, then to a **binary nybble**, then combine.

**Example: B2**
- B → 11 → 1011
- 2 → 2 → 0010
- Combined: **10110010** (= 178 in decimal)

### Hexadecimal to Decimal

Either convert via binary first, or use hex place values directly.

**Example: 4C3**
(4×256) + (12×16) + (3×1) = **1219**

---

## Floating Point Numbers in Binary

Similar to **scientific notation** (e.g., 6.67 × 10⁻¹¹).

**Components:**
- **Mantissa**: The significant digits
- **Exponent**: How many places to shift the binary point

Both stored in **two's complement**:
- MSB of mantissa: 0 = positive, 1 = negative

**Structure example:** 11-bit mantissa + 6-bit exponent

| M (11 bits) | E (6 bits) |
|-------------|------------|
| 0 1 1 0 0 1 0 0 1 1 1 | 0 0 0 1 1 0 |

The **binary point** is always placed after the MSB of the mantissa.
So mantissa 01100100111 represents **0.1100100111**

**Converting to decimal:**
1. Read mantissa with binary point after MSB
2. Convert exponent to decimal (using two's complement)
3. Shift binary point by exponent value (right if positive, left if negative)
4. Calculate decimal value

---

## Normalisation

Floating point numbers are **normalised** to maximise **precision** in a given number of bits.

**Normalised form:**
- Positive numbers start with **01**
- Negative numbers start with **10**

**To normalise:**
1. Shift mantissa bits until it starts 01 (positive) or 10 (negative)
2. Add zeros to fill the mantissa
3. Adjust exponent accordingly (decrease for left shifts, increase for right shifts)

**Example:** Normalise 000110100101 (8-bit mantissa, 4-bit exponent)

- Original mantissa: 00011010, exponent: 0101 (= 5)
- Shift mantissa 2 places left: **01101000**
- New exponent: 5 - 2 = 3 = **0011**
- Result: **011010000011**

---

## Floating Point Addition and Subtraction

### Addition

1. **Make exponents equal** by shifting mantissa and adjusting exponent
2. **Add mantissas** using binary addition
3. **Normalise** the result if required

**Example:** Add 000100 0011 and 000101 0010

Step 1 — Equalise exponents:
- 000100 0011 → shift mantissa right by 1 → 001000 0010
- 000101 0010 (unchanged)

Step 2 — Add mantissas:
```
  0 0 1 0 0 0
+ 0 0 0 1 0 1
-------------
  0 0 1 1 0 1
```

Step 3 — Normalise: 001101 0010 → shift left by 1 → **011010 0001**

### Subtraction

1. Make exponents equal
2. Convert the number being subtracted to **two's complement** (flip bits, add one)
3. Add the numbers
4. Normalise the result

---

## Bitwise Manipulation and Masks

### Logical Shifts

Moving all bits a specified number of places left or right.

**Logical shift left**: Add trailing zeros → **multiplies** by 2ⁿ
**Logical shift right**: Add leading zeros → **divides** by 2ⁿ

**Example:** Logical shift left by 3 on 10010110
- Result: 10010110**000**
- Effect: Multiply by 2³ = 8

A shift left by 1 place **doubles** the number.
A shift right by 1 place **halves** the number.

### Masks

Masks combine binary numbers using logic gates to manipulate specific bits.

**AND mask** — Output 1 only if **both** bits are 1:

| | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |
|-----|---|---|---|---|---|---|---|---|
| AND | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |
| = | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |

**OR mask** — Output 1 if **either** bit is 1:

| | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |
|-----|---|---|---|---|---|---|---|---|
| OR | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |
| = | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |

**XOR mask** — Output 1 if bits are **different**:

| | 0 | 0 | 1 | 0 | 1 | 0 | 1 | 1 |
|-----|---|---|---|---|---|---|---|---|
| XOR | 1 | 0 | 1 | 1 | 1 | 0 | 1 | 1 |
| = | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |

---

## Character Sets

A **character set** is a published collection of codes and corresponding characters used by computers for representing text.

### ASCII

**American Standard Code for Information Interchange**

- Uses **7 bits** to represent 2⁷ = **128** different characters
- Capital letters A-Z: codes **65-90**
- Lowercase letters a-z: codes **97-122**
- Also includes numbers and symbols

**Limitation:** Cannot represent characters from other languages or modern symbols/emoji.

### Unicode

Solves ASCII's limitations by using a **varying number of bits** (up to 32 bits), allowing for **over 1 million** different characters.

**Advantages:**
- Supports a wealth of different **languages** and scripts
- Includes modern **symbols** and **emoji**
- Many character codes are yet to be allocated

**Trade-off:** Unicode requires more storage space than ASCII.
