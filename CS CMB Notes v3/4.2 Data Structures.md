# 4.2 Data Structures

## Arrays

An **array** is an **ordered**, **finite** set of elements of a **single type**.

**One-dimensional (1D) array**: A **linear array**. Elements are accessed by index.

```
oneDimensionalArray = [1, 23, 12, 14, 16, 29, 12]
print(oneDimensionalArray[3])  // Output: 14
```

Arrays are **zero-indexed** by default — the first element is at position 0.

**Two-dimensional (2D) array**: Visualised as a **table** or **spreadsheet**. Navigate by going **down the rows** first, then **across the columns** (opposite to coordinate systems).

```
twoDimensionalArray = [[123, 28, 90, 38, 88, 23, 47], [1, 23, 12, 14, 16, 29, 12]]
print(twoDimensionalArray[1, 3])  // Output: 14
```

**Three-dimensional (3D) array**: Visualised as a **multi-page spreadsheet** — multiple 2D arrays. Syntax: `array[z, y, x]` where z = array number, y = row, x = column.

---

## Records

A **record** is a **row in a file**, made up of **fields**. Used in databases.

| ID  | FirstName | Surname |
|-----|-----------|---------|
| 001 | Antony    | Joshua  |
| 002 | Tyson     | Fury    |

**Declaring a record:**

```
fighterDataType = record
    integer ID
    string FirstName
    string Surname
end record
```

**Creating and accessing:**

```
fighter : fighterDataType
fighter.FirstName  // Access using recordName.fieldName
```

---

## Lists

A **list** is a data structure of **ordered** items where items can **occur more than once**.

**Key differences from arrays:**
- Values stored **non-contiguously** (not adjacent in memory)
- Can contain **more than one data type**

**List Operations:**

| Operation | Example | Description |
|-----------|---------|-------------|
| `isEmpty()` | `List.isEmpty()` → False | Checks if list is empty |
| `append(value)` | `List.append(15)` | Adds value to end of list |
| `remove(value)` | `List.remove(23)` | Removes first occurrence of value |
| `search(value)` | `List.search(38)` → False | Searches for value in list |
| `length()` | `List.length()` → 7 | Returns length of list |
| `index(value)` | `List.index(23)` → 0 | Returns position of item |
| `insert(pos, value)` | `List.insert(4, 25)` | Inserts value at given position |
| `pop()` | `List.pop()` → 12 | Returns and removes last value |
| `pop(position)` | `List.pop(3)` | Returns and removes value at position |

---

## Tuples

A **tuple** is an **ordered set of values of any type**. Tuples are **immutable** — elements cannot be added, changed, or removed once created.

Initialised using **round brackets** (not square):

```
tupleExample = ("Value1", 2, "Value3")
print(tupleExample[0])  // Output: Value1
tupleExample[0] = "New"  // Syntax Error — cannot modify
```

---

## Linked Lists

A **linked list** is a **dynamic data structure** used to hold an **ordered sequence**. Items do not need to be stored in **contiguous** memory locations.

Each item is called a **node**, containing:
- **Data field**: The actual value
- **Pointer field** (or **link**): Address of the next item

Additional pointers stored:
- **Start pointer**: Index of the first item
- **NextFree pointer**: Index of the next available space

| Index | Data | Pointer |
|-------|------|---------|
| 0 | 'Linked' | 2 |
| 1 | 'Example' | 0 |
| 2 | 'List' | - |
| 3 | | |

Start = 1, NextFree = 3

**Traversal**: Begin at Start pointer, output each node's data, follow pointers until null/empty.
Output: 'Example', 'Linked', 'List'

### Adding a Node

To add 'OCR' after 'Example':
1. Add new value at NextFree position, update NextFree pointer
2. Update 'Example' pointer to point to new node (index 3)
3. Set new node's pointer to 'Linked' (index 0)

### Removing a Node

Update pointers to **bypass** the deleted node. The node remains in memory but is ignored — this **wastes memory** but is simpler.

**Disadvantages of linked lists:**
- Storing pointers requires **more memory** than arrays
- Items can only be traversed **sequentially** — no **random access** (direct access by index)

---

## Graphs

A **graph** is a set of **vertices** (or **nodes**) connected by **edges** (or **arcs**).

**Types:**
- **Directed graph**: Edges can only be traversed in **one direction**
- **Undirected graph**: Edges can be traversed in **both directions**
- **Weighted graph**: A **cost** is attached to each edge

### Representing Graphs

**Adjacency Matrix**: 2D array showing connections between all nodes.

|   | A | B | C | D | E |
|---|---|---|---|---|---|
| A | - | 4 | 18| 12| - |
| B | 4 | - | 5 | - | 8 |
| C | 18| 5 | - | 5 | - |
| D | 12| - | - | - | 3 |
| E | - | 8 | - | 3 | - |

**Adjacency List**: Each node stores a list of its connections.

```
A → {B:4, C:18, D:12}
B → {A:4, C:5, E:8}
C → {A:18, B:5, D:5}
D → {A:12, E:3}
E → {B:8, D:3}
```

| Adjacency Matrix | Adjacency List |
|-----------------|----------------|
| Quicker access times | More space efficient for **large, sparse networks** |
| Easy to add nodes | |

---

## Stacks

A **stack** is a **Last In First Out (LIFO)** data structure. Items can only be added to or removed from the **top** of the stack.

**Uses**: Reversing actions (e.g., **undo** buttons, browser **back** function)

**Implementation**: Uses a **top pointer** indicating where the next item will be inserted. Can be **static** (fixed size, more efficient) or **dynamic**.

**Stack Operations:**

| Operation | Example | Description |
|-----------|---------|-------------|
| `isEmpty()` | `Stack.isEmpty()` → True | Checks if stack is empty (checks top pointer) |
| `push(value)` | `Stack.push("Nadia")` | Adds value to top (checks if full first) |
| `peek()` | `Stack.peek()` → "Elijah" | Returns top value without removing |
| `pop()` | `Stack.pop()` → "Elijah" | Returns and removes top value |
| `size()` | `Stack.size()` → 2 | Returns size of stack |
| `isFull()` | `Stack.isFull()` → False | Checks if stack is full (compares size to top pointer) |

---

## Queues

A **queue** is a **First In First Out (FIFO)** data structure. Items are added to the **back** (rear) and removed from the **front**.

**Uses**: Printers, keyboards, simulators

**Pointers**: **Front pointer** and **back/rear pointer**

### Linear Queue

Items added to next available space; removed from front. **Problem**: Removed items leave unusable spaces — inefficient use of memory.

### Circular Queue

When rear pointer equals max size, it **loops back** to the front of the array (if empty). More **efficient memory use** but **harder to implement**.

```
// When rearPointer reaches maxSize:
rearPointer = (rearPointer + 1) MOD maxSize
```

**Queue Operations:**

| Operation | Description |
|-----------|-------------|
| `enQueue(value)` | Adds item to back; increments back pointer |
| `deQueue()` | Removes item from front; increments front pointer |
| `isEmpty()` | Compares front and back pointers |
| `isFull()` | Compares back pointer and queue size |

---

## Trees

A **tree** is a **connected form of a graph**. Trees have a **root node** at the top.

**Terminology:**

| Term | Definition |
|------|------------|
| **Node** | An item in the tree |
| **Edge** (branch/arc) | Connects two nodes together |
| **Root** | Single node with no incoming edges |
| **Child** | Node with incoming edges |
| **Parent** | Node with outgoing edges |
| **Subtree** | Parent node and all its children |
| **Leaf** | Node with no children |

### Binary Trees

A **binary tree** is a tree where each node has a **maximum of two children**. Used for **binary searches** as they are **easy to search**.

**Implementation**: Each node has a **left pointer** and **right pointer**, typically stored in a **2D array**.

| Index | Left Pointer | Data | Right Pointer |
|-------|--------------|------|---------------|
| 0 | 1 | G | 3 |
| 1 | 2 | C | 4 |
| 2 | - | A | - |
| 3 | - | J | 5 |

---

## Tree Traversal

Three methods using the **outline method** (trace around the tree):

### Pre-order Traversal

**Order**: Root → Left subtree → Right subtree

**Outline method**: Visit nodes when passing on the **left** side.

**Use**: Prefix notation (operator before operands: `+ a b`)

Example: 15, 9, 5, 7, 11, 10, 12, 20, 25, 34

### In-order Traversal

**Order**: Left subtree → Root → Right subtree

**Outline method**: Visit nodes when passing **underneath**.

**Use**: Outputs nodes in **sequential/sorted order**

Example: 5, 7, 9, 10, 11, 12, 15, 20, 25, 34

### Post-order Traversal

**Order**: Left subtree → Right subtree → Root

**Outline method**: Visit nodes when passing on the **right** side.

**Use**: Postfix notation (operator after operands: `a b +`)

Example: 7, 5, 10, 12, 11, 9, 34, 25, 20, 15

---

## Hash Tables

A **hash table** is an **array** coupled with a **hash function**.

- **Hash function**: Takes a **key** as input and outputs a **hash** value
- **Purpose**: Maps the key to an **index** in the hash table
- **Advantage**: Provides **fast access** to data — O(1) time complexity in best case

### Collisions

A **collision** occurs when two different keys produce the **same hash value**.

A good hashing algorithm has a **low probability of collisions**.

### Collision Resolution

**Method 1 — Linear Probing**: Place the item in the **next available location**. Simple but can cause **clustering**.

**Method 2 — Chaining**: Store a **pointer** to a **linked list** at each index. Multiple items with the same hash are chained together.

### Rehashing

When table fills up or performance degrades, create a **new larger table** and rehash all existing items. May require modifying the hash function for the larger range.

---

## Static vs Dynamic Data Structures

| Static | Dynamic |
|--------|---------|
| Fixed size at compile time | Size can change at runtime |
| Memory allocated in advance | Memory allocated as needed |
| More efficient memory use | More flexible |
| Faster access | Slower access (pointer following) |
| Example: Arrays | Example: Linked lists |

---

## Key Comparisons

**Array vs List:**
- Arrays: Single type, contiguous storage, fixed size (static)
- Lists: Multiple types, non-contiguous storage, variable size

**Array vs Linked List:**
- Arrays: Random access (O(1)), fixed size, efficient memory
- Linked Lists: Sequential access only, dynamic size, extra memory for pointers

**Stack vs Queue:**
- Stack: LIFO — last in, first out (undo operations)
- Queue: FIFO — first in, first out (print jobs)

**Adjacency Matrix vs Adjacency List:**
- Matrix: Better for dense graphs, faster edge lookup
- List: Better for sparse graphs, less memory
