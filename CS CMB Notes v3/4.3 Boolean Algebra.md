# 4.3 Boolean Algebra

## Boolean Logic Fundamentals

**Boolean logic** is used in computer science and electronics to make logical decisions. Boolean values are either **TRUE (1)** or **FALSE (0)**.

**Boolean equations** can equate to either True or False, but not both. Inputs and outputs are represented by letters (A, B, C, etc.).

**Boolean algebra** is a mathematical system used to manipulate Boolean values — distinct from Boolean logic, which refers to the underlying principles.

### Order of Operations

When evaluating Boolean expressions with multiple operators:

1. **Brackets** — evaluated first
2. **NOT** — highest precedence operator
3. **AND** — next highest precedence
4. **OR** — lowest precedence

---

## Logic Gates and Truth Tables

**Logic gates** visually represent Boolean expressions. **Truth tables** show every possible input permutation and the corresponding output.

### Conjunction (AND)

| A | B | A ∧ B |
|---|---|-------|
| 0 | 0 | 0 |
| 0 | 1 | 0 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

- Returns TRUE only when **both inputs are TRUE**
- Can be thought of as multiplication: 1 × 1 = 1
- Symbol: ∧ or · (dot)

### Disjunction (OR)

| A | B | A ∨ B |
|---|---|-------|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 1 |

- Returns TRUE if **either input is TRUE**
- Can be thought of as addition (capped at 1)
- Symbol: ∨ or +

### Negation (NOT)

| A | ¬A |
|---|-----|
| 0 | 1 |
| 1 | 0 |

- Applied to **one literal only**
- **Inverts** the input value
- Symbol: ¬ or overbar (Ā)

### Exclusive Disjunction (XOR)

| A | B | A ⊕ B |
|---|---|-------|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

- Returns TRUE when **exactly one input is TRUE**
- Returns FALSE when inputs are the same
- Symbol: ⊕ or ⊻

### Combining Boolean Operations

Boolean equations combine operators like standard mathematics. Build truth tables by evaluating parts step-by-step.

**Example**: For ¬(A ∧ (B ∨ C))
1. Calculate B ∨ C
2. Calculate A ∧ (B ∨ C)
3. Apply negation to the result

---

## Karnaugh Maps

**Karnaugh maps (K-maps)** simplify Boolean expressions by providing a visual method to group terms with common factors and eliminate redundant terms.

### Creating a K-Map

**2-variable K-map:**

|   | A=0 | A=1 |
|---|-----|-----|
| B=0 | w | y |
| B=1 | x | z |

**3-variable K-map:**

| C \ AB | 00 | 01 | 11 | 10 |
|--------|----|----|----|----|
| 0 | | | | |
| 1 | | | | |

**4-variable K-map:**

| CD \ AB | 00 | 01 | 11 | 10 |
|---------|----|----|----|----|
| 00 | | | | |
| 01 | | | | |
| 11 | | | | |
| 10 | | | | |

**Critical**: Column/row headers must use **Gray code** — adjacent cells differ by only **one bit**. The sequence is 00, 01, 11, 10 (not binary counting order).

### Simplification Process

1. Fill the K-map with 1s and 0s from the truth table
2. Group adjacent 1s into **rectangular groups**
3. Group sizes must be **powers of 2** (1, 2, 4, 8)
4. Make groups **as large as possible**
5. Groups can **overlap** — this is desirable
6. Groups can **wrap around** edges (top-bottom, left-right)
7. Use the **minimum number of groups** to cover all 1s

### Deriving the Simplified Expression

For each group:
- Identify variables that **remain constant** across all cells in the group
- Variables that change within the group are **eliminated**
- Write the term using only the constant variables
- **OR** all group terms together for the final expression

**Example**: If a group covers all cells where A=1 regardless of B and C values, that group simplifies to just **A**.

---

## Simplifying Boolean Algebra

### General Rules

**AND Rules:**
- X ∧ 0 = 0
- X ∧ 1 = X
- X ∧ X = X
- X ∧ ¬X = 0

**OR Rules:**
- X ∨ 0 = X
- X ∨ 1 = 1
- X ∨ X = X
- X ∨ ¬X = 1

### De Morgan's Laws

Used when negation applies to an entire expression. **Break the negation** and **change the operator**.

**First Law:**
$$¬(A ∧ B) ≡ ¬A ∨ ¬B$$

**Second Law:**
$$¬(A ∨ B) ≡ ¬A ∧ ¬B$$

**Application steps:**
1. Change AND to OR (or vice versa)
2. Negate each term either side of the operator
3. Negate the entire changed expression
4. Remove double negations
5. Remove unnecessary brackets

**Practical use**: Allows circuits to be built using only **NAND** or only **NOR** gates, simplifying microprocessor design.

### Distribution

Similar to factorising in mathematics.

**Conjunction over disjunction:**
$$A ∧ (B ∨ C) ≡ (A ∧ B) ∨ (A ∧ C)$$

**Disjunction over conjunction:**
$$A ∨ (B ∧ C) ≡ (A ∨ B) ∧ (A ∨ C)$$

**Same operator distribution:**
$$A ∧ (B ∧ C) ≡ (A ∧ B) ∧ (A ∧ C)$$
$$A ∨ (B ∨ C) ≡ (A ∨ B) ∨ (A ∨ C)$$

### Association

Allows removal or addition of brackets and regrouping of literals.

$$(A ∧ B) ∧ C ≡ A ∧ (B ∧ C) ≡ A ∧ B ∧ C$$
$$(A ∨ B) ∨ C ≡ A ∨ (B ∨ C) ≡ A ∨ B ∨ C$$

### Commutation

The **order of literals** around an operator does not affect the result.

$$A ∧ B ≡ B ∧ A$$
$$A ∨ B ≡ B ∨ A$$

### Double Negation

Negating a literal twice returns the original value.

$$¬¬A ≡ A$$

### Absorption Laws

Useful for eliminating redundant terms:

$$A ∨ (A ∧ B) ≡ A$$
$$A ∧ (A ∨ B) ≡ A$$

---

## D-Type Flip Flops

A **flip flop** is a logic circuit that can **store the value of one bit** — a basic unit of memory. Also called **positive edge triggered** circuits.

### Components

- **D (Data input)** — the value to be stored
- **CLK (Clock input)** — timing signal
- **Q** — the stored output value
- **Q̄ (NOT Q)** — the complement of Q

### Operation

- A **clock pulse** rises and falls, with **rising edges** and **falling edges**
- D-type flip flop output **only changes on the rising edge** (start of clock tick)
- At each rising edge, **Q takes the value of D**
- Q **holds its value** until the next rising edge
- Q̄ is always the inverse of Q

### Circuit Construction

Typically built using **four NAND gates**. The circuit updates Q to match D whenever CLK has a rising edge.

### Applications

- **Shift registers**
- **Counters**
- **Memory units**
- **Edge-triggered devices**
- **Synchronous circuits**
- **Data storage**

Sets of flip flops can be combined to form **registers**.

---

## Adder Circuits

**Adders** are logic circuits that add binary inputs and output the result in binary.

### Half Adder

Adds **two single-bit inputs** (A and B).

**Components**: One XOR gate, one AND gate

**Outputs**:
- **S (Sum)** = A ⊕ B
- **C (Carry)** = A ∧ B

| A | B | Carry | Sum |
|---|---|-------|-----|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 0 |

**Memory aid**: Add A + B in decimal, convert to 2-bit binary. Result is (Carry, Sum).

### Full Adder

Extends the half adder to handle **three inputs**: A, B, and **Carry in (Cᵢₙ)**.

**Components**: Two XOR gates, two AND gates, one OR gate (equivalent to two half adders plus an OR gate)

**Outputs**:
- **S (Sum)** = A ⊕ B ⊕ Cᵢₙ
- **Cₒᵤₜ (Carry out)** = TRUE if at least two inputs are TRUE

| A | B | Cᵢₙ | Cₒᵤₜ | Sum |
|---|---|-----|------|-----|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 0 | 1 |
| 0 | 1 | 0 | 0 | 1 |
| 0 | 1 | 1 | 1 | 0 |
| 1 | 0 | 0 | 0 | 1 |
| 1 | 0 | 1 | 1 | 0 |
| 1 | 1 | 0 | 1 | 0 |
| 1 | 1 | 1 | 1 | 1 |

**Memory aid**: Add A + B + Cᵢₙ in decimal (result: 0, 1, 2, or 3), convert to 2-bit binary. Result is (Cₒᵤₜ, Sum).

### Ripple Adder

Full adders can be **chained together** to add multi-bit numbers:
- Connect Cₒᵤₜ of one adder to Cᵢₙ of the next
- Each full adder handles one bit position
- **n full adders** can add two **n-bit numbers**

---

## Exam Tips

- When simplifying with K-maps, **always show your groupings** clearly
- Remember Gray code ordering for K-map headers: 00, 01, 11, 10
- For D-type flip flops, Q can **only change at rising clock edges**
- Truth tables for adders: just add the inputs as decimal, then convert to binary
- De Morgan's Law: "break the bar, change the sign"
- You do not need to memorise the internal gate structure of D-type flip flops
