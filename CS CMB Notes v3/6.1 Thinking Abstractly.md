# 6.1 Thinking Abstractly

## What is Abstraction?

**Abstraction** is the process of removing unnecessary details from a problem to focus on the important features needed for a solution. It is a fundamental principle of **computational thinking**.

Abstraction involves:
- Identifying **key features** relevant to solving a problem
- Removing **excessive or irrelevant details**
- Creating a **simplified representation** of reality

## Types of Abstraction

### Representational Abstraction

**Representational abstraction** involves analysing what is relevant to a given scenario and simplifying a problem based on this information. Only the essential elements needed to solve the problem are retained.

### Abstraction by Generalisation

**Abstraction by generalisation** involves grouping together similarities within a problem to identify what kind of problem it is. This allows:
- Problems to be **categorised** as a particular type
- A **common solution** to be applied to similar problems

### Data Abstraction

**Data abstraction** hides details about how data is stored. Programmers can use **abstract data structures** (such as stacks and queues) without needing to understand their underlying implementation.

### Procedural Abstraction

**Procedural abstraction** models what a subroutine does without considering how it achieves this. Once a procedure is coded, it can be reused as a **black-box** — the user only needs to know its inputs and outputs, not its internal workings.

## Levels of Abstraction

Complex problems use **multiple levels of abstraction**, each performing a different role:

| Level | Role | Example |
|-------|------|---------|
| **Highest** | Closest to user; provides interface for interaction | GUI, application layer |
| **Lowest** | Performs actual tasks through machine code execution | Hardware operations |

Each layer hides the complexity of layers below it, allowing users and developers to work at an appropriate level of detail.

## The Need for Abstraction

Abstraction is essential because it:

- **Enables non-experts** to use complex systems without understanding underlying details
- **Improves development efficiency** by allowing programmers to focus on relevant elements
- **Reduces development time** by eliminating unnecessary complexity early
- **Prevents programs becoming unnecessarily large** by removing wasteful details
- **Makes coding accessible** to non-specialists through high-level languages

## Programming Language Abstraction

Programming languages form a hierarchy of abstraction:

| Generation | Language Type | Characteristics |
|------------|---------------|-----------------|
| **1st** | Machine code (binary) | 0s and 1s; time-consuming, tedious, error-prone |
| **2nd** | Assembly language | Mnemonics represent binary groups; processor-specific instruction sets |
| **3rd** | High-level languages (Python, Java, C) | Syntax parallels natural language; portable across platforms |

**Benefits of high-level languages:**
- Abstract away machine code complexity
- Developers don't need to manage memory directly or understand processor-specific instructions
- A single line (e.g., `A = B * C`) replaces many assembly instructions
- Allows focus on **problem-solving** rather than technical details

**Analogy:** A driver doesn't need to understand engine mechanics to drive a car; similarly, a programmer doesn't need to know all underlying technical complexity to create programs.

## Network Abstraction: TCP/IP Model

The **TCP/IP model** demonstrates abstraction in networking with four layers:

| Layer | Function |
|-------|----------|
| **Application** | User-facing protocols and interfaces |
| **Transport** | End-to-end communication management |
| **Internet** | Routing and addressing |
| **Link** | Physical network access |

Each layer:
- Deals with a **different part** of the communication process
- Does **not need to know** how other layers work
- Uses **protocols** to ensure compatibility between layers

Outgoing data passes **down** through layers; incoming data passes **up** through layers.

## Abstraction vs Reality

**Reality** is complex with many variables; **abstraction** creates a simplified, manageable representation.

### Representing Real-World Entities

| Real-World Element | Computational Representation |
|--------------------|------------------------------|
| Entities | Objects, records in databases |
| Values | Variables |
| Characteristics | Attributes |
| Actions/behaviours | Methods |
| Structures | Tables, graphs, trees |

### Object-Oriented Programming Abstraction

In **OOP**, abstraction considers:
- **Functionality** — what the object does
- **Interface** — how users interact with it
- **Properties** — characteristics of the entity

**Attributes** abstract real-world characteristics; **methods** abstract actions an object can perform.

## Data Abstraction

Programmers don't need to understand how **primitive data types** (integers, strings, booleans) are stored and represented at the hardware level.

**Abstract data types** model real-world structures:
- A **queue** models a real queue (first-in, first-out)
- Implementation details (arrays → variables → bytes → bits → flip-flops) are hidden

This separation of **what** a structure does from **how** it's implemented makes problems easier to solve and understand.

## Examples of Abstraction

### London Underground Map

The Tube map is a classic abstraction:
- **Removed:** Geographical accuracy, actual distances, surface features
- **Retained:** Station names, line connections, interchange points
- **Purpose:** Travellers only need to know that station A connects to station B — not the physical route

### Navigation/Mapping Applications

Converting a real city map for computational use:

1. **Reality:** Aerial view with roads, buildings, greenspace, complex junctions
2. **First abstraction:** Remove buildings and greenspace; retain roads and junctions
3. **Final abstraction:** Represent as a **weighted graph**
   - **Nodes** = junctions
   - **Edges/arcs** = roads
   - **Weights** = distances
   - **Directed edges** = one-way restrictions

This graph can then use algorithms like **Dijkstra's shortest path** or **A\* search**. Additional factors (traffic, roadworks, weather) can be incorporated as dynamic weights.

### Game Physics (Pong)

Pong is a highly abstracted tennis/badminton simulation:
- **Removed:** Gravity, air resistance, friction, player movement
- **Retained:** Ball movement, paddle collision, scoring
- The closer to reality, the **less abstract** (and more complex) the solution

## Devising an Abstract Model

When creating an abstract model, consider:

| Question | Consideration |
|----------|---------------|
| **What problem needs solving?** | Can it be solved computationally? What are the key features? |
| **How will the model be used?** | Required format, convenience, affordability, accessibility |
| **Who will use the model?** | Number of users, their level of expertise |
| **What is relevant?** | Remove sections not relevant to the problem; remove details that would confuse the audience |

**Key test:** If an element were removed, would it impact the solution? If not, it can be abstracted away.

## Summary

**Abstraction** separates **what** a system does from **how** it does it. It enables:
- Management of complexity
- Focus on relevant problem features
- Reuse of common solutions
- Accessibility for non-experts
- Efficient software development

The appropriate level of abstraction depends on the problem, the audience, and the purpose of the model.
