# 6.2 Thinking Ahead

## Overview

**Thinking ahead** involves anticipating the different components of a problem and how they will be handled before implementation. This allows developers to consider potential difficulties, design strategies to handle them, and create programs that are efficient, robust, and intuitive to use.

## Inputs and Outputs

### Definitions

**Inputs** are any data required to solve a problem, entered into the system by the user. When designing a solution, consider:

- The **data type** of each input
- The **order** in which data must be entered
- The **method of input** (how data is captured)

**Outputs** are the results passed back once inputs have been processed. When designing outputs, consider:

- The **data type** and **structure** of the output
- The **method of output** (how results are presented)

Outputs are not limited to screen displays — they can include visual, audio, or printed formats requiring devices such as monitors, speakers, or printers.

### Design Approach

Typically, designers:

1. First consider what **outputs are required** based on user requirements
2. Then identify the **inputs needed** to produce those outputs
3. Finally determine how inputs must be **processed** to achieve the outputs

### Example: ATM System

| Inputs | Outputs |
|--------|---------|
| Transaction type (deposit/balance check/withdrawal) | Display amount deposited on screen |
| Card details (captured via card reader) | Display account balance on screen |
| PIN (entered via keypad) | Dispense correct amount of cash |
| | Print receipt to confirm transaction |
| | Verbal feedback via speaker |

**Input devices**: Touch screen, magnetic stripe card reader, keypad

**Output devices**: Monitor, cash dispenser, printer, speakers

## Preconditions

### Definition

**Preconditions** are requirements that must be met before a program or subroutine can execute successfully. If preconditions are not met, the program will either:

- Fail to execute
- Return an invalid result
- Crash with an error

### Specifying Preconditions

Preconditions can be handled in two ways:

**1. Tested within the code** — validation checks are built into the subroutine

```
function pop():
    if top = 0 then
        print "No items in the stack."
    else:
        element = stack[top]
        top = top - 1
    endif
endfunction
```

The `pop()` function checks the stack is not empty (top > 0) before attempting to remove an item. Without this check, popping from an empty stack would cause a crash.

**2. Documented with the subroutine** — the user is responsible for ensuring inputs meet the specified requirements

Example: The `factorial` function requires **non-negative integer** inputs. Rather than checking this within the code, it is specified in the documentation.

### Benefits of Specifying Preconditions

- Subroutines can **safely expect arguments** to meet defined criteria
- **Reduces code length and complexity** when preconditions are documented
- **Saves debugging and maintenance time**
- Makes subroutines **more reusable**
- Developers know what checks are required before calling a subroutine

### Formal Definition Format

When defining preconditions formally:

```
Name: BinarySearch
Input: A list of integers my_list = (i₁, i₂, i₃, ..., iₙ)
Output: The index of the element as an integer
Preconditions: length of my_list > 0, list is sorted, type(my_list) = int
```

## Caching (HT)

### Definition

**Caching** is the process of storing instructions or values in **cache memory** after they have been used, as they may be needed again. This saves time that would otherwise be spent retrieving data from slower secondary storage.

### Applications

**Web caching**: Frequently accessed web pages are cached so that content (images, text) can be loaded without delay on subsequent visits. This also:

- Reduces the need to re-download content
- Frees up **bandwidth** for other network tasks

**Processor cache**: The CPU stores frequently used data and instructions in cache memory during program execution.

### Prefetching (HT)

**Prefetching** is an advanced caching technique where algorithms **predict which instructions are likely to be needed** and load them into cache before they are actually required.

By thinking ahead, less time is spent waiting for instructions to be loaded into RAM from secondary storage.

### Benefits of Caching

- **Faster access** to frequently used data
- **Reduced latency** when loading content
- **Bandwidth savings** (for web caching)
- **Improved overall performance** when implemented effectively

### Drawbacks of Caching

- **Algorithm accuracy** — prefetching relies on predictions which may be incorrect
- **Cache size limitations** — larger caches take longer to search, limiting how much data can be stored
- **Implementation difficulty** — effective caching algorithms can be complex to develop
- **Cache coherence** — cached data may become outdated (stale data)

## Reusable Program Components

### Definition

**Reusable program components** are pre-written, tested modules (subroutines, classes, data structures) that can be used across multiple programs or projects.

### Types of Reusable Components

- **Libraries** — collections of commonly used functions (e.g., printing, type casting, random number generation)
- **Abstract data structure implementations** — queues, stacks, linked lists
- **Classes** — object-oriented components
- **Subroutines/functions** — specific algorithms (sorting, searching)

### Connection to Decomposition

When designing software, problems are **decomposed** (broken down into smaller, simpler tasks). This allows developers to:

- Identify where **existing components** can be reused
- Plan which components need to be developed
- Consider using **externally-sourced** (third-party) components

### Benefits of Reusable Components

- **More reliable** — already tested with bugs resolved
- **Saves time, money and resources** — no need to develop from scratch
- **Consistent behaviour** — same subroutine produces predictable outputs with different arguments
- **Future reuse** — well-tested components can be used in subsequent projects
- **Reduced development costs** overall

### Drawbacks of Reusable Components

- **Compatibility issues** — third-party components may not integrate easily with existing software
- **Modification costs** — adapting incompatible components can be more expensive and time-consuming than developing in-house
- **Dependency risks** — reliance on external libraries can cause issues if they are discontinued or updated

## Summary Table

| Concept | Definition | Key Points |
|---------|------------|------------|
| **Inputs** | Data required to solve a problem | Consider data type, order, and input method |
| **Outputs** | Results returned after processing | Consider data type, structure, and output method |
| **Preconditions** | Requirements that must be met before execution | Can be tested in code or documented |
| **Caching** (HT) | Storing data in cache for faster future access | Saves time but limited by cache size and algorithm accuracy |
| **Prefetching** (HT) | Predicting and pre-loading data before needed | Reduces wait times but depends on prediction accuracy |
| **Reusable components** | Pre-tested modules for use across projects | Save time and increase reliability; may have compatibility issues |
