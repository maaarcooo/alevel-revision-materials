# 6.3 Thinking Procedurally

## Overview

**Thinking procedurally** is an approach to problem-solving that breaks down complex problems into smaller, manageable parts. It simplifies program design by making problems easier to understand and implement.

The key stages of thinking procedurally are:
1. Identify the components of a problem
2. Identify the components of a solution
3. Determine the order of steps needed to solve the problem
4. Identify sub-procedures necessary to solve the problem

---

## Identifying the Components of a Problem

### Abstraction

**Abstraction** is the process of removing unimportant details from a real problem and focusing on the details that will form part of the solution.

**Examples of abstraction:**
- **Modelling environments**: A garden or football field in a game doesn't require modelling every blade of grass — a green mesh or image suffices
- **Saving files**: Users don't need to know the underlying procedures for writing to disk or how the OS handles paging and segmentation
- **Sending email**: Users don't need to know about protocols, data formatting, or handshaking procedures
- **Downloading content**: Users don't need to understand digital certificates, signatures, or protocol details

### Problem Decomposition

**Problem decomposition** is the process of breaking down a large, complex problem into smaller **subproblems** that can be solved more easily.

**Benefits of decomposition:**
- Makes problems more feasible to manage
- Allows work to be divided among a team according to individual skill sets
- Each component becomes easier to understand and design

**Example — Adventure Game Decomposition:**
- Characters → Character interactions, Character appearance
- Adventures → Levels, Backgrounds and settings
- Enemies → Enemy interactions, Enemy appearance

### Top-Down Design

**Top-down design** (also called **stepwise refinement**) is the preferred method for approaching large problems. It breaks problems down into levels:
- **Higher levels** provide an overview of the problem
- **Lower levels** specify the detailed components

**The aim of top-down design** is to keep splitting problems into subproblems until each subproblem can be represented as a **single task** and ideally a **self-contained module or subroutine**.

**Advantages:**
- Each task can be developed as a subroutine by a different person
- Subroutines can be **tested separately** before integration
- Reduces complexity by identifying where **reusable components** (existing modules, subroutines, or libraries) can be used

---

## Identifying the Components of a Solution

Once problem components are identified, the matching **solution components** can be determined. This stage considers the implementation details of each component.

### Technical Considerations

When identifying solution components, programmers must consider:
- **Input parameter and output data types**: Integer, real/float, string, boolean, etc.
- **Data structures required**: Array, list, dictionary, linked list, hash table
- **Libraries required**: Statistics module, math module, etc.
- **Output format**: Array, list, dictionary, output string
- **Data transformations and constructs**: Mathematical operations, loops (for, while), selection (if, case)
- **Algorithm efficiency**: Does the algorithm need to be O(n) or less?

### Example — Book Reservation System Components

| Component | Implementation |
|-----------|----------------|
| **Borrower name** | Procedure `getName()` that checks if user is signed in, queries database for borrower name by ID, or redirects to login/register |
| **Book details** | Function returning the ISBN of the selected book from user text input |
| **Collection location** | Function returning user-selected location via drop-down field (prevents erroneous data entry) |
| **Check book availability** | Function returning `True` if book is available, `False` if on loan (requires database query) |

### Procedural Abstraction

**Procedural abstraction** means using a procedure to execute sequences of instructions to achieve a goal. Once initial solution components are identified, the procedure can be **decomposed into more detailed instructions**.

More complex problems may require larger programs consisting of many **subroutines** that call each other or use imported **library subroutines**.

> **Note**: In this context, "procedure" refers to a unit of computation that performs a single task. Technically, a **function** returns a value while a **procedure** does not.

---

## Determining the Order of Steps

When constructing the final solution, the **order in which operations are performed** is critical.

### Key Considerations

- **Input dependencies**: Some programs require certain inputs before processing can occur
- **Validation**: Inputs must be validated before being passed to subsequent subroutines
- **Data dependencies**: Some subroutines require data from other subroutines before they can execute
- **Simultaneous execution**: Identify where subroutines can run concurrently (when they don't depend on each other's output)

### Sequencing Requirements

Programmers must determine:
- The **order in which subroutines are executed**
- **How subroutines interact** with each other based on their role in solving the problem

**Example — Book Reservation System:**
Without user input, the rest of the program cannot execute. Validation checks must confirm input validity before data is passed between subroutines.

### Practical Sequencing Examples

Programs must be built to ensure operations are not carried out in an illogical order:

| Scenario | Correct Sequence |
|----------|------------------|
| Adventure game | Users cannot access locked levels before completing previous ones |
| Food delivery app | Location must be confirmed before food selection; order must be confirmed before payment |

Although these sequences seem obvious to humans, they must be **explicitly written into software** for programs to work correctly.

### Example — Grade Calculation Steps

1. **Calculate grade for each assessment**
   - Mark each question and store the value
   - Sum the values of all marked questions

2. **Calculate average grade for each student**
   - Add up grades for each assessment
   - Divide by number of assessments
   - Store the result

3. **Repeat steps 1-2 for each class**

---

## Identifying Sub-Procedures

Problems can be decomposed using tables and lists, but larger problems are better represented with **diagrams**.

### Hierarchy Charts

A **hierarchy chart** is a diagram used to show problem decomposition:
- Each problem is divided into multiple **subproblems**
- Subproblems are further divided until they cannot be broken down any more
- Shows how **modules and subroutines relate** to each other
- Depicted as a **tree structure**
- Can be created on paper, digitally, or programmatically

**Properties of well-decomposed sub-tasks:**
- **Cannot be broken down further**
- **Easily solved**
- **Clear in purpose**

### Advantages of Decomposition into Sub-Procedures

| Advantage | Explanation |
|-----------|-------------|
| **Simpler testing** | Each subroutine can be tested individually using unit testing |
| **Easier maintenance** | Self-contained, well-documented subroutines make it easier to find and fix errors |
| **Reusability** | Subroutines can be reused rather than rewriting code |
| **Team collaboration** | Tasks can be delegated to different developers |

### Example — Mobile Phone Hierarchy

```
MOBILE PHONE
├── VOICE CALLS
│   ├── VIBRATE
│   ├── RECEIVE VOICE
│   ├── RECEIVE DATA
│   ├── CONVERT TO ANALOGUE
│   └── SEND VOICE
│       ├── CAPTURE VOICE
│       ├── CONVERT TO DIGITAL
│       └── TRANSMIT TO NETWORK
├── TEXT MESSAGES
│   └── ...
└── CONTACT DATA STORE
    └── ...
```

---

## Summary of Key Terms

| Term | Definition |
|------|------------|
| **Thinking procedurally** | Breaking problems into smaller parts to simplify program design |
| **Abstraction** | Removing unimportant details to focus on solution-relevant components |
| **Problem decomposition** | Breaking a complex problem into smaller, solvable subproblems |
| **Top-down design** | Breaking problems into levels, from overview to detailed components |
| **Stepwise refinement** | Alternative term for top-down design |
| **Procedural abstraction** | Using procedures to execute instruction sequences for a goal |
| **Hierarchy chart** | Tree diagram showing problem decomposition and module relationships |
| **Subroutine** | Self-contained unit of code that performs a specific task |

---

## Exam Tips

- When asked to describe sub-procedures, explain both **what the procedure does** and **how it contributes to solving the problem**
- Basic input procedures (e.g., "move left/right") are typically not credit-worthy — focus on procedures that process or transform data
- Remember that sequencing constraints must be **explicitly programmed** — they are not implicit in code
